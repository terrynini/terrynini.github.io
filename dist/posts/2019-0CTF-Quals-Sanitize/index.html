<!DOCTYPE html><html lang="en"> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><link rel="icon" type="image/png" href="/favicon.png"><meta name="generator" content="Astro v5.11.1"><title>NiNi's Den. CyberSec Blog</title><link rel="stylesheet" href="/src/styles/cyber-space-theme.css"><link rel="stylesheet" href="/src/styles/light-theme.css"><style>.post-image-wrapper[data-astro-cid-no5unav3]{margin:1.5em auto;max-width:100%;position:relative;display:inline-block}.post-image-wrapper[data-astro-cid-no5unav3]:before{content:"";position:absolute;top:0;left:0;width:100%;height:100%;background-color:rgba(var(--color-accent-r),var(--color-accent-g),var(--color-accent-b),1);mix-blend-mode:color;pointer-events:none;transition:opacity .3s ease-in-out;opacity:1}.post-image-wrapper[data-astro-cid-no5unav3]:hover:before{opacity:0}.post-image[data-astro-cid-no5unav3]{display:block;max-width:100%;height:auto;border:1px solid var(--color-border);box-shadow:0 0 10px #0009;transition:all .3s ease-in-out}.post-image[data-astro-cid-no5unav3]:hover{filter:brightness(1) contrast(1);box-shadow:0 0 15px rgba(var(--color-accent-r),var(--color-accent-g),var(--color-accent-b),.7)}
</style></head> <body style="margin: 0; padding-top: 60px;"> <script>
            // Apply theme from localStorage immediately to prevent FOUC
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                document.body.classList.add(savedTheme);
            } else {
                document.body.classList.add('theme-light'); // Default theme
                localStorage.setItem('theme', 'theme-light');
            }
        </script> <button id="theme-toggle" class="theme-toggle-btn">
切換主題
</button> <nav class="main-nav"> <ul class="main-nav-list"> <li class="main-nav-item"><a href="/" class="main-nav-link">Home</a></li> <li class="main-nav-item"><a href="/about" class="main-nav-link">About</a></li> </ul> </nav>  <div class="article-page-wrapper"> <aside class="author-hud"> <div class="author-hud-content glitchable"> <img src="//avatars2.githubusercontent.com/u/15998206" alt="NiNi's avatar" class="author-avatar"> <div class="author-info"> <h4><a href="https://balsn.tw/">NiNi</a></h4> <p class="title">Security Researcher</p> </div> </div> </aside> <div class="container"> <article class="post-content"> <h1>2019::0CTF::Quals::Sanitize</h1> <p class="post-meta">Published: 2019-03-27 | Category: CTF</p> <p>Play with Balsn this time and got 12th place, teamates are really amazing.
I just slept late at the weekend…, there was only a reverse challenge left …
Though, they release the sixology on the last day,  we almost solve that, but I did not notice that the compare operation in the bubble sort is lexicographically…</p>
<h1 id="tldr">TL;DR</h1>
<p>binary search</p>
<pre><code>{}cmp_char_here
3
guess_position_here 4 47
</code></pre>
<p><code>flag{fr0M_C0vEr4ge_To_Fl4G_And_Enj0Y_0cTF_2Ol9!}</code></p>
<h1 id="detail">detail</h1>
<p>The binary expects us to input a string , and pick some characters from the flag string, then the binary would perform sorting on these characters. At the end of the binary, it prints out the record of it’s code coverage. Which means that we may recover the control flow of binary from these information which sounds difficult. And the key point is what kind of sorting was implemented in the binary.</p>
<p>The below is the detail of the sorting implemented in the binary, take input as <code>123\n3\n1 2 5\n</code> for example, which means that take the char at <code>flag[1]</code>,<code>flag[2]</code>,<code>flag[5]</code>, and sort these chars with string <code>123</code> together. (Newline would affect the code coverage)</p>
<p>The user input <code>123</code> would be processed first, then the characters from flag string.</p>
<p>And the phases of sorting can be summarize as follow :</p>
<ol>
<li>Build up a List</li>
<li>Build a charObject which has <code>sub_list</code>,<code>sub_list_len</code>,<code>char_value</code>,<code>next</code>,<code>parent</code></li>
<li>Insert the charObject to the List base on the value of <code>sub_list_len</code>,which should initialize as<code>0</code>. If there were already some objects with 0 <code>sub_list_len</code>,the new object would be inserted at the tail of them (it’s actually not the length, just for convenience)</li>
<li>Compare last two object at row of charObject with same <code>sub_list_len</code> value</li>
<li>The bigger one would be put into the sublist of the other one</li>
<li>Go back to 2. if there are still chars remaining.</li>
</ol>
<p>So, it look like</p>
<pre><code>input :
123
3
1 2 5
#Assume that the flag at remote is &#39;flag{???????????}&#39;
List -&gt; null 

List -&gt; &#39;1&#39;

List -&gt; &#39;1&#39; -&gt; &#39;2&#39;

List -&gt; &#39;1&#39;
         |
        &#39;2&#39;
        
List -&gt; &#39;3&#39; -&gt; &#39;1&#39;
                |
               &#39;2&#39;
               
List -&gt; &#39;l&#39; -&gt; &#39;3&#39; -&gt; &#39;1&#39;
                       |
                      &#39;2&#39;
                      
List -&gt; &#39;3&#39; -&gt; &#39;1&#39;
         |      |
        &#39;l&#39;    &#39;2&#39;
        
List -&gt; &#39;a&#39; -&gt; &#39;1&#39;
                |
               &#39;2&#39;
                |
               &#39;3&#39;
                |
               &#39;l&#39;
               
List -&gt; &#39;a&#39; -&gt; unknown_char -&gt;  &#39;1&#39;
                                 |
                                &#39;2&#39;
                                 |
                                &#39;3&#39;
                                 |
                                &#39;l&#39;
</code></pre>
<p>At this point, the last char, which is <code>flag[5]</code> would be compare with char <code>a</code>, according to the result (<code>&gt;</code> or <code>&lt;=</code>), the binary would give us two different code coverage, but the problem here is we can only compare the last char,<code>flag[4]</code> here, with the other char , <code>flag[1] ==&#39;a&#39;</code> here , which was also from flag string.</p>
<p>If we change the order of the input slightly:</p>
<pre><code>123
3
5 1 2
</code></pre>
<p>Now we can compare the unknown char from string with our input, but the new problem is the code coverage is implemented by a bunch of counter, the flow after this compare may cause them looks the same. So we have to construct a string which make the binary branch predictable. That is :</p>
<pre><code>{}A
3
5 4 47
</code></pre>
<p>The <code>flag[4]</code> and <code>flag[47]</code> are <code>{</code> and <code>}</code> respectively, this input make the path of sorting more predictable due to<code>{</code> and <code>}</code> are almost bigeer than all ascii. The fun fact here is the last char of flag is <code>\n</code>.</p>
<h1 id="exploit">exploit</h1>
<pre><code class="language-python=">from pwn import *
import string

context.log_level =&#39;error&#39;
charset = sorted(list(string.printable[:-5]))

flag = []

def bsearch(idx,pos):
    p = remote(&quot;111.186.63.16&quot;,20193)
    p.sendline(&quot;{}&quot;+charset[idx]) 
    p.send(&quot;3\n&quot;+str(k)+&quot;\n4\n47\n&quot;)
    ret = p.recv()
    p.close()
    return ret

for k in range(5,47):
    lower = 0
    upper = len(charset)-1
    l_st= bsearch(lower, k)
    u_st = bsearch(upper, k)

    while lower &lt; upper:
        mid =  (lower+upper)/2 
        if (bsearch(mid,k) == l_st):
            lower = mid + 1
        else:
            upper = mid

    flag.append(charset[lower-1])
    print &quot;flag{&quot;+&#39;&#39;.join(flag)+&quot;}&quot;
</code></pre> </article> </div> <aside class="article-outline-hud" data-augmented-ui="tl-clip tr-clip br-clip bl-clip border"> <div class="article-outline-hud-content glitchable"> <h2>文章大綱</h2> <nav> <ul> <li> <a href="#tldr">TL;DR</a> </li><li> <a href="#detail">detail</a> </li><li> <a href="#exploit">exploit</a> </li> </ul> </nav> </div> </aside> </div> <div id="persistent-notes-overlay"></div> <script>
        document.addEventListener('DOMContentLoaded', () => {
            const highlightElements = document.querySelectorAll('.persistent-highlight');
            const notesOverlay = document.getElementById('persistent-notes-overlay');
            const containerElement = document.querySelector('.container');

            const positionNotes = () => {
                notesOverlay.innerHTML = ''; 
                if (!containerElement) return; 

                
                if (window.innerWidth > 1024) {
                    const containerRect = containerElement.getBoundingClientRect();
                    const noteWidth = 220; 
                    const margin = 60; 

                    highlightElements.forEach(highlightEl => {
                        const noteId = highlightEl.dataset.noteId;
                        const noteText = highlightEl.dataset.noteText; 

                        const rect = highlightEl.getBoundingClientRect();

                        const noteDiv = document.createElement('div');
                        noteDiv.className = 'persistent-note-item';
                        noteDiv.setAttribute('data-note-id', noteId);
                        noteDiv.innerHTML = `<p>${noteText}</p>`;

                        
                        noteDiv.style.position = 'absolute'; 
                        noteDiv.style.top = `${rect.top}px`; 
                        noteDiv.style.left = `${containerRect.left - noteWidth - margin}px`; 
                        noteDiv.style.width = `${noteWidth}px`;

                        notesOverlay.appendChild(noteDiv);

                        
                        highlightEl.addEventListener('mouseenter', () => {
                            noteDiv.classList.add('sci-fi-active');
                        });
                        highlightEl.addEventListener('mouseleave', () => {
                            noteDiv.classList.remove('sci-fi-active');
                        });

                        
                        noteDiv.addEventListener('mouseenter', () => {
                            highlightEl.classList.add('highlight-active');
                        });
                        noteDiv.addEventListener('mouseleave', () => {
                            highlightEl.classList.remove('highlight-active');
                        });
                    });
                }
            };

            
            positionNotes();

            
            window.addEventListener('scroll', positionNotes);
            window.addEventListener('resize', positionNotes);
        });
    </script> <style>
        
        .post-content img {
            max-width: 100%;
            height: auto;
            display: block; 
            margin: 0 auto; 
        }

        

        #persistent-notes-overlay {
            position: fixed; 
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none; 
            z-index: 5; 
        }

        @media (max-width: 1200px) {
            #persistent-notes-overlay {
                display: none; 
            }
        }

        .persistent-note-item {
            pointer-events: auto; 
            
        }
    </style>  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" style="position: absolute; top: -9999px; left: -9999px;"> <defs> <filter id="dist-01"> <feTurbulence id="turbulence" baseFrequency="0.02" numOctaves="8" result="noise" seed="0"></feTurbulence> <feConvolveMatrix in="noise" order="3" result="snoise" kernelMatrix="
						0  -1   0
						-1   5  -1
						0  -1   0    
					"></feConvolveMatrix> <feDisplacementMap id="displacement" in="SourceGraphic" in2="snoise" scale="6"></feDisplacementMap> </filter> <filter id="dist-02"> <feTurbulence id="turbulence" baseFrequency="0.2" numOctaves="8" result="noise" seed="1"></feTurbulence> <feConvolveMatrix in="noise" order="3" result="snoise" kernelMatrix="
						0  -1   0
						-1   5  -1
						0  -1   0    
					"></feConvolveMatrix> <feDisplacementMap id="displacement" in="SourceGraphic" in2="snoise" scale="6"></feDisplacementMap> </filter> <filter id="dist-03"> <feTurbulence id="turbulence" baseFrequency="0.01" numOctaves="6" result="noise" seed="2"></feTurbulence> <feConvolveMatrix in="noise" order="3" result="snoise" kernelMatrix="
						0  -1   0
						-1   5  -1
						0  -1   0    
					"></feConvolveMatrix> <feDisplacementMap id="displacement" in="SourceGraphic" in2="snoise" scale="6"></feDisplacementMap> </filter> <filter id="dist-04"> <feTurbulence id="turbulence" baseFrequency="0.01" numOctaves="6" result="noise" seed="2" type="fractalNoise"></feTurbulence> <feDisplacementMap id="displacement" in="SourceGraphic" in2="noise" scale="6"></feDisplacementMap> </filter> <!-- Additional Glitch Filters for more variety --> <filter id="dist-05"> <feTurbulence baseFrequency="0.05" numOctaves="4" result="noise" seed="3"></feTurbulence> <feDisplacementMap in="SourceGraphic" in2="noise" scale="10"></feDisplacementMap> </filter> <filter id="dist-06"> <feTurbulence baseFrequency="0.1" numOctaves="2" result="noise" seed="4"></feTurbulence> <feDisplacementMap in="SourceGraphic" in2="noise" scale="8"></feDisplacementMap> </filter> <filter id="dist-07"> <feTurbulence baseFrequency="0.03" numOctaves="6" result="noise" seed="5" type="fractalNoise"></feTurbulence> <feDisplacementMap in="SourceGraphic" in2="noise" scale="12"></feDisplacementMap> </filter> <filter id="dist-08"> <feTurbulence baseFrequency="0.08" numOctaves="3" result="noise" seed="6"></feTurbulence> <feDisplacementMap in="SourceGraphic" in2="noise" scale="5"></feDisplacementMap> </filter> </defs> </svg> <script>
            document.addEventListener('DOMContentLoaded', () => {
                const glitchableElements = document.querySelectorAll('.glitchable');
                const filters = ['dist-01', 'dist-02', 'dist-03', 'dist-04', 'dist-05', 'dist-06', 'dist-07', 'dist-08'];

                glitchableElements.forEach(el => {
                    function applyGlitch() {
                        const randomFilterId = filters[Math.floor(Math.random() * filters.length)];
                        const glitchDuration = 0.08//Math.random() * (0.1 - 0.05) + 0.05; // Glitch lasts between 0.05 and 0.1 seconds
                        const delayBeforeNextGlitch = Math.random() * (6 - 3) + 3; // Next glitch in 0.5 to 2 seconds

                        el.style.filter = `url(#${randomFilterId})`;

                        setTimeout(() => {
                            el.style.filter = 'none';
                            setTimeout(applyGlitch, delayBeforeNextGlitch * 1000);
                        }, glitchDuration * 1000);
                    }

                    // Initial glitch after a random delay
                    setTimeout(applyGlitch, Math.random() * 3000); // Initial delay up to 3 seconds
                });

                // Theme switching logic
                const themeToggleBtn = document.getElementById('theme-toggle');
                const body = document.body;

                function toggleTheme() {
                    if (body.classList.contains('theme-red')) {
                        body.classList.remove('theme-red');
                        body.classList.add('theme-purple');
                        localStorage.setItem('theme', 'theme-purple');
                    } else if (body.classList.contains('theme-purple')) {
                        body.classList.remove('theme-purple');
                        body.classList.add('theme-blue');
                        localStorage.setItem('theme', 'theme-blue');
                    } else if (body.classList.contains('theme-blue')) {
                        body.classList.remove('theme-blue');
                        body.classList.add('theme-light');
                        localStorage.setItem('theme', 'theme-light');
                    } else {
                        body.classList.remove('theme-light');
                        body.classList.add('theme-red');
                        localStorage.setItem('theme', 'theme-red');
                    }
                }

                if (themeToggleBtn) {
                    themeToggleBtn.addEventListener('click', toggleTheme);
                }
            });
        </script> <script type="module">document.addEventListener("DOMContentLoaded",function(){document.querySelectorAll(".persistent-highlight").forEach(t=>{const s=t.dataset.noteId,o=t.dataset.noteText;if(!t||!s||!o)return;let e=null;e=document.createElement("div"),e.className="persistent-note-block",e.dataset.noteId=s,e.innerHTML=`<p>${o}</p>`;let n=t.closest("p");if(n===null){let a=t;for(;a&&a.nextElementSibling;)if(a=a.nextElementSibling,a.tagName==="P"){n=a;break}}n&&n.parentNode&&n.parentNode.insertBefore(e,n.nextSibling),t.addEventListener("mouseenter",()=>{e.classList.add("glow-active")}),t.addEventListener("mouseleave",()=>{e.classList.remove("glow-active")}),e.addEventListener("mouseenter",()=>{t.classList.add("highlight-active"),e.classList.add("glow-active")}),e.addEventListener("mouseleave",()=>{t.classList.remove("highlight-active"),e.classList.remove("glow-active")})})});</script> </body> </html>