<!DOCTYPE html><html lang="en"> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><link rel="icon" type="image/png" href="/favicon.png"><meta name="generator" content="Astro v5.11.1"><title>NiNi's Den. CyberSec Blog</title><link rel="stylesheet" href="/src/styles/cyber-space-theme.css"><link rel="stylesheet" href="/src/styles/light-theme.css"><style>.post-image-wrapper[data-astro-cid-no5unav3]{margin:1.5em auto;max-width:100%;position:relative;display:inline-block}.post-image-wrapper[data-astro-cid-no5unav3]:before{content:"";position:absolute;top:0;left:0;width:100%;height:100%;background-color:rgba(var(--color-accent-r),var(--color-accent-g),var(--color-accent-b),1);mix-blend-mode:color;pointer-events:none;transition:opacity .3s ease-in-out;opacity:1}.post-image-wrapper[data-astro-cid-no5unav3]:hover:before{opacity:0}.post-image[data-astro-cid-no5unav3]{display:block;max-width:100%;height:auto;border:1px solid var(--color-border);box-shadow:0 0 10px #0009;transition:all .3s ease-in-out}.post-image[data-astro-cid-no5unav3]:hover{filter:brightness(1) contrast(1);box-shadow:0 0 15px rgba(var(--color-accent-r),var(--color-accent-g),var(--color-accent-b),.7)}
</style></head> <body style="margin: 0; padding-top: 60px;"> <script>
            // Apply theme from localStorage immediately to prevent FOUC
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                document.body.classList.add(savedTheme);
            } else {
                document.body.classList.add('theme-light'); // Default theme
                localStorage.setItem('theme', 'theme-light');
            }
        </script> <button id="theme-toggle" class="theme-toggle-btn">
切換主題
</button> <nav class="main-nav"> <ul class="main-nav-list"> <li class="main-nav-item"><a href="/" class="main-nav-link">Home</a></li> <li class="main-nav-item"><a href="/about" class="main-nav-link">About</a></li> </ul> </nav>  <div class="article-page-wrapper"> <aside class="author-hud"> <div class="author-hud-content glitchable"> <img src="//avatars2.githubusercontent.com/u/15998206" alt="NiNi's avatar" class="author-avatar"> <div class="author-info"> <h4><a href="https://balsn.tw/">NiNi</a></h4> <p class="title">Security Researcher</p> </div> </div> </aside> <div class="container"> <article class="post-content"> <h1>2021::QEMU::AFL++ and TCG</h1> <p class="post-meta">Published: 2021-05-29 | Category: QEMU</p> <p>Rewriting some of notes in my obsidian into a post seems to be a good idea.</p>
<h2 id="tcg">TCG</h2>
<p>TCG is abbreviation of Tiny Code Generator, the TCG frontend lifts target instructions into TCG-IR and the TCG backend lowers the TCG-IR into host instructions. The <a href="https://github.com/qemu/qemu/tree/master/tcg#readme">tcg/README</a> is a good place to start.</p>
<p>Because TCG-IR is relatively simple, some target instructions are hard to be implemented by pure TCG-IR. Helper functions provides another way to implement these instruction.</p>
<h2 id="code-review">Code Review</h2>
<p>Take QEMU-5.0.0-rc4 for example, how QEMU emulating <code>syscall</code> instruction of i386 is at line 7381 of <code>target/i386/tcg/translate.c</code> :</p>
<pre><code class="language-c" metastring="target/i386/tcg/translate.c =7381">#ifdef TARGET_X86_64

    case 0x105: /* syscall */
        /* XXX: is it usable in real mode ? */
        gen_update_cc_op(s);
        gen_jmp_im(s, pc_start - s-&gt;cs_base);
        gen_helper_syscall(cpu_env, tcg_const_i32(s-&gt;pc - pc_start));
        /* TF handling for the syscall insn is different. The TF bit is  checked
           after the syscall insn completes. This allows #DB to not be
           generated after one has entered CPL0 if TF is set in FMASK.  */
        gen_eob_worker(s, false, true);
        break;

</code></pre>
<p>Functions with prefix <code>gen</code> are responsible for generating corresponding <a href="https://wiki.qemu.org/Documentation/TCG/backend-ops">backend-ops</a>, but <code>get_helper_syscall</code> is more special.</p>
<p>The function <code>get_helper_syscall</code> will insert a call backend-op into TCG code, and the target of the call instruction is function <code>helper_syscall</code>, which is at line 979 of <code>target/i386/tcg/seg_helper.c</code>. (use <code>CONFIG_USER_ONLY</code> to choose different implementation for user mode emulation and full system emulation)</p>
<pre><code class="language-c" metastring="target/i386/tcg/seg_helper.c =979">#ifdef TARGET_X86_64
#if defined(CONFIG_USER_ONLY)
void helper_syscall(CPUX86State *env, int next_eip_addend)
{
    ...
}
#else
void helper_syscall(CPUX86State *env, int next_eip_addend)
{
	...
}
#endif
#endif
</code></pre>
<p>So, calling a custom helper function from TCG is easy, takes AFL++ for example.</p>
<h2 id="afl-and-tcg">AFL++ and TCG</h2>
<p>AFL++ is the community version of well-known coverage-based greybox fuzzer AFL, the way it used to track the code coverage during fuzzing process is to insert a instruction to call function <code>afl_maybe_log</code> at the beginning of each basic block at compile time.</p>
<p>The function <code>afl_maybe_log</code> will add the corresponding element by 1 in the bitmap shared with AFL++, and the way to index the bitmap is using the hash value of token of current basic block and previous basic block ( <code>cur_loc</code> and <code>afl_prev_loc</code> ), and the token value was assigned randomly at compile time.</p>
<pre><code class="language-c">cur_loc = 0x123;
afl_area_ptr[cur_loc ^ afl_prev_loc]++;
afl_prev_loc = cur_loc &gt;&gt; 1;
</code></pre>
<p>In a scenario where the source code is unavailable, which is very common, it’s not possible to insert <code>afl_maybe_log</code> at compile time, so AFL++ has QEMU mode to perform the so-called dynamic instrumentation.</p>
<p>AFL++ use it’s own forked version of QEMU, <a href="https://github.com/AFLplusplus/qemuafl">qemuafl</a>, which will insert <code>afl_maybe_log</code> into TCG-IR while generating TCG-IR of each basic block so it can benefit from block chaining.</p>
<p>To add a new helper, we need to declare the helper function at <code>accel/tcg/tcg-runtime.h</code> , or if the helper only works on specific architecture, it should be declared at <code>target/&lt;arch&gt;/helper.h</code> .</p>
<pre><code class="language-c" metastring="accel/tcg/tcg-runtime.h">DEF_HELPER_FLAGS_1(afl_maybe_log, TCG_CALL_NO_RWG, void, tl)

</code></pre>
<p>The <code>N</code> of macro <code>DEF_HELPER_FLAGS_N</code> means the number of arguments, this macro will declare a function <code>helper_afl_maybe_log</code> which returns nothing and takes one argument.</p>
<p>The <code>TCG_CALL_NO_RWG</code> is alias of <code>TCG_CALL_NO_READ_GLOBALS</code>, it means helper does not read globals (either directly or through an exception). It implies <code>TCG_CALL_NO_WRITE_GLOBALS</code>.</p>
<p>The definition of <code>DEF_HELPER_FLAGS_1</code> in <code>exec/helper-proto.h</code> is:</p>
<pre><code class="language-c" metastring="exec/helper-proto.h">#define DEF_HELPER_FLAGS_1(name, flags, ret, t1) \
dh_ctype(ret) HELPER(name) (dh_ctype(t1));
</code></pre>
<p>But why we need a macro only for declaration? And where it use the <code>flags</code> variable? It’s actually a cool macro trick here!</p>
<p>Actually, the macro <code>DEF_HELPER_FLAGS_1</code> was undefined  at the end of the <code>exec/helper-proto.h</code> :</p>
<pre><code class="language-c" metastring="exec/helper-proto.h">#undef DEF_HELPER_FLAGS_0
#undef DEF_HELPER_FLAGS_1
#undef DEF_HELPER_FLAGS_2
#undef DEF_HELPER_FLAGS_3
#undef DEF_HELPER_FLAGS_4
#undef DEF_HELPER_FLAGS_5
#undef DEF_HELPER_FLAGS_6
#undef DEF_HELPER_FLAGS_7

#endif /* HELPER_PROTO_H */

</code></pre>
<p>Let’s take a look at <code>include/tcg/tcg-op.h</code> , which includes two files:</p>
<pre><code class="language-c" metastring="include/tcg/tcg-op.h">#include &quot;exec/helper-proto.h&quot;
#include &quot;exec/helper-gen.h&quot;
</code></pre>
<p>Surprisingly, there is another definition of <code>DEF_HELPER_FLAGS_1</code> in <code>exec/helper-gen.h</code> !</p>
<pre><code class="language-c" metastring="exec/helper-gen.h">#define DEF_HELPER_FLAGS_1(name, flags, ret, t1)                        \
static inline void glue(gen_helper_, name)(dh_retvar_decl(ret)          \

    dh_arg_decl(t1, 1))                                                 \

{                                                                       \
  TCGTemp *args[1] = { dh_arg(t1, 1) }; \
  tcg_gen_callN(HELPER(name), dh_retvar(ret), 1, args); \
}

</code></pre>
<p>As we can see, this is used to define another function <code>gen_helper_afl_maybe_log</code> here. The first argument of <code>tcg_gen_callN</code> is the target of call instruction, which is <code>HELPER(name)</code> here. The macro <code>HELPER</code> is used to insert <code>helper_</code> in front of the given name. What <code>gen_helper_afl_maybe_log</code> do is to generate a call instruction to call <code>helper_afl_maybe_log</code> in TCG code !</p>
<p>After the declaration, next step is defining it, qemuafl defines the function <code>helper_afl_maybe_log</code> in the <code>accel/tcg/translate-all.c</code> :</p>
<pre><code class="language-c" metastring="accel/tcg/translate-all.c =71">void HELPER(afl_maybe_log)(target_ulong cur_loc)
{

    register uintptr_t afl_idx = cur_loc ^ afl_prev_loc;

    INC_AFL_AREA(afl_idx);

    afl_prev_loc = cur_loc &gt;&gt; 1;
}
</code></pre>
<p>Now, it’s possible to call the custom function from TCG. As mentioned, AFL++ insert <code>afl_may_log</code> at the beginning of each basic block to gather the coverage information during fuzzing. Because QEMU also uses basic block as a unit while translating TCG code into host code, it’s easy to  insert <code>afl_may_log</code> at the beginning of each basic block.</p>
<p>In the function <code>tb_gen_code</code> , we can observe that qemuafl call function <code>afl_gen_trace(pc)</code> before generating machine code:</p>
<pre><code class="language-c" metastring="accel/tcg/translate-all.c">
    tcg_ctx-&gt;cpu = env_cpu(env);
    afl_gen_trace(pc);
    gen_intermediate_code(cpu, tb, max_insns);
    tcg_ctx-&gt;cpu = NULL;
    max_insns = tb-&gt;icount;

    trace_translate_block(tb, tb-&gt;pc, tb-&gt;tc.ptr);

    /* generate machine code */

</code></pre>
<p>Let’s inspect the definition of <code>afl_gen_trace</code> and highlight the last three lines:</p>
<pre><code class="language-c" metastring="accel/tcg/translate-all.c">/* Generates TCG code for AFL&#39;s tracing instrumentation. */
static void afl_gen_trace(target_ulong cur_loc) {

  ...

  TCGv cur_loc_v = tcg_const_tl(cur_loc);
  gen_helper_afl_maybe_log(cur_loc_v);
  tcg_temp_free(cur_loc_v);

}
</code></pre>
<p>To use <code>gen_helper_afl_maybe_log</code> to generate a call in TCG code, the parameter have to be converted to TCG variables, <code>tcg_const_tl(cur_loc_v)</code> is used to generate a TCG temporary with value <code>cur_loc</code> , and although it’s “const”, it did create a temporary, we have to free it after use to reduce the memory usage.</p>
<h2 id="end">End</h2>
<p>And, that’s it, qemuafl inserts a call instruction at the beginning of each basic block’s TCG code, once a basic block is being executed, it must call the custom helper function, <code>HELPER(afl_maybe_log)</code>, to record the code coverage first. AFL is actually using the same strategy, but I was reviewing the source code of AFL++, I use it as example here.</p> </article> </div> <aside class="article-outline-hud" data-augmented-ui="tl-clip tr-clip br-clip bl-clip border"> <div class="article-outline-hud-content glitchable"> <h2>文章大綱</h2> <nav> <ul> <li> <a href="#tcg">TCG</a> </li><li> <a href="#code-review">Code Review</a> </li><li> <a href="#afl-and-tcg">AFL++ and TCG</a> </li><li> <a href="#end">End</a> </li> </ul> </nav> </div> </aside> </div> <div id="persistent-notes-overlay"></div> <script>
        document.addEventListener('DOMContentLoaded', () => {
            const highlightElements = document.querySelectorAll('.persistent-highlight');
            const notesOverlay = document.getElementById('persistent-notes-overlay');
            const containerElement = document.querySelector('.container');

            const positionNotes = () => {
                notesOverlay.innerHTML = ''; 
                if (!containerElement) return; 

                
                if (window.innerWidth > 1024) {
                    const containerRect = containerElement.getBoundingClientRect();
                    const noteWidth = 220; 
                    const margin = 60; 

                    highlightElements.forEach(highlightEl => {
                        const noteId = highlightEl.dataset.noteId;
                        const noteText = highlightEl.dataset.noteText; 

                        const rect = highlightEl.getBoundingClientRect();

                        const noteDiv = document.createElement('div');
                        noteDiv.className = 'persistent-note-item';
                        noteDiv.setAttribute('data-note-id', noteId);
                        noteDiv.innerHTML = `<p>${noteText}</p>`;

                        
                        noteDiv.style.position = 'absolute'; 
                        noteDiv.style.top = `${rect.top}px`; 
                        noteDiv.style.left = `${containerRect.left - noteWidth - margin}px`; 
                        noteDiv.style.width = `${noteWidth}px`;

                        notesOverlay.appendChild(noteDiv);

                        
                        highlightEl.addEventListener('mouseenter', () => {
                            noteDiv.classList.add('sci-fi-active');
                        });
                        highlightEl.addEventListener('mouseleave', () => {
                            noteDiv.classList.remove('sci-fi-active');
                        });

                        
                        noteDiv.addEventListener('mouseenter', () => {
                            highlightEl.classList.add('highlight-active');
                        });
                        noteDiv.addEventListener('mouseleave', () => {
                            highlightEl.classList.remove('highlight-active');
                        });
                    });
                }
            };

            
            positionNotes();

            
            window.addEventListener('scroll', positionNotes);
            window.addEventListener('resize', positionNotes);
        });
    </script> <style>
        
        .post-content img {
            max-width: 100%;
            height: auto;
            display: block; 
            margin: 0 auto; 
        }

        

        #persistent-notes-overlay {
            position: fixed; 
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none; 
            z-index: 5; 
        }

        @media (max-width: 1200px) {
            #persistent-notes-overlay {
                display: none; 
            }
        }

        .persistent-note-item {
            pointer-events: auto; 
            
        }
    </style>  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" style="position: absolute; top: -9999px; left: -9999px;"> <defs> <filter id="dist-01"> <feTurbulence id="turbulence" baseFrequency="0.02" numOctaves="8" result="noise" seed="0"></feTurbulence> <feConvolveMatrix in="noise" order="3" result="snoise" kernelMatrix="
						0  -1   0
						-1   5  -1
						0  -1   0    
					"></feConvolveMatrix> <feDisplacementMap id="displacement" in="SourceGraphic" in2="snoise" scale="6"></feDisplacementMap> </filter> <filter id="dist-02"> <feTurbulence id="turbulence" baseFrequency="0.2" numOctaves="8" result="noise" seed="1"></feTurbulence> <feConvolveMatrix in="noise" order="3" result="snoise" kernelMatrix="
						0  -1   0
						-1   5  -1
						0  -1   0    
					"></feConvolveMatrix> <feDisplacementMap id="displacement" in="SourceGraphic" in2="snoise" scale="6"></feDisplacementMap> </filter> <filter id="dist-03"> <feTurbulence id="turbulence" baseFrequency="0.01" numOctaves="6" result="noise" seed="2"></feTurbulence> <feConvolveMatrix in="noise" order="3" result="snoise" kernelMatrix="
						0  -1   0
						-1   5  -1
						0  -1   0    
					"></feConvolveMatrix> <feDisplacementMap id="displacement" in="SourceGraphic" in2="snoise" scale="6"></feDisplacementMap> </filter> <filter id="dist-04"> <feTurbulence id="turbulence" baseFrequency="0.01" numOctaves="6" result="noise" seed="2" type="fractalNoise"></feTurbulence> <feDisplacementMap id="displacement" in="SourceGraphic" in2="noise" scale="6"></feDisplacementMap> </filter> <!-- Additional Glitch Filters for more variety --> <filter id="dist-05"> <feTurbulence baseFrequency="0.05" numOctaves="4" result="noise" seed="3"></feTurbulence> <feDisplacementMap in="SourceGraphic" in2="noise" scale="10"></feDisplacementMap> </filter> <filter id="dist-06"> <feTurbulence baseFrequency="0.1" numOctaves="2" result="noise" seed="4"></feTurbulence> <feDisplacementMap in="SourceGraphic" in2="noise" scale="8"></feDisplacementMap> </filter> <filter id="dist-07"> <feTurbulence baseFrequency="0.03" numOctaves="6" result="noise" seed="5" type="fractalNoise"></feTurbulence> <feDisplacementMap in="SourceGraphic" in2="noise" scale="12"></feDisplacementMap> </filter> <filter id="dist-08"> <feTurbulence baseFrequency="0.08" numOctaves="3" result="noise" seed="6"></feTurbulence> <feDisplacementMap in="SourceGraphic" in2="noise" scale="5"></feDisplacementMap> </filter> </defs> </svg> <script>
            document.addEventListener('DOMContentLoaded', () => {
                const glitchableElements = document.querySelectorAll('.glitchable');
                const filters = ['dist-01', 'dist-02', 'dist-03', 'dist-04', 'dist-05', 'dist-06', 'dist-07', 'dist-08'];

                glitchableElements.forEach(el => {
                    function applyGlitch() {
                        const randomFilterId = filters[Math.floor(Math.random() * filters.length)];
                        const glitchDuration = 0.08//Math.random() * (0.1 - 0.05) + 0.05; // Glitch lasts between 0.05 and 0.1 seconds
                        const delayBeforeNextGlitch = Math.random() * (6 - 3) + 3; // Next glitch in 0.5 to 2 seconds

                        el.style.filter = `url(#${randomFilterId})`;

                        setTimeout(() => {
                            el.style.filter = 'none';
                            setTimeout(applyGlitch, delayBeforeNextGlitch * 1000);
                        }, glitchDuration * 1000);
                    }

                    // Initial glitch after a random delay
                    setTimeout(applyGlitch, Math.random() * 3000); // Initial delay up to 3 seconds
                });

                // Theme switching logic
                const themeToggleBtn = document.getElementById('theme-toggle');
                const body = document.body;

                function toggleTheme() {
                    if (body.classList.contains('theme-red')) {
                        body.classList.remove('theme-red');
                        body.classList.add('theme-purple');
                        localStorage.setItem('theme', 'theme-purple');
                    } else if (body.classList.contains('theme-purple')) {
                        body.classList.remove('theme-purple');
                        body.classList.add('theme-blue');
                        localStorage.setItem('theme', 'theme-blue');
                    } else if (body.classList.contains('theme-blue')) {
                        body.classList.remove('theme-blue');
                        body.classList.add('theme-light');
                        localStorage.setItem('theme', 'theme-light');
                    } else {
                        body.classList.remove('theme-light');
                        body.classList.add('theme-red');
                        localStorage.setItem('theme', 'theme-red');
                    }
                }

                if (themeToggleBtn) {
                    themeToggleBtn.addEventListener('click', toggleTheme);
                }
            });
        </script> <script type="module">document.addEventListener("DOMContentLoaded",function(){document.querySelectorAll(".persistent-highlight").forEach(t=>{const s=t.dataset.noteId,o=t.dataset.noteText;if(!t||!s||!o)return;let e=null;e=document.createElement("div"),e.className="persistent-note-block",e.dataset.noteId=s,e.innerHTML=`<p>${o}</p>`;let n=t.closest("p");if(n===null){let a=t;for(;a&&a.nextElementSibling;)if(a=a.nextElementSibling,a.tagName==="P"){n=a;break}}n&&n.parentNode&&n.parentNode.insertBefore(e,n.nextSibling),t.addEventListener("mouseenter",()=>{e.classList.add("glow-active")}),t.addEventListener("mouseleave",()=>{e.classList.remove("glow-active")}),e.addEventListener("mouseenter",()=>{t.classList.add("highlight-active"),e.classList.add("glow-active")}),e.addEventListener("mouseleave",()=>{t.classList.remove("highlight-active"),e.classList.remove("glow-active")})})});</script> </body> </html>